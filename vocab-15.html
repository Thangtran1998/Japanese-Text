<!doctype html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Test Từ Vựng Ngày 15 - Cyberpunk Quiz</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;600&family=Share+Tech+Mono&display=swap"
    rel="stylesheet" />
  <style>
    /* ===== CYBER LOADING - ĐẶT TRONG HEAD ĐỂ HIỆN NGAY TỪ PIXEL ĐẦU TIÊN ===== */
    #cyberLoading {
      position: fixed;
      inset: 0;
      background: rgba(2, 8, 18, 0.98);
      backdrop-filter: blur(12px);
      z-index: 999999;
      display: flex;
      align-items: center;
      justify-content: center;
      visibility: visible;
      opacity: 1;
      transition: opacity 0.25s ease, visibility 0.25s ease;
    }

    #cyberLoading.hide {
      opacity: 0;
      visibility: hidden;
    }
  </style>
  <style>
    /* ===== RESET & VARIABLES ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary-glow: #00a8ff;
      --secondary-glow: #00ffcc;
      --danger-glow: #ff3366;
      --warning-glow: #ff9900;
      --bg-primary: #0a0e17;
      --bg-secondary: rgba(0, 20, 40, 0.6);
      --bg-tertiary: rgba(0, 30, 60, 0.5);
      --border-glow: rgba(0, 150, 255, 0.3);
      --text-primary: #e0f7ff;
      --text-secondary: #a0c8e0;
      --transition-smooth: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      --sidebar-width: 320px;
      --sidebar-collapsed-width: 60px;
    }

    body {
      font-family: "Exo 2", sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      background-image:
        radial-gradient(circle at 20% 30%,
          rgba(16, 64, 120, 0.15) 0%,
          transparent 20%),
        radial-gradient(circle at 80% 70%,
          rgba(0, 150, 200, 0.1) 0%,
          transparent 20%),
        linear-gradient(to bottom, #0a0e17, #0c1220);
      padding: 20px;
      max-width: 1600px;
      margin: auto;
      position: relative;
      z-index: 1;
    }

    /* ===== BACKGROUND EFFECTS ===== */
    .cyber-grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(rgba(0, 150, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 150, 255, 0.05) 1px, transparent 1px);
      background-size: 40px 40px;
      z-index: -1;
      opacity: 0.4;
    }

    .cyber-line {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .cyber-line::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 1px;
      background: linear-gradient(to right,
          transparent,
          #00ffcc,
          transparent);
      animation: scan 4s linear infinite;
    }

    @keyframes scan {
      0% {
        top: 0%;
      }

      100% {
        top: 100%;
      }
    }

    /* ===== FLOATING BUTTONS ===== */
    .floating-btn-container {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 15px;
      transition: var(--transition-smooth);
    }

    .floating-btn-container.left {
      left: 20px;
    }

    .floating-btn-container.right {
      right: 20px;
    }

    .floating-btn-container.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .floating-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: linear-gradient(135deg, #1a2a3a, #0f1a24);
      border: 2px solid var(--primary-glow);
      color: var(--primary-glow);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 0 20px rgba(0, 168, 255, 0.3);
      transition: var(--transition-smooth);
      position: relative;
    }

    .floating-btn:hover {
      transform: scale(1.1);
      border-color: var(--secondary-glow);
      color: var(--secondary-glow);
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.5);
    }

    .floating-btn .badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: linear-gradient(135deg, #ff3366, #ff0066);
      color: white;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      border: 2px solid var(--bg-primary);
    }

    .btn-tooltip {
      position: absolute;
      background: rgba(0, 20, 40, 0.95);
      color: var(--secondary-glow);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: var(--transition-smooth);
      border: 1px solid var(--border-glow);
      font-family: "Orbitron", sans-serif;
      font-weight: 500;
      backdrop-filter: blur(10px);
    }

    .floating-btn.left .btn-tooltip {
      left: 70px;
    }

    .floating-btn.right .btn-tooltip {
      right: 70px;
    }

    .floating-btn:hover .btn-tooltip {
      opacity: 1;
    }

    /* ===== SIDEBAR PANELS ===== */
    .sidebar-panel {
      position: fixed;
      top: 155px;
      bottom: 30px;
      width: var(--sidebar-width);
      background: rgba(0, 15, 30, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-glow);
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      z-index: 9998;
      transition: var(--transition-smooth);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      border-radius: 25px;
    }

    .sidebar-panel.left {
      left: 20px;
      transform: translateX(calc(var(--sidebar-collapsed-width) - var(--sidebar-width) - 20px));
      border-right: 2px solid var(--danger-glow);
    }

    .sidebar-panel.right {
      right: 20px;
      transform: translateX(calc(var(--sidebar-width) - var(--sidebar-collapsed-width) + 20px));
      border-left: 2px solid var(--primary-glow);
    }

    .sidebar-panel.left.active,
    .sidebar-panel.right.active {
      transform: translateX(0);
    }

    .sidebar-panel.left:not(.active) .sidebar-content,
    .sidebar-panel.right:not(.active) .sidebar-content {
      opacity: 0;
      visibility: hidden;
    }

    .sidebar-panel.left:not(.active) .sidebar-header,
    .sidebar-panel.right:not(.active) .sidebar-header {
      justify-content: center;
      padding: 20px 0;
      height: 100%;
      display: flex;
      align-items: center;
    }

    .sidebar-panel.left:not(.active) .sidebar-header h3 span,
    .sidebar-panel.right:not(.active) .sidebar-header h3 span {
      display: none;
    }

    .sidebar-panel.left:not(.active) .sidebar-header h3 i,
    .sidebar-panel.right:not(.active) .sidebar-header h3 i {
      margin: 0;
      font-size: 28px;
    }

    .sidebar-panel.left:not(.active) .sidebar-close,
    .sidebar-panel.right:not(.active) .sidebar-close {
      display: none;
    }

    .sidebar-toggle {
      position: absolute;
      width: 30px;
      height: 60px;
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      border: none;
      border-radius: 8px;
      color: #0a0e17;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: var(--transition-smooth);
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      top: 50%;
      transform: translateY(-50%);
    }

    .sidebar-panel.left.active .sidebar-toggle {
      right: -15px;
      display: flex;
    }

    .sidebar-panel.right.active .sidebar-toggle {
      left: -15px;
      display: flex;
    }

    .sidebar-toggle:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 25px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.3);
      transition: var(--transition-smooth);
    }

    .sidebar-header h3 {
      font-family: "Orbitron", sans-serif;
      color: var(--secondary-glow);
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
    }

    .sidebar-close {
      background: rgba(255, 50, 50, 0.2);
      border: 1px solid rgba(255, 50, 50, 0.5);
      color: #ff6666;
      width: 36px;
      height: 36px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s;
      font-family: Orbitron, sans-serif;
    }

    .sidebar-close:hover {
      background: rgba(255, 50, 50, 0.4);
      box-shadow: 0 0 10px rgba(255, 50, 50, 0.4);
      transform: translateY(-1px);
    }

    .sidebar-close i {
      font-size: 16px;
      /* Điều chỉnh kích thước icon nếu cần */
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
      transition: var(--transition-smooth);
    }

    /* ===== MAIN CONTENT WRAPPER ===== */
    .main-content-wrapper {
      margin-left: calc(var(--sidebar-collapsed-width) + 20px);
      margin-right: calc(var(--sidebar-collapsed-width) + 20px);
      transition: var(--transition-smooth);
      padding: 20px;
      margin-top: 20px;
    }

    .main-content-wrapper.left-expanded {
      margin-left: calc(var(--sidebar-width) + 40px);
    }

    .main-content-wrapper.right-expanded {
      margin-right: calc(var(--sidebar-width) + 40px);
    }

    .main-quiz-container {
      background: rgba(0, 20, 40, 0.6);
      border-radius: 16px;
      padding: 30px;
      border: 1px solid var(--border-glow);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }

    .main-quiz-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(to right,
          var(--primary-glow),
          var(--secondary-glow));
    }

    /* ===== QUIZ STYLES ===== */
    .question-block {
      background: var(--bg-tertiary);
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 25px;
      border: 1px solid rgba(0, 150, 255, 0.2);
      transition: var(--transition-smooth);
      position: relative;
    }

    .question-block:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0, 100, 255, 0.3);
      border-color: var(--primary-glow);
    }

    /* Bookmark star (top-right of each question) */
    .bookmark-star {
      position: absolute;
      top: 12px;
      right: 12px;
      font-size: 20px;
      color: rgba(255,255,255,0.5);
      cursor: pointer;
      transition: transform 0.15s ease, color 0.15s ease;
      user-select: none;
      z-index: 5;
    }

    .bookmark-star.starred { color: gold; transform: scale(1.08); }

    .question-number {
      font-size: 20px;
      font-weight: 700;
      color: var(--secondary-glow);
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .question-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .answer-option {
      display: block;
      margin-bottom: 12px;
      padding: 15px 20px;
      background: rgba(0, 40, 80, 0.4);
      border: 1px solid rgba(0, 150, 255, 0.2);
      border-radius: 10px;
      color: var(--text-primary);
      cursor: pointer;
      transition: var(--transition-smooth);
    }

    .answer-option:hover {
      background: rgba(0, 80, 160, 0.5);
      border-color: var(--primary-glow);
      transform: translateX(8px);
      box-shadow: 0 5px 15px rgba(0, 100, 255, 0.3);
    }

    .answer-option input[type="radio"] {
      margin-right: 15px;
      transform: scale(1.2);
      accent-color: var(--secondary-glow);
    }

    .detail-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      color: #0a0e17;
      border: none;
      border-radius: 8px;
      font-family: "Orbitron", sans-serif;
      font-weight: 600;
      cursor: pointer;
      margin-top: 15px;
      transition: var(--transition-smooth);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .detail-btn:hover {
      background: linear-gradient(135deg,
          var(--secondary-glow),
          var(--primary-glow));
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
      transform: translateY(-2px);
    }

    /* ===== READING COMPREHENSION ===== */
    .reading-comprehension {
      background: rgba(0, 30, 80, 0.6);
      border-left: 4px solid var(--secondary-glow);
      padding: 25px;
      border-radius: 12px;
      position: relative;
      margin-bottom: 20px;
      padding-top: 70px;
    }

    .reading-title {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.2);
      position: relative;
      z-index: 5;
    }

    .reading-timer-container {
      position: absolute;
      top: 15px;
      right: 25px;
      width: 350px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-glow);
      border-radius: 30px;
      padding: 8px 15px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 20;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      transition: var(--transition-smooth);
    }

    .highlight-controls {
      position: absolute;
      top: 15px;
      right: 400px;
      display: flex;
      gap: 8px;
      background: rgba(0, 20, 40, 0.9);
      padding: 8px 15px;
      border-radius: 30px;
      border: 1px solid var(--border-glow);
      z-index: 20;
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      align-items: center;
      height: 46px;
      width: auto;
    }

    .highlight-btn {
      width: 30px;
      height: 30px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .highlight-btn:hover {
      transform: scale(1.15);
      box-shadow: 0 0 15px currentColor;
      border-color: white;
    }

    .highlight-btn.red {
      background-color: #ff3333;
      color: white;
    }

    .highlight-btn.blue {
      background-color: #00a8ff;
      color: white;
    }

    .highlight-btn.purple {
      background-color: #aa00ff;
      color: white;
    }

    .highlight-btn.black {
      background-color: #000000;
      color: white;
      border-color: rgba(255, 255, 255, 0.5);
    }

    .highlight-btn.remove-btn {
      background: linear-gradient(135deg, #ff3333, #ff6600);
      color: white;
      font-size: 16px;
      font-weight: bold;
    }

    .reading-timer-input {
      width: 50px;
      height: 32px;
      background: rgba(0, 10, 25, 0.9);
      border: 1px solid rgba(0, 150, 255, 0.4);
      border-radius: 20px;
      color: var(--text-primary);
      text-align: center;
      font-size: 13px;
      padding: 0 8px;
      transition: var(--transition-smooth);
    }

    .reading-timer-input:focus {
      outline: none;
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    .reading-timer-btn {
      padding: 6px 14px;
      background: linear-gradient(135deg, #0066cc, var(--primary-glow));
      border: none;
      border-radius: 20px;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      font-weight: 500;
      white-space: nowrap;
    }

    .reading-timer-btn i {
      font-size: 11px;
    }

    .reading-timer-btn:hover {
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 168, 255, 0.4);
    }

    .reading-timer-display {
      font-family: "Orbitron", sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: var(--secondary-glow);
      padding: 0 8px;
      min-width: 60px;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 20px;
      padding: 4px 10px;
      border: 1px solid rgba(0, 255, 204, 0.3);
      letter-spacing: 1px;
    }

    .reading-label {
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      color: #0a0e17;
      padding: 5px 18px;
      border-radius: 30px;
      font-family: "Orbitron", sans-serif;
      font-weight: 700;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 15px rgba(0, 168, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.3);
      position: relative;
      overflow: hidden;
      transition: var(--transition-smooth);
      animation: reading-pulse 3s infinite ease-in-out;
    }

    .reading-label::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent);
      transition: left 0.5s ease;
    }

    .reading-label:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
    }

    .reading-label:hover::before {
      left: 100%;
    }

    @keyframes reading-pulse {
      0% {
        box-shadow: 0 0 15px rgba(0, 168, 255, 0.3);
      }

      50% {
        box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
      }

      100% {
        box-shadow: 0 0 15px rgba(0, 168, 255, 0.3);
      }
    }

    .sub-question-container {
      margin: 25px 0 15px 25px;
      padding-left: 20px;
      border-left: 3px solid rgba(0, 150, 255, 0.3);
    }

    .sub-question-box {
      background: rgba(0, 40, 80, 0.4);
      border: 1px solid rgba(0, 150, 255, 0.2);
      border-radius: 10px;
      padding: 20px;
      margin-top: 15px;
    }

    .sub-question-box p {
      font-weight: 600;
      color: var(--secondary-glow);
      margin-bottom: 15px;
      font-size: 17px;
    }

    .sub-question-options {
      margin-top: 15px;
    }

    .sub-question-key {
      font-size: 12px;
      color: #888;
      margin-left: 10px;
      font-family: monospace;
    }

    /* ===== QUIZ HISTORY ===== */
    #quizHistory {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 15px;
    }

    #quizHistory li {
      background: rgba(0, 40, 80, 0.5);
      padding: 10px;
      margin-bottom: 8px;
      border-radius: 6px;
      border-left: 3px solid var(--primary-glow);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* ===== WRONG ANSWERS LIST ===== */
    .wrong-answers-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .wrong-answer-item {
      background: rgba(255, 51, 51, 0.1);
      border-left: 4px solid #ff3366;
      padding: 15px;
      border-radius: 8px;
      transition: var(--transition-smooth);
    }

    .wrong-answer-item:hover {
      background: rgba(255, 51, 51, 0.2);
      transform: translateX(5px);
    }

    /* ===== BUTTON STYLES ===== */
    .cyber-button {
      width: 100%;
      padding: 12px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #0066cc, var(--primary-glow));
      color: white;
      border: none;
      border-radius: 10px;
      font-family: "Orbitron", sans-serif;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .cyber-button::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent);
      transition: left 0.5s;
    }

    .cyber-button:hover {
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      transform: translateY(-2px);
      box-shadow: 0 0 20px rgba(0, 168, 255, 0.5);
    }

    .cyber-button:hover::before {
      left: 100%;
    }

    /* ===== DETAIL POPUP (GIẢI THÍCH) - NEW STYLE ===== */
    .detail-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(760px, 94vw);
      max-height: 82vh;
      overflow: hidden;

      background: rgba(0, 18, 36, 0.98);
      border: 3px solid rgba(0, 255, 204, 0.65);
      /* ✅ viền dày */
      border-radius: 18px;

      box-shadow:
        0 25px 60px rgba(0, 0, 0, 0.85),
        0 0 30px rgba(0, 255, 204, 0.18);
      backdrop-filter: blur(18px);

      z-index: 200000;
      animation: popup-appear 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .detail-popup::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      height: 5px;
      width: 100%;
      background: linear-gradient(90deg,
          var(--primary-glow),
          var(--secondary-glow));
      opacity: 0.9;
    }

    .detail-popup-inner {
      padding: 22px 22px 18px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .detail-popup-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.22);
    }

    .detail-popup-title {
      margin: 0;
      font-family: Orbitron, sans-serif;
      color: var(--secondary-glow);
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* ✅ Nút Đóng giống hệt style bạn đưa */
    .detail-popup-close.test-modal-close {
      background: rgba(255, 50, 50, 0.2);
      border: 1px solid rgba(255, 50, 50, 0.5);
      color: #ff6666;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.25s;
      font-size: 13px;
      font-family: Orbitron, sans-serif;
    }

    .detail-popup-close.test-modal-close:hover {
      background: rgba(255, 50, 50, 0.4);
      box-shadow: 0 0 10px rgba(255, 50, 50, 0.4);
      transform: translateY(-1px);
    }

    /* Nội dung cuộn */
    .detail-popup .detail-scroll {
      overflow-y: auto;
      max-height: calc(82vh - 120px);
      padding-right: 10px;
      line-height: 1.85;
      font-size: 16px;

      background: rgba(0, 0, 0, 0.18);
      border: 1px solid rgba(0, 255, 204, 0.18);
      border-radius: 12px;
      padding: 14px 14px;
    }

    /* Scrollbar đẹp (Chrome/Edge) */
    .detail-popup .detail-scroll::-webkit-scrollbar {
      width: 10px;
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 204, 0.35);
      border-radius: 10px;
      border: 2px solid rgba(0, 18, 36, 0.98);
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    }

    /* ===== DETAIL POPUP SCROLL ===== */
    .detail-popup .detail-scroll {
      overflow-y: auto;
      max-height: calc(80vh - 120px);
      /* trừ phần header + padding */
      padding-right: 10px;
      /* chừa chỗ cho scrollbar */
    }

    /* (Tuỳ chọn) làm scrollbar đẹp hơn trên Chrome/Edge */
    .detail-popup .detail-scroll::-webkit-scrollbar {
      width: 10px;
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 204, 0.35);
      border-radius: 10px;
      border: 2px solid rgba(0, 20, 40, 0.98);
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    }

    /* Dark mode toggle removed */

    /* ===== CORRECT / WRONG ANSWER STYLES ===== */
    .correct-answer {
      color: #2e7d32;
      font-weight: bold;
      margin-left: 8px;
    }

    .wrong-answer {
      color: #c62828;
      font-weight: bold;
      margin-left: 8px;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .sidebar-panel {
        width: 100%;
        left: 0 !important;
        right: 0 !important;
        top: 0 !important;
        bottom: 0 !important;
        border-radius: 0;
      }

      .main-content-wrapper {
        margin-left: 0 !important;
        margin-right: 0 !important;
      }

      .floating-btn-container {
        display: none;
      }

      .highlight-controls {
        position: relative;
        top: auto;
        right: auto;
        margin-top: 15px;
      }
    }

    @media (max-width: 900px) {
      .reading-timer-container {
        position: relative;
        top: auto;
        right: auto;
        width: 100%;
        margin-top: 15px;
        margin-bottom: 10px;
        border-radius: 15px;
      }

      .highlight-controls {
        position: relative;
        top: auto;
        right: auto;
        width: 100%;
        margin-top: 10px;
        margin-bottom: 15px;
        justify-content: center;
        height: auto;
      }

      .reading-comprehension {
        padding-top: 25px;
      }
    }

    /* ===== BACK TO TOP BUTTON ===== */
    #backToTopBtn {
      position: fixed;
      bottom: 30px;
      /* nằm phía trên nút dark mode để không đè nhau */
      right: 10px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 20, 40, 0.95);
      border: 2px solid var(--secondary-glow);
      color: var(--secondary-glow);
      cursor: pointer;
      font-size: 22px;
      z-index: 10002;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.25);
      backdrop-filter: blur(10px);
      transition: var(--transition-smooth);

      /* ẩn mặc định */
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transform: translateY(10px);
    }

    #backToTopBtn.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transform: translateY(0);
    }

    #backToTopBtn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.45);
      border-color: var(--primary-glow);
      color: var(--primary-glow);
    }

    /* ===== FIREWORKS EFFECT ===== */
    .fireworks-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999999;
    }

    .firework-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      animation: firework-explode 1.5s ease-out forwards;
    }

    @keyframes firework-explode {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }

      100% {
        transform: translate(var(--tx), var(--ty)) scale(0.2);
        opacity: 0;
      }
    }

    /* Hiệu ứng confetti rơi (thay thế hoặc bổ sung) */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      position: fixed;
      top: -10px;
      z-index: 999999;
      animation: confetti-fall linear forwards;
    }

    @keyframes confetti-fall {
      to {
        transform: translateY(100vh) rotate(720deg);
      }
    }

    @keyframes bounce {
      from {
        transform: translateX(-50%) translateY(0);
      }

      to {
        transform: translateX(-50%) translateY(-20px);
      }
    }

    /* Khóa scroll ngoài khi mở popup */
    body.modal-open {
      overflow: hidden;
    }

    /* (Tuỳ chọn) mượt hơn trên mobile */
    body.modal-open {
      touch-action: none;
    }

    /* ===== RESULT POPUP - GIỐNG DETAIL POPUP ===== */
    .result-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(500px, 90vw);
      max-height: 82vh;
      overflow: hidden;

      background: rgba(0, 18, 36, 0.98);

      /* 2 ĐƯỜNG VIỀN */
      border: 6px solid #00ffcc;
      /* Viền ngoài dày */
      outline: 4px solid rgba(255, 102, 0, 0.3);
      /* Viền trong mờ */
      outline-offset: -10px;
      /* Điều chỉnh vị trí viền trong */

      border-radius: 24px;

      box-shadow:
        0 25px 60px rgba(0, 0, 0, 0.85),
        0 0 40px rgba(255, 102, 0, 0.5);
      backdrop-filter: blur(18px);

      z-index: 200000;
      animation: popup-appear 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .result-popup-inner {
      padding: 22px 22px 18px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .result-popup-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.22);
    }

    .result-popup-title {
      margin: 0;
      font-family: Orbitron, sans-serif;
      color: var(--secondary-glow);
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
      text-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    .result-popup-content {
      overflow-y: auto;
      max-height: calc(82vh - 120px);
      padding-right: 10px;

      background: transparent;
      /* KHÔNG tô màu đặc */
      border: 1px solid rgba(0, 255, 204, 0.18);
      border-radius: 12px;
      padding: 20px 20px;
      text-align: center;
    }

    /* Scrollbar đẹp cho result popup */
    .result-popup-content::-webkit-scrollbar {
      width: 10px;
    }

    .result-popup-content::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 204, 0.35);
      border-radius: 10px;
      border: 2px solid rgba(0, 18, 36, 0.98);
    }

    .result-popup-content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    }

    /* Hiệu ứng đặc biệt cho điểm 100% */
    .result-popup.perfect-score {
      animation:
        popup-appear 0.3s,
        glow-pulse 1s infinite;
      border-color: gold;
      box-shadow: 0 0 80px gold;
    }

    @keyframes glow-pulse {

      0%,
      100% {
        box-shadow: 0 0 50px gold;
      }

      50% {
        box-shadow: 0 0 100px #ffaa00;
      }
    }

    /* Trophy icon styling */
    .result-popup .fa-trophy {
      font-size: 50px;
      color: #ffd700;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.5));
    }

    /* Score styling */
    #popupScore {
      font-size: 56px;
      font-weight: 900;
      font-family: "Orbitron", sans-serif;
      color: var(--secondary-glow);
      text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
      margin: 15px 0;
      letter-spacing: 2px;
    }

    /* Comment styling */
    #popupComment {
      font-size: 20px;
      color: var(--text-primary);
      padding: 15px 20px;
      background: linear-gradient(135deg,
          rgba(0, 150, 255, 0.1),
          rgba(0, 255, 204, 0.1));
      border-radius: 50px;
      display: inline-block;
      border: 1px solid rgba(0, 255, 204, 0.3);
    }

    /* Hiệu ứng đặc biệt cho điểm 100% */
    .result-popup.perfect-score {
      animation:
        popup-appear 0.3s,
        glow-pulse 1s infinite;
      border-color: gold;
      box-shadow: 0 0 80px gold;
    }

    @keyframes glow-pulse {

      0%,
      100% {
        box-shadow: 0 0 50px gold;
      }

      50% {
        box-shadow: 0 0 100px #ffaa00;
      }
    }


    /* ===== HUD RESULT PANEL ===== */
    :root {
      --hud-cyan: #00e5ff;
      --hud-cyan-glow: rgba(0, 229, 255, 0.6);
      --hud-green: #00ff88;
      --hud-green-glow: rgba(0, 255, 136, 0.8);
      --hud-red: #ff2d55;
      --hud-gold: #ffc107;
    }

    .hud-result-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(580px, 96vw);
      background: rgba(0, 15, 35, 0.95);
      padding: 32px 36px 28px;
      z-index: 200000;
      backdrop-filter: blur(16px);
      animation: hudPanelIn 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
      font-family: 'Orbitron', monospace;
    }

    @keyframes hudPanelIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9) translateY(16px);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1) translateY(0);
      }
    }

    /* L-corners */
    .hud-corner {
      position: absolute;
    }

    .hud-corner span {
      position: absolute;
      background: var(--hud-cyan);
      box-shadow: 0 0 7px var(--hud-cyan-glow);
      display: block;
    }

    .hud-corner span.h {
      width: 22px;
      height: 2.5px;
    }

    .hud-corner span.v {
      width: 2.5px;
      height: 22px;
    }

    .hud-corner-tl {
      top: 0;
      left: 0;
    }

    .hud-corner-tl span.h {
      top: 0;
      left: 0;
    }

    .hud-corner-tl span.v {
      top: 0;
      left: 0;
    }

    .hud-corner-tr {
      top: 0;
      right: 0;
    }

    .hud-corner-tr span.h {
      top: 0;
      right: 0;
    }

    .hud-corner-tr span.v {
      top: 0;
      right: 0;
    }

    .hud-corner-bl {
      bottom: 0;
      left: 0;
    }

    .hud-corner-bl span.h {
      bottom: 0;
      left: 0;
    }

    .hud-corner-bl span.v {
      bottom: 0;
      left: 0;
    }

    .hud-corner-br {
      bottom: 0;
      right: 0;
    }

    .hud-corner-br span.h {
      bottom: 0;
      right: 0;
    }

    .hud-corner-br span.v {
      bottom: 0;
      right: 0;
    }

    /* Scan bar */
    .hud-scan-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--hud-cyan), transparent);
      animation: hudScanMove 3s linear infinite;
    }

    @keyframes hudScanMove {
      0% {
        top: 0;
        opacity: 1;
      }

      95% {
        opacity: 1;
      }

      100% {
        top: 100%;
        opacity: 0;
      }
    }

    /* Header */
    .hud-result-header {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      min-height: 34px;
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid;
      border-image: linear-gradient(90deg, transparent, var(--hud-cyan), transparent) 1;
    }

    .hud-result-title {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1rem;
      letter-spacing: 0.25em;
      color: var(--hud-cyan);
      text-shadow: 0 0 18px var(--hud-cyan), 0 0 38px var(--hud-cyan-glow);
      white-space: nowrap;
      pointer-events: none;
    }

    .hud-btn-close {
      height: 28px;
      padding: 0 14px;
      background: transparent;
      border: 1px solid var(--hud-red);
      color: var(--hud-red);
      font-family: 'Orbitron', monospace;
      font-size: 0.6rem;
      font-weight: 700;
      letter-spacing: 1.5px;
      cursor: pointer;
      clip-path: polygon(6px 0%, 100% 0%, calc(100% - 6px) 100%, 0% 100%);
      transition: all .2s;
      text-shadow: 0 0 6px rgba(255, 45, 85, 0.6);
      box-shadow: 0 0 8px rgba(255, 45, 85, 0.15);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .hud-btn-close:hover {
      background: rgba(255, 45, 85, 0.15);
      box-shadow: 0 0 18px rgba(255, 45, 85, 0.5);
      color: #fff;
    }

    /* Status dot */
    .hud-res-status {
      display: flex;
      align-items: center;
      gap: 7px;
      justify-content: center;
      font-family: 'Share Tech Mono', monospace;
      font-size: 9px;
      letter-spacing: 2.5px;
      color: var(--hud-cyan);
      opacity: .75;
      margin-bottom: 14px;
    }

    .hud-res-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--hud-green);
      box-shadow: 0 0 6px var(--hud-green-glow);
      animation: hudDotPulse 1.5s ease-in-out infinite;
      flex-shrink: 0;
    }

    @keyframes hudDotPulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: .3;
        transform: scale(.6);
      }
    }

    /* Clock ring wrap */
    .hud-res-score-wrap {
      display: flex;
      justify-content: center;
      margin-bottom: 18px;
    }

    .hud-res-clock {
      position: relative;
      width: 190px;
      height: 190px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hud-res-ring-outer {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 3px solid var(--hud-cyan);
      box-shadow: 0 0 12px var(--hud-cyan-glow), 0 0 30px rgba(0, 229, 255, 0.15), inset 0 0 12px rgba(0, 229, 255, 0.07);
      animation: hudResRingPulse 3s ease-in-out infinite;
    }

    @keyframes hudResRingPulse {

      0%,
      100% {
        box-shadow: 0 0 12px var(--hud-cyan-glow), 0 0 30px rgba(0, 229, 255, 0.15), inset 0 0 12px rgba(0, 229, 255, 0.07);
      }

      50% {
        box-shadow: 0 0 22px var(--hud-cyan-glow), 0 0 55px rgba(0, 229, 255, 0.28), inset 0 0 20px rgba(0, 229, 255, 0.13);
      }
    }

    .hud-res-ring-outer.yellow {
      border-color: var(--hud-gold) !important;
      box-shadow: 0 0 12px rgba(255, 193, 7, 0.7), 0 0 30px rgba(255, 193, 7, 0.2) !important;
      animation: hudResRingPulseYellow 3s ease-in-out infinite !important;
    }

    @keyframes hudResRingPulseYellow {

      0%,
      100% {
        box-shadow: 0 0 12px rgba(255, 193, 7, 0.7), 0 0 30px rgba(255, 193, 7, 0.2);
      }

      50% {
        box-shadow: 0 0 24px rgba(255, 193, 7, 0.9), 0 0 55px rgba(255, 193, 7, 0.35);
      }
    }

    .hud-res-ring-outer.red-blink {
      border-color: var(--hud-red) !important;
      animation: hudResRingBlink 0.7s step-start infinite !important;
    }

    @keyframes hudResRingBlink {

      0%,
      100% {
        box-shadow: 0 0 16px rgba(255, 45, 85, 0.8), 0 0 30px rgba(255, 45, 85, 0.3);
        opacity: 1;
      }

      50% {
        box-shadow: none;
        opacity: 0.3;
      }
    }

    /* Progress SVG */
    .hud-res-progress-svg {
      position: absolute;
      inset: -8px;
      width: calc(100% + 16px);
      height: calc(100% + 16px);
      transform: rotate(-90deg);
      pointer-events: none;
    }

    .hud-res-track {
      fill: none;
      stroke: rgba(0, 229, 255, 0.1);
      stroke-width: 8;
    }

    .hud-res-bar {
      fill: none;
      stroke: var(--hud-cyan);
      stroke-width: 8;
      stroke-linecap: round;
      filter: drop-shadow(0 0 5px var(--hud-cyan));
      stroke-dasharray: 647;
      stroke-dashoffset: 647;
      transition: stroke 0.5s, stroke-dashoffset 1.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .hud-res-bar.yellow {
      stroke: var(--hud-gold);
      filter: drop-shadow(0 0 5px var(--hud-gold));
    }

    .hud-res-bar.red {
      stroke: var(--hud-red);
      filter: drop-shadow(0 0 5px var(--hud-red));
      animation: hudBarBlink 0.7s step-start infinite;
    }

    @keyframes hudBarBlink {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.2
      }
    }

    /* Inner dashed ring */
    .hud-res-ring-inner {
      position: absolute;
      inset: 10px;
      border-radius: 50%;
      border: 1px dashed rgba(0, 229, 255, 0.22);
    }

    /* Ticks */
    .hud-res-ticks-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Accents */
    .hud-res-accent {
      position: absolute;
      width: 13px;
      height: 13px;
      border-color: var(--hud-cyan);
      border-style: solid;
      opacity: 0.55;
    }

    .hud-res-accent.tl {
      top: 11px;
      left: 11px;
      border-width: 1.5px 0 0 1.5px;
    }

    .hud-res-accent.tr {
      top: 11px;
      right: 11px;
      border-width: 1.5px 1.5px 0 0;
    }

    .hud-res-accent.bl {
      bottom: 11px;
      left: 11px;
      border-width: 0 0 1.5px 1.5px;
    }

    .hud-res-accent.br {
      bottom: 11px;
      right: 11px;
      border-width: 0 1.5px 1.5px 0;
    }

    /* Face */
    .hud-res-face {
      position: relative;
      width: 118px;
      height: 118px;
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0, 229, 255, 0.05) 0%, rgba(0, 0, 0, 0.97) 70%);
      border: 1px solid rgba(0, 229, 255, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* 7-seg */
    .hud-res-seg-display {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .hud-res-seg-digit {
      position: relative;
      width: 22px;
      height: 38px;
    }

    .hud-res-seg-svg {
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    .hud-res-seg-pct {
      font-family: 'Orbitron', monospace;
      font-size: 1.1rem;
      font-weight: 900;
      color: #ffc107;
      text-shadow: 0 0 10px #ffc107, 0 0 20px rgba(255, 193, 7, 0.5);
      align-self: flex-end;
      padding-bottom: 3px;
    }

    /* PERFECT */
    .hud-res-perfect {
      text-align: center;
      font-size: 1.9rem;
      font-weight: 900;
      letter-spacing: 0.15em;
      background: linear-gradient(90deg, var(--hud-red), var(--hud-gold), var(--hud-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 18px;
      animation: hudPerfectGlow 2s ease-in-out infinite alternate;
    }

    @keyframes hudPerfectGlow {
      from {
        filter: brightness(1);
      }

      to {
        filter: brightness(1.4) drop-shadow(0 0 12px var(--hud-gold));
      }
    }

    /* Stats */
    .hud-res-stats {
      display: grid;
      grid-template-columns: 1fr auto 1fr auto 1fr;
      text-align: center;
    }

    .hud-res-stat {
      padding: 10px 8px;
    }

    .hud-res-stat-label {
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.6rem;
      letter-spacing: 0.15em;
      color: rgba(0, 229, 255, 0.6);
      margin-bottom: 4px;
    }

    .hud-res-stat-value {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .hud-res-stat-value.correct {
      color: var(--hud-green);
      text-shadow: 0 0 12px var(--hud-green-glow);
    }

    .hud-res-stat-value.wrong {
      color: var(--hud-red);
      text-shadow: 0 0 10px rgba(255, 45, 85, 0.5);
    }

    .hud-res-stat-value.time {
      color: var(--hud-cyan);
    }

    .hud-res-divider {
      width: 1px;
      background: linear-gradient(to bottom, transparent, var(--hud-cyan), transparent);
      margin: 8px 0;
      align-self: stretch;
    }

    /* ===== TIME UP ALERT - CŨNG CẦN THÊM ===== */
    .time-up-alert {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #d32f2f, #b71c1c);
      color: white;
      padding: 30px 50px;
      border-radius: 20px;
      font-size: 28px;
      font-weight: bold;
      z-index: 200000;
      box-shadow: 0 0 50px rgba(211, 47, 47, 0.5);
      border: 2px solid #ff8a80;
      text-align: center;
      animation: popup-appear 0.3s;
    }

    /* Overlay làm tối màn hình */
    .result-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      /* Độ tối 70% */
      backdrop-filter: blur(5px);
      /* Hiệu ứng mờ (tùy chọn) */
      z-index: 199999;
      /* Thấp hơn popup một chút */
      display: none;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* ===== MAIN AUDIO PLAYER STYLES ===== */
    #mainAudioSelect {
      outline: none;
      transition: var(--transition-smooth);
    }

    #mainAudioSelect:hover {
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    #mainAudioSelect option {
      background: #0a0e17;
      color: var(--text-primary);
    }

    #mainPlayPauseBtn {
      background: linear-gradient(135deg, #00cc66, #00ff88);
      border: none;
      border-radius: 5px;
      color: #0a0e17;
      padding: 8px 15px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: var(--transition-smooth);
    }

    #mainPlayPauseBtn:hover {
      background: linear-gradient(135deg, #00ff88, var(--secondary-glow));
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
    }

    #mainPlayPauseBtn.playing {
      background: linear-gradient(135deg, #ff3333, #ff6600);
    }

    #mainVolumeSlider {
      -webkit-appearance: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      height: 4px;
      background: linear-gradient(90deg,
          var(--primary-glow),
          var(--secondary-glow));
      border-radius: 2px;
      outline: none;
    }

    #mainVolumeSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--secondary-glow);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 0 10px var(--secondary-glow);
    }

    /* Responsive */
    @media (max-width: 900px) {
      .main-quiz-container>div:first-child {
        flex-direction: column;
        gap: 15px;
      }

      .main-quiz-container>div:first-child>div {
        width: 100%;
        flex-wrap: wrap;
      }

      #mainAudioSelect {
        min-width: 150px;
      }
    }

    /* ===== CUSTOM SEEK BAR STYLES ===== */
    #mainSeekBar {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: linear-gradient(90deg,
          var(--primary-glow),
          var(--secondary-glow));
      border-radius: 3px;
      outline: none;
    }

    #mainSeekBar::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 2px solid var(--secondary-glow);
      box-shadow: 0 0 10px var(--secondary-glow);
      transition: all 0.2s;
    }

    #mainSeekBar::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px var(--secondary-glow);
    }

    #mainSeekBar::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 2px solid var(--secondary-glow);
      box-shadow: 0 0 10px var(--secondary-glow);
      transition: all 0.2s;
    }

    #mainSeekBar::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px var(--secondary-glow);
    }

    /* Speed select styling */
    #mainSpeedSelect {
      background: rgba(0, 10, 25, 0.9);
      color: var(--text-primary);
      border: 1px solid rgba(0, 150, 255, 0.4);
      border-radius: 5px;
      padding: 5px;
      cursor: pointer;
      outline: none;
      transition: all 0.3s;
    }

    #mainSpeedSelect:hover {
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    #mainSpeedSelect option {
      background: #0a0e17;
      color: var(--text-primary);
    }

    /* ===== CUSTOM DROPDOWN STYLES ===== */
    #mainAudioSelect {
      background: rgba(0, 10, 25, 0.9);
      color: var(--text-primary);
      border: 1px solid rgba(0, 150, 255, 0.6);
      border-radius: 5px;
      padding: 8px 15px;
      min-width: 250px;
      cursor: pointer;
      outline: none;
      font-family: monospace;
      transition: all 0.3s;
    }

    #mainAudioSelect:hover {
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    #mainAudioSelect option {
      background: #0a0e17;
      color: var(--text-primary);
      padding: 10px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #mainAudioSelect {
        min-width: 100%;
        margin-bottom: 10px;
      }
    }

    /* Style cho option disabled */
    #mainAudioSelect option:disabled {
      color: #ff6666;
      font-style: italic;
      background: rgba(255, 50, 50, 0.1);
    }

    /* ===== HUD TIMER EXTRA VARS ===== */
    :root {
      --cyan: #00e5ff;
      --cyan-glow: rgba(0, 229, 255, 0.6);
      --green: #00ff88;
      --green-glow: rgba(0, 255, 136, 0.8);
      --seg-on: #00ff88;
      --seg-off: rgba(0, 255, 136, 0.07);
    }

    /* Scanlines overlay */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0, 0, 0, 0.03) 3px, rgba(0, 0, 0, 0.03) 4px);
      pointer-events: none;
      z-index: 9999;
    }

    /* ================================================================
         TITLE BLOCK WRAPPER
      ================================================================ */
    .hq-title-block {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      position: relative;
      user-select: none;
    }

    /* --- TICKER --- */
    .hq-ticker {
      width: 100%;
      overflow: hidden;
      border-top: 1px solid rgba(0, 255, 204, 0.18);
      border-bottom: 1px solid rgba(0, 255, 204, 0.18);
      background: rgba(0, 255, 204, 0.03);
      padding: 5px 0;
      margin-bottom: 18px;
      opacity: 0;
      animation: hq-fadein 0.5s 0.1s ease forwards;
    }

    .hq-ticker-inner {
      display: flex;
      gap: 0;
      white-space: nowrap;
      animation: hq-ticker-scroll 22s linear infinite;
    }

    .hq-ticker-item {
      font-family: 'Share Tech Mono', monospace;
      font-size: 11px;
      color: rgba(0, 255, 204, 0.5);
      letter-spacing: 2px;
      padding: 0 32px;
    }

    .hq-ticker-item b {
      color: rgba(0, 255, 204, 0.9);
    }

    @keyframes hq-ticker-scroll {
      0% {
        transform: translateX(0)
      }

      100% {
        transform: translateX(-50%)
      }
    }

    /* ================================================================
         MAIN CARD — 2 columns
      ================================================================ */
    .hq-title-card {
      position: relative;
      width: 90%;
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr 2fr;
      align-items: stretch;
      background: linear-gradient(180deg, rgba(0, 40, 80, 0.55) 0%, rgba(0, 20, 50, 0.35) 60%, transparent 100%);
      border-top: 2px solid transparent;
      border-image: linear-gradient(90deg, transparent 0%, rgba(0, 168, 255, 0.6) 20%, rgba(0, 255, 204, 0.9) 50%, rgba(0, 168, 255, 0.6) 80%, transparent 100%) 1;
      overflow: visible;
    }

    .hq-col-sep {
      position: absolute;
      left: 33.33%;
      top: 12px;
      bottom: 12px;
      width: 1px;
      background: linear-gradient(180deg, transparent, rgba(0, 255, 204, 0.3) 20%, rgba(0, 255, 204, 0.3) 80%, transparent);
    }

    .hq-corner {
      position: absolute;
      width: 28px;
      height: 28px;
      opacity: 0;
      animation: hq-fadein 0.4s ease forwards;
    }

    .hq-corner.tl {
      top: -1px;
      left: 0;
      animation-delay: 0.6s;
    }

    .hq-corner.tr {
      top: -1px;
      right: 0;
      animation-delay: 0.7s;
      transform: scaleX(-1);
    }

    .hq-corner line {
      stroke: #00ffcc;
      stroke-width: 2;
    }

    /* ================================================================
         LEFT COLUMN — HUD Timer
      ================================================================ */
    .hq-timer-col {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px 20px;
      gap: 0;
    }

    .hud-status {
      display: flex;
      align-items: center;
      gap: 7px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 9px;
      letter-spacing: 2.5px;
      color: var(--cyan);
      text-shadow: 0 0 8px var(--cyan-glow);
      opacity: .8;
      margin-bottom: 12px;
    }

    .hud-status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--green);
      box-shadow: 0 0 6px var(--green-glow);
      animation: hud-dot-pulse 1.5s ease-in-out infinite;
      flex-shrink: 0;
    }

    @keyframes hud-dot-pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: .3;
        transform: scale(.6);
      }
    }

    .hud-clock-wrap {
      position: relative;
      width: 130px;
      height: 130px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .hud-ring-outer {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 1.5px solid var(--cyan);
      box-shadow: 0 0 12px var(--cyan-glow), 0 0 30px rgba(0, 229, 255, .15), inset 0 0 12px rgba(0, 229, 255, .07);
      animation: hud-pulse-ring 3s ease-in-out infinite;
    }

    @keyframes hud-pulse-ring {

      0%,
      100% {
        box-shadow: 0 0 12px var(--cyan-glow), 0 0 30px rgba(0, 229, 255, .15), inset 0 0 12px rgba(0, 229, 255, .07);
      }

      50% {
        box-shadow: 0 0 20px var(--cyan-glow), 0 0 50px rgba(0, 229, 255, .28), inset 0 0 18px rgba(0, 229, 255, .13);
      }
    }

    .hud-progress-svg {
      position: absolute;
      inset: -7px;
      width: calc(100% + 14px);
      height: calc(100% + 14px);
      transform: rotate(-90deg);
      pointer-events: none;
    }

    .hud-progress-track {
      fill: none;
      stroke: rgba(0, 229, 255, 0.1);
      stroke-width: 4;
    }

    .hud-progress-bar {
      fill: none;
      stroke: var(--cyan);
      stroke-width: 4;
      stroke-linecap: round;
      filter: drop-shadow(0 0 5px var(--cyan));
      transition: stroke-dashoffset 1s linear;
    }

    .hud-ring-inner {
      position: absolute;
      inset: 9px;
      border-radius: 50%;
      border: 1px dashed rgba(0, 229, 255, 0.22);
    }

    .hud-ticks {
      position: absolute;
      inset: 0;
    }

    .hud-accent {
      position: absolute;
      width: 11px;
      height: 11px;
      border-color: var(--cyan);
      border-style: solid;
      opacity: 0.5;
    }

    .hud-accent.tl {
      top: 9px;
      left: 9px;
      border-width: 1.5px 0 0 1.5px;
    }

    .hud-accent.tr {
      top: 9px;
      right: 9px;
      border-width: 1.5px 1.5px 0 0;
    }

    .hud-accent.bl {
      bottom: 9px;
      left: 9px;
      border-width: 0 0 1.5px 1.5px;
    }

    .hud-accent.br {
      bottom: 9px;
      right: 9px;
      border-width: 0 1.5px 1.5px 0;
    }

    .hud-face {
      position: relative;
      width: 88px;
      height: 88px;
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0, 229, 255, 0.05) 0%, rgba(0, 0, 0, 0.97) 70%);
      border: 1px solid rgba(0, 229, 255, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hud-seg-display {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .hud-seg-display.alarm {
      animation: hud-seg-alarm .75s step-start infinite;
    }

    @keyframes hud-seg-alarm {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: .08;
      }
    }

    .hud-colon-wrap {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 5px;
      padding-bottom: 2px;
    }

    .hud-colon-dot {
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: var(--seg-on);
      animation: hud-colon-blink 1s step-start infinite;
    }

    @keyframes hud-colon-blink {

      0%,
      49% {
        opacity: 1;
      }

      50%,
      100% {
        opacity: .12;
      }
    }

    .hud-colon-dot.paused {
      animation: none;
      opacity: .12;
    }

    .hud-controls-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 14px;
      width: 100%;
    }

    .hud-input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
    }

    .hud-time-input {
      background: rgba(0, 10, 25, 0.9);
      border: 1px solid rgba(0, 150, 255, 0.45);
      border-radius: 6px;
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      width: 62px;
      height: 32px;
      text-align: center;
      outline: none;
      text-shadow: 0 0 6px var(--cyan-glow);
      transition: all .2s;
    }

    .hud-time-input:focus {
      border-color: var(--cyan);
      box-shadow: 0 0 8px rgba(0, 229, 255, .3);
    }

    .hud-time-input::placeholder {
      color: rgba(0, 229, 255, .25);
    }

    .hud-input-label {
      font-size: 8px;
      letter-spacing: 2px;
      color: rgba(0, 229, 255, .42);
      font-family: 'Orbitron', monospace;
    }

    .hud-sep {
      color: var(--cyan);
      font-size: 18px;
      opacity: .5;
      font-family: 'Orbitron', monospace;
      padding-bottom: 10px;
    }

    .hud-btn {
      height: 32px;
      min-width: 54px;
      padding: 0 10px;
      background: transparent;
      border: 1px solid var(--cyan);
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      cursor: pointer;
      clip-path: polygon(5px 0%, 100% 0%, calc(100% - 5px) 100%, 0% 100%);
      transition: all .2s;
      text-shadow: 0 0 6px var(--cyan-glow);
      box-shadow: 0 0 8px rgba(0, 229, 255, .1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      white-space: nowrap;
    }

    .hud-btn:hover {
      background: rgba(0, 229, 255, .1);
      box-shadow: 0 0 16px var(--cyan-glow);
      color: #fff;
    }

    .hud-btn:active {
      transform: scale(.97);
    }

    .hud-btn.primary {
      border-color: var(--green);
      color: var(--green);
      text-shadow: 0 0 6px var(--green-glow);
      box-shadow: 0 0 8px rgba(0, 255, 136, .1);
    }

    .hud-btn.primary:hover {
      background: rgba(0, 255, 136, .1);
      box-shadow: 0 0 16px var(--green-glow);
    }

    /* ================================================================
         RIGHT COLUMN — Title content
      ================================================================ */
    .hq-title-col {
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 28px 32px 28px 36px;
      gap: 0;
    }

    .hq-status-bar {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 14px;
      opacity: 0;
      animation: hq-slidein-down 0.5s 0.3s ease forwards;
      flex-wrap: wrap;
    }

    .hq-status-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 10px;
      color: rgba(160, 200, 224, 0.65);
      letter-spacing: 1.5px;
      text-transform: uppercase;
    }

    .hq-status-dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      animation: hq-dot-blink 1.8s ease infinite;
    }

    .hq-status-dot.green {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }

    .hq-status-dot.cyan {
      background: #00ffcc;
      box-shadow: 0 0 6px #00ffcc;
      animation-delay: 0.4s;
    }

    .hq-status-dot.orange {
      background: #ff9900;
      box-shadow: 0 0 6px #ff9900;
      animation-delay: 0.8s;
    }

    @keyframes hq-dot-blink {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.2
      }
    }

    .hq-divider {
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.3) 50%, transparent);
      margin-bottom: 18px;
      opacity: 0;
      animation: hq-fadein 0.4s 0.5s ease forwards;
    }

    .hq-main-title-scanline {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent 0%, rgba(0, 255, 204, 0.7) 30%, rgba(0, 255, 204, 0.7) 70%, transparent 100%);
      mix-blend-mode: screen;
      pointer-events: none;
      animation: hq-scan-title 4s 1.5s linear infinite;
      opacity: 0;
    }

    @keyframes hq-scan-title {
      0% {
        top: -5px;
        opacity: 0;
      }

      5% {
        opacity: 0.6;
      }

      95% {
        opacity: 0.6;
      }

      100% {
        top: calc(100% + 5px);
        opacity: 0;
      }
    }

    .hq-main-title {
      font-family: 'Orbitron', sans-serif;
      font-weight: 900;
      font-size: clamp(22px, 3.5vw, 46px);
      text-align: left;
      line-height: 1.15;
      letter-spacing: clamp(1px, 0.35vw, 5px);
      text-transform: uppercase;
      position: relative;
      display: inline-block;
      background: linear-gradient(135deg, #e0f7ff 0%, #00e5ff 25%, #00ffcc 45%, #e0f7ff 62%, #00a8ff 80%, #00ffcc 100%);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 18px rgba(0, 255, 204, 0.55)) drop-shadow(0 0 40px rgba(0, 168, 255, 0.30));
      animation: hq-title-appear 0.7s 0.55s cubic-bezier(0.16, 1, 0.3, 1) both, hq-gradient-flow 5s 1.3s ease infinite, hq-glow-breathe 3s 1.3s ease infinite alternate;
    }

    @keyframes hq-gradient-flow {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes hq-glow-breathe {
      from {
        filter: drop-shadow(0 0 12px rgba(0, 255, 204, 0.40)) drop-shadow(0 0 30px rgba(0, 168, 255, 0.20));
      }

      to {
        filter: drop-shadow(0 0 28px rgba(0, 255, 204, 0.75)) drop-shadow(0 0 55px rgba(0, 168, 255, 0.45));
      }
    }

    @keyframes hq-title-appear {
      from {
        opacity: 0;
        transform: translateY(22px) skewX(-3deg);
        letter-spacing: 12px;
      }

      to {
        opacity: 1;
        transform: translateY(0) skewX(0deg);
      }
    }

    .hq-main-title::before,
    .hq-main-title::after {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      opacity: 0;
    }

    .hq-main-title::before {
      background: linear-gradient(135deg, #ff3366, #ff6600);
      animation: hq-glitch-a 7s 2s infinite linear;
    }

    .hq-main-title::after {
      background: linear-gradient(135deg, #00ffcc, #00a8ff);
      animation: hq-glitch-b 7s 2.3s infinite linear;
    }

    @keyframes hq-glitch-a {

      0%,
      89%,
      100% {
        opacity: 0;
        clip-path: none;
        transform: none;
      }

      90% {
        opacity: .7;
        clip-path: polygon(0 18%, 100% 18%, 100% 32%, 0 32%);
        transform: translate(4px, 0);
      }

      92% {
        opacity: .5;
        clip-path: polygon(0 55%, 100% 55%, 100% 67%, 0 67%);
        transform: translate(-3px, 0);
      }

      94% {
        opacity: .6;
        clip-path: polygon(0 40%, 100% 40%, 100% 50%, 0 50%);
        transform: translate(2px, 0);
      }

      96% {
        opacity: 0;
      }
    }

    @keyframes hq-glitch-b {

      0%,
      86%,
      100% {
        opacity: 0;
        clip-path: none;
        transform: none;
      }

      87% {
        opacity: .6;
        clip-path: polygon(0 60%, 100% 60%, 100% 72%, 0 72%);
        transform: translate(-4px, 0);
      }

      90% {
        opacity: .4;
        clip-path: polygon(0 8%, 100% 8%, 100% 20%, 0 20%);
        transform: translate(3px, 0);
      }

      93% {
        opacity: 0;
      }
    }

    .hq-chips-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 20px;
      flex-wrap: wrap;
      opacity: 0;
      animation: hq-slidein-up 0.5s 1.1s ease forwards;
    }

    .hq-chip {
      display: flex;
      align-items: center;
      gap: 7px;
      padding: 6px 16px;
      border-radius: 3px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      transition: all 0.3s;
      cursor: default;
      background: rgba(0, 10, 25, 0.7);
      border: 1px solid rgba(0, 150, 255, 0.25);
      color: rgba(160, 200, 224, 0.85);
      clip-path: polygon(6px 0%, 100% 0%, calc(100% - 6px) 100%, 0% 100%);
    }

    .hq-chip::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.06), transparent);
      transform: translateX(-100%);
      transition: transform 0.5s;
    }

    .hq-chip:hover {
      border-color: rgba(0, 255, 204, 0.5);
      color: #00ffcc;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 255, 204, 0.15);
    }

    .hq-chip:hover::before {
      transform: translateX(100%);
    }

    .hq-chip.accent-cyan {
      border-color: rgba(0, 255, 204, 0.35);
    }

    .hq-chip-icon {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .hq-chip-icon.cyan {
      background: #00ffcc;
      box-shadow: 0 0 8px #00ffcc;
    }

    .hq-chip-sep {
      width: 1px;
      height: 18px;
      background: linear-gradient(180deg, transparent, rgba(0, 255, 204, 0.3), transparent);
    }

    .hq-bottom-bar {
      width: 100%;
      height: 3px;
      margin-top: 20px;
      background: rgba(0, 100, 200, 0.1);
      border-radius: 2px;
      overflow: hidden;
      opacity: 0;
      animation: hq-fadein 0.4s 1.3s ease forwards;
    }

    @keyframes hq-fadein {
      from {
        opacity: 0
      }

      to {
        opacity: 1
      }
    }

    @keyframes hq-slidein-down {
      from {
        opacity: 0;
        transform: translateY(-12px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    @keyframes hq-slidein-up {
      from {
        opacity: 0;
        transform: translateY(12px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    /* ================================================================
         GHOST CLOCK — fixed bottom-right
      ================================================================ */
    .ghost-clock {
      position: fixed;
      top: 5px;
      right: 5px;
      z-index: 10001;
      opacity: 0;
      pointer-events: none;
      transform: translateY(18px) scale(0.85);
      transition: opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1), transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      padding-bottom: 28px;
    }

    .ghost-clock.should-show {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }

    /* Khi kéo vào vùng ẩn: hiệu ứng nhẹ để báo hiệu */
    .ghost-clock.hide-cue {
      box-shadow: 0 0 10px #ff4444;
      transform: translateY(0) scale(1.02);
      transition: box-shadow 0.15s ease, transform 0.15s ease;
    }

    .ghost-clock.peek {
      opacity: 0.85;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }

    .ghost-clock.alert-pop {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }

    .ghost-shell {
      position: relative;
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(4, 12, 28, 0.85);
      border-radius: 50%;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(0, 229, 255, 0.2);
      cursor: pointer;
      transition: box-shadow 0.2s, transform 0.15s;
    }

    .ghost-shell:hover {
      box-shadow: 0 8px 36px rgba(0, 0, 0, 0.7), 0 0 0 1.5px rgba(0, 229, 255, 0.55), 0 0 20px rgba(0, 229, 255, 0.2);
      transform: scale(1.04);
    }

    .ghost-shell:active {
      transform: scale(0.97);
    }

    .ghost-shell .g-ring-outer {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 1.5px solid var(--cyan);
      box-shadow: 0 0 12px var(--cyan-glow), 0 0 30px rgba(0, 229, 255, .15), inset 0 0 12px rgba(0, 229, 255, .07);
      animation: hud-pulse-ring 3s ease-in-out infinite;
      pointer-events: none;
    }

    .ghost-shell .g-progress-svg {
      position: absolute;
      inset: -7px;
      width: calc(100% + 14px);
      height: calc(100% + 14px);
      transform: rotate(-90deg);
      pointer-events: none;
    }

    .ghost-shell .g-ring-inner {
      position: absolute;
      inset: 9px;
      border-radius: 50%;
      border: 1px dashed rgba(0, 229, 255, 0.22);
      pointer-events: none;
    }

    .ghost-shell .g-accent {
      position: absolute;
      width: 10px;
      height: 10px;
      border-color: var(--cyan);
      border-style: solid;
      opacity: 0.45;
      pointer-events: none;
    }

    .ghost-shell .g-accent.tl {
      top: 8px;
      left: 8px;
      border-width: 1.5px 0 0 1.5px;
    }

    .ghost-shell .g-accent.tr {
      top: 8px;
      right: 8px;
      border-width: 1.5px 1.5px 0 0;
    }

    .ghost-shell .g-accent.bl {
      bottom: 8px;
      left: 8px;
      border-width: 0 0 1.5px 1.5px;
    }

    .ghost-shell .g-accent.br {
      bottom: 8px;
      right: 8px;
      border-width: 0 1.5px 1.5px 0;
    }

    .ghost-shell .g-ticks {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .ghost-shell .g-face {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0, 229, 255, 0.05) 0%, rgba(0, 0, 0, 0.97) 70%);
      border: 1px solid rgba(0, 229, 255, 0.13);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .ghost-label {
      position: absolute;
      bottom: 4px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Share Tech Mono', monospace;
      font-size: 9px;
      letter-spacing: 2px;
      color: var(--cyan);
      text-shadow: 0 0 6px var(--cyan-glow);
      white-space: nowrap;
      opacity: 0.7;
      pointer-events: none;
    }

    .ghost-hint {
      position: absolute;
      top: -26px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Share Tech Mono', monospace;
      font-size: 8px;
      letter-spacing: 1.5px;
      color: rgba(0, 229, 255, 0.5);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }

    .ghost-clock.should-show:hover .ghost-hint {
      opacity: 1;
    }

    @keyframes ghost-alert-ring {
      0% {
        box-shadow: 0 0 0 0 rgba(0, 229, 255, 0.7);
      }

      70% {
        box-shadow: 0 0 0 12px rgba(0, 229, 255, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(0, 229, 255, 0);
      }
    }

    .ghost-clock.alert-pop .ghost-shell {
      animation: ghost-alert-ring 0.6s ease-out 2;
    }

    /* ================================================================
         LAYOUT ADJUST — push main content below new title block
      ================================================================ */
    .main-content-wrapper {
      margin-top: 20px !important;
    }

    /* ================================================================
         RESPONSIVE HUD
      ================================================================ */
    @media (max-width:768px) {
      .hq-title-card {
        grid-template-columns: 1fr;
      }

      .hq-col-sep {
        display: none;
      }

      .hq-title-col {
        padding: 20px 16px;
      }

      .hq-timer-col {
        padding: 20px 16px;
        border-bottom: 1px solid rgba(0, 255, 204, 0.15);
      }

      .hq-main-title {
        text-align: center;
      }

      .hq-chips-row {
        justify-content: center;
      }
    }

    @media (max-width:480px) {
      .hud-controls-wrap {
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
      }
    }

    /* ===== PERFORMANCE CONTROL ===== */
    .pause-animations *,
    .pause-animations *::before,
    .pause-animations *::after {
      animation: none !important;
      transition: none !important;
    }

    /* Trạng thái đang kéo - hiệu ứng hover mạnh hơn */
    .ghost-clock.dragging {
      opacity: 0.95;
      transition: none;
      /* Bỏ transition khi kéo để không bị giật */
      cursor: grabbing !important;
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
    }

    .ghost-clock.dragging .ghost-shell {
      transform: scale(1.05);
      transition: transform 0.2s ease;
    }

    /* Hiệu ứng khi đang snap */
    .ghost-clock.snapping {
      transition: left 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), top 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) !important;
    }

    /* Vòng tròn hiển thị phạm vi bắt (tùy chọn - để debug) */
    .dock-visualization {
      position: fixed;
      border: 2px dashed rgba(0, 255, 204, 0.3);
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      animation: dock-pulse 2s infinite;
    }

    @keyframes dock-pulse {

      0%,
      100% {
        opacity: 0.3;
        transform: scale(1);
      }

      50% {
        opacity: 0.6;
        transform: scale(1.05);
      }
    }

    /* ===== DOCK L-SHAPED CORNERS - 4 DẤU VUÔNG CHỮ L ===== */
    .dock-circle {
      position: fixed;
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 9990;
      opacity: 0;
      transition: opacity 0.3s ease;
      display: none;
    }

    /* Hiện vòng khi active */
    .dock-circle.active {
      opacity: 1;
      display: block;
      animation: dock-scale-pulse 1.5s ease-in-out infinite;
    }

    /* ===== 4 DẤU VUÔNG L TẠI 4 GÓC ===== */
    /* Góc trên-bên trái */
    .dock-corner {
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid #ff3333;
      pointer-events: none;
    }

    .dock-circle.top-right .dock-corner.corner-tl {
      top: 0;
      left: 0;
      border-right: none;
      border-bottom: none;
    }

    /* Góc trên-bên phải */
    .dock-circle.top-right .dock-corner.corner-tr {
      top: 0;
      right: 0;
      border-left: none;
      border-bottom: none;
    }

    /* Góc dưới-bên phải */
    .dock-circle.top-right .dock-corner.corner-br {
      bottom: 0;
      right: 0;
      border-left: none;
      border-top: none;
    }

    /* Góc dưới-bên trái */
    .dock-circle.top-right .dock-corner.corner-bl {
      bottom: 0;
      left: 0;
      border-right: none;
      border-top: none;
    }

    /* Tương tự cho dock bên trái */
    .dock-circle.top-left .dock-corner.corner-tl {
      top: 0;
      left: 0;
      border-right: none;
      border-bottom: none;
    }

    .dock-circle.top-left .dock-corner.corner-tr {
      top: 0;
      right: 0;
      border-left: none;
      border-bottom: none;
    }

    .dock-circle.top-left .dock-corner.corner-br {
      bottom: 0;
      right: 0;
      border-left: none;
      border-top: none;
    }

    .dock-circle.top-left .dock-corner.corner-bl {
      bottom: 0;
      left: 0;
      border-right: none;
      border-top: none;
    }

    /* Hiệu ứng nhấp nháy scale */
    @keyframes dock-scale-pulse {

      0%,
      100% {
        transform: scale(1);
        filter: drop-shadow(0 0 4px #ff3333);
      }

      50% {
        transform: scale(1.15);
        filter: drop-shadow(0 0 8px #ff3333);
      }
    }
  </style>

</head>

<body>
  <!-- CYBER LOADING: phần tử đầu tiên trong body, hiển thị ngay trước mọi nội dung khác -->
  <div id="cyberLoading">
    <div class="cyber-loading-box">
      <div class="cyber-loading-title">
        <span id="cyberLoadingText">ĐANG TẢI BÀI TEST</span>
        <span id="cyberLoadingPercent" style="margin-left: 10px">0%</span>
      </div>
      <div class="cyber-loading-bar">
        <div class="cyber-loading-bar-fill"></div>
      </div>
      <div class="cyber-loading-sub">SYSTEM PROCESSING...</div>
    </div>
  </div>
  <!-- INLINE SCRIPT ĐẦU TIÊN - CHẠY NGAY LẬP TỨC -->
  <!-- Background Effects -->
  <div class="cyber-grid"></div>
  <div class="cyber-line"></div>

  <!-- ================================================================
         HQ TITLE BLOCK (replaces old h1 + timer-container)
    ================================================================ -->
  <div class="hq-title-block">

    <!-- Ticker -->
    <div id="cyber-header-wrapper"></div>
    <div class="hq-ticker" aria-hidden="true">
      <div class="hq-ticker-inner">
        <span class="hq-ticker-item">◈ SYS_ACTIVE</span>
        <span class="hq-ticker-item"><b>QUIZ_MODULE</b> :: TEST</span>
        <span class="hq-ticker-item">◈ READY</span>
        <span class="hq-ticker-item"><b>40 QUESTIONS</b> :: ARMED</span>
        <span class="hq-ticker-item">◈ NEURAL_LINK :: ONLINE</span>
        <span class="hq-ticker-item"><b>CYBERPUNK ENGINE</b> :: ACTIVE</span>
        <span class="hq-ticker-item">◈ SYS_ACTIVE</span>
        <span class="hq-ticker-item"><b>QUIZ_MODULE</b> :: TEST</span>
        <span class="hq-ticker-item">◈ READY</span>
        <span class="hq-ticker-item"><b>40 QUESTIONS</b> :: ARMED</span>
      </div>
    </div>
  </div>

  <!-- 2-column card -->
  <div class="hq-title-card">

    <!-- Corner decorations -->
    <svg class="hq-corner tl" viewBox="0 0 28 28" fill="none">
      <line x1="0" y1="1" x2="28" y2="1" />
      <line x1="1" y1="0" x2="1" y2="28" />
    </svg>
    <svg class="hq-corner tr" viewBox="0 0 28 28" fill="none">
      <line x1="0" y1="1" x2="28" y2="1" />
      <line x1="1" y1="0" x2="1" y2="28" />
    </svg>

    <!-- Vertical separator -->
    <div class="hq-col-sep"></div>

    <!-- ═══ LEFT: HUD TIMER ═══ -->
    <div class="hq-timer-col">
      <div class="hud-status">
        <div class="hud-status-dot" id="hudStatusDot"></div>
        <span id="hudStatusText">STANDBY</span>
      </div>

      <div class="hud-clock-wrap" id="hudClockWrap">
        <div class="hud-ring-outer"></div>
        <svg class="hud-progress-svg" viewBox="0 0 144 144">
          <circle class="hud-progress-track" cx="72" cy="72" r="66" />
          <circle class="hud-progress-bar" id="hudProgressBar" cx="72" cy="72" r="66" stroke-dasharray="414.7"
            stroke-dashoffset="0" />
        </svg>
        <div class="hud-ticks" id="hudTicks"></div>
        <div class="hud-ring-inner"></div>
        <div class="hud-accent tl"></div>
        <div class="hud-accent tr"></div>
        <div class="hud-accent bl"></div>
        <div class="hud-accent br"></div>
        <div class="hud-face">
          <div class="hud-seg-display" id="hudSegDisplay">
            <svg id="hd4" width="17" height="30" viewBox="0 0 17 30" style="display:none"></svg>
            <svg id="hd0" width="17" height="30" viewBox="0 0 17 30"></svg>
            <svg id="hd1" width="17" height="30" viewBox="0 0 17 30"></svg>
            <div class="hud-colon-wrap">
              <div class="hud-colon-dot" id="hcd1"></div>
              <div class="hud-colon-dot" id="hcd2"></div>
            </div>
            <svg id="hd2" width="17" height="30" viewBox="0 0 17 30"></svg>
            <svg id="hd3" width="17" height="30" viewBox="0 0 17 30"></svg>
          </div>
        </div>
      </div>

      <div class="hud-controls-wrap">
        <button class="hud-btn" id="hudResetBtn">↺ RESET</button>
        <div style="display:flex;align-items:center;gap:4px;">
          <div class="hud-input-group">
            <input class="hud-time-input" id="hudInputMin" type="number" min="0" max="999" placeholder="20" value="20">
            <div class="hud-input-label">MIN</div>
          </div>
          <div class="hud-sep">:</div>
          <div class="hud-input-group">
            <input class="hud-time-input" id="hudInputSec" type="number" min="0" max="59" placeholder="00" value="0">
            <div class="hud-input-label">SEC</div>
          </div>
        </div>
        <button class="hud-btn primary" id="hudStartBtn">▶ START</button>
      </div>
    </div><!-- end .hq-timer-col -->

    <!-- ═══ RIGHT: TITLE ═══ -->
    <div class="hq-title-col">
      <div class="hq-status-bar">
        <div class="hq-status-item"><span class="hq-status-dot green"></span>SYS ONLINE</div>
        <div class="hq-status-item"><span class="hq-status-dot cyan"></span>MODULE : QUIZ</div>
        <div class="hq-status-item"><span class="hq-status-dot orange"></span>STATUS : READY</div>
      </div>
      <div class="hq-divider"></div>
      <div style="position:relative;">
        <div class="hq-main-title-scanline"></div>
        <!-- SỬA: placeholder TEST TỪ VỰNG NGÀY 15 được giữ nguyên -->
        <h1 class="hq-main-title" data-text="TEST TỪ VỰNG NGÀY 15">TEST TỪ VỰNG NGÀY 15</h1>
      </div>
      <div class="hq-chips-row">
        <!-- SỬA: placeholder 40 được giữ nguyên -->
        <div class="hq-chip accent-cyan"><span class="hq-chip-icon cyan"></span>40 Câu hỏi</div>
        <div class="hq-chip-sep"></div>
        <div class="hq-chip accent-cyan"><span class="hq-chip-icon cyan"></span>CYBERPUNK QUIZ</div>
      </div>
      <div class="hq-bottom-bar"></div>
    </div><!-- end .hq-title-col -->

  </div><!-- end .hq-title-card -->
  </div><!-- end .hq-title-block -->

  <!-- GHOST CLOCK (fixed bottom-right, mirrors HUD timer) -->
  <div class="ghost-clock" id="ghostClock" title="Click vào để ẩn">
    <div class="ghost-shell">
      <div class="g-ring-outer"></div>
      <svg class="g-progress-svg" viewBox="0 0 134 134">
        <circle fill="none" stroke="rgba(0,229,255,0.1)" stroke-width="3.5" cx="67" cy="67" r="60" />
        <circle id="ghostProgressBar" fill="none" stroke="var(--cyan)" stroke-width="3.5" stroke-linecap="round" cx="67"
          cy="67" r="60" style="filter:drop-shadow(0 0 4px var(--cyan));transition:stroke-dashoffset 1s linear;" />
      </svg>
      <div class="g-ticks" id="ghostTicks"></div>
      <div class="g-ring-inner"></div>
      <div class="g-accent tl"></div>
      <div class="g-accent tr"></div>
      <div class="g-accent bl"></div>
      <div class="g-accent br"></div>
      <div class="g-face">
        <div class="hud-seg-display" id="ghostSegDisplay">
          <svg id="gd4" width="15" height="27" viewBox="0 0 15 27" style="display:none"></svg>
          <svg id="gd0" width="15" height="27" viewBox="0 0 15 27"></svg>
          <svg id="gd1" width="15" height="27" viewBox="0 0 15 27"></svg>
          <div class="hud-colon-wrap">
            <div class="hud-colon-dot" id="gcd1"></div>
            <div class="hud-colon-dot" id="gcd2"></div>
          </div>
          <svg id="gd2" width="15" height="27" viewBox="0 0 15 27"></svg>
          <svg id="gd3" width="15" height="27" viewBox="0 0 15 27"></svg>
        </div>
      </div>
    </div>
    <div class="ghost-label" id="ghostLabel">STANDBY</div>
    <div class="ghost-hint" id="ghostHint">[ NHẤN ĐỂ ẨN ]</div>
  </div>

  <!-- Dark Mode Toggle removed -->
  <!-- Back To Top -->
  <button id="backToTopBtn" onclick="scrollToTop()" title="Lên đầu trang">
    <i class="fas fa-arrow-up"></i>
  </button>

  <!-- FLOATING BUTTONS -->
  <div id="leftFloatingBtn" class="floating-btn-container left">
    <div class="floating-btn left" onclick="toggleSidebar('left')">
      <i class="fas fa-times-circle"></i>
      <span class="badge" id="wrongAnswersBadge">0</span>
      <span class="btn-tooltip">Câu đã sai</span>
    </div>
  </div>
  <div id="rightFloatingBtn" class="floating-btn-container right">
    <div class="floating-btn right" onclick="toggleSidebar('right')">
      <i class="fas fa-cog"></i>
      <span class="btn-tooltip">Điều khiển</span>
    </div>
  </div>

  <!-- LEFT SIDEBAR - Wrong Answers -->
  <div id="leftSidebarPanel" class="sidebar-panel left">
    <button class="sidebar-toggle" onclick="toggleSidebar('left')">
      <i class="fas fa-chevron-left"></i>
    </button>
    <div class="sidebar-header">
      <h3>
        <i class="fas fa-times-circle" style="color: #ff3366"></i><span>CÂU ĐÃ SAI</span>
      </h3>
      <button class="sidebar-close" onclick="forceCloseSidebar('left')">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="sidebar-content">
      <div style="margin-bottom: 20px; display: flex; gap: 10px">
        <button class="cyber-button" onclick="showWrongAnswers()" style="flex: 2">
          <i class="fas fa-eye"></i> Xem
        </button>
        <button class="cyber-button" onclick="practiceWrongAnswers()" style="flex: 2">
          <i class="fas fa-graduation-cap"></i> Luyện
        </button>
        <button class="cyber-button" onclick="clearWrongAnswers()" style="
              flex: 1;
              background: linear-gradient(135deg, #ff3333, #ff6600);
            ">
          <i class="fas fa-trash"></i>
        </button>
      </div>
      <div id="wrongAnswersList" class="wrong-answers-list"></div>
    </div>
  </div>

  <!-- RIGHT SIDEBAR - Controls -->
  <div id="rightSidebarPanel" class="sidebar-panel right">
    <button class="sidebar-toggle" onclick="toggleSidebar('right')">
      <i class="fas fa-chevron-right"></i>
    </button>
    <div class="sidebar-header">
      <h3>
        <i class="fas fa-tasks" style="color: var(--secondary-glow)"></i><span>ĐIỀU KHIỂN</span>
      </h3>
      <button class="sidebar-close" onclick="forceCloseSidebar('right')">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="sidebar-content">
      <button class="cyber-button" onclick="submitQuiz()">
        <i class="fas fa-paper-plane"></i> Nộp bài
      </button>
      <button class="cyber-button" onclick="resetQuiz()">
        <i class="fas fa-redo-alt"></i> Làm lại
      </button>
      <button id="showAnswersBtn" class="cyber-button" onclick="showCorrectAnswers()" style="
            display: none;
            background: linear-gradient(135deg, #00cc66, #00ff88);
          ">
        <i class="fas fa-check-circle"></i> Hiện đáp án
      </button>

      <h4 style="
            color: var(--secondary-glow);
            margin: 20px 0 10px;
            font-family: Orbitron;
          ">
        <i class="fas fa-history"></i> LỊCH SỬ
      </h4>
      <ul id="quizHistory"></ul>

      <h4 style="
            color: var(--secondary-glow);
            margin: 20px 0 10px;
            font-family: Orbitron;
          ">
        <i class="fas fa-edit"></i> CẬP NHẬT ĐÁP ÁN
      </h4>
      <input type="text" id="editKey" placeholder="Ví dụ: q1 hoặc 4.1" style="
            width: 100%;
            margin-bottom: 10px;
            background: rgba(0, 10, 25, 0.9);
            color: white;
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            padding: 10px;
          " />
      <input type="text" id="editValue" placeholder="Số đáp án (1-4)" style="
            width: 100%;
            margin-bottom: 10px;
            background: rgba(0, 10, 25, 0.9);
            color: white;
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            padding: 10px;
          " />
      <button class="cyber-button" onclick="updateAnswer()" style="margin-bottom: 5px">
        <i class="fas fa-save"></i> Cập nhật
      </button>
      <button class="cyber-button" id="clearAnswersBtn" style="background: linear-gradient(135deg, #ff3333, #ff6600)">
        <i class="fas fa-eraser"></i> Xóa cập nhật
      </button>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div id="mainContentWrapper" class="main-content-wrapper">
    <div class="main-quiz-container">
<!-- Không có audio chính -->
      <!-- H2 - SỬA: thêm placeholder cho tên bài test -->
      <h2 style="
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(0, 255, 204, 0.3);
            padding-bottom: 15px;
          ">
        <i class="fas fa-file-alt" style="color: var(--secondary-glow)"></i>
        TEST TỪ VỰNG NGÀY 15
      </h2>
      <form id="quizForm"></form>
    </div>
  </div>

  <!-- Popups -->
  <div id="timeUpAlert" class="time-up-alert" style="display: none">
    <i class="fas fa-hourglass-end" style="font-size: 40px; margin-bottom: 20px"></i>
    <h2>⏰ HẾT THỜI GIAN!</h2>
    <p style="margin-top: 10px">Bạn đã hết thời gian làm bài rồi!</p>
  </div>
  <!-- Overlay làm tối màn hình -->
  <div id="resultOverlay" class="result-overlay"></div>
  <!-- Fullscreen fireworks canvas — outside panel so it doesn't block content -->
  <canvas id="hudFwCanvas"
    style="position:fixed;inset:0;width:100%;height:100%;pointer-events:none;z-index:200001;display:none;"></canvas>

  <!-- ===== HUD RESULT PANEL ===== -->
  <div id="resultPopup" class="hud-result-panel" style="display:none">
    <!-- L-corners -->
    <div class="hud-corner hud-corner-tl"><span class="h"></span><span class="v"></span></div>
    <div class="hud-corner hud-corner-tr"><span class="h"></span><span class="v"></span></div>
    <div class="hud-corner hud-corner-bl"><span class="h"></span><span class="v"></span></div>
    <div class="hud-corner hud-corner-br"><span class="h"></span><span class="v"></span></div>
    <!-- scan bar -->
    <div class="hud-scan-bar"></div>

    <!-- Header row: title + close button -->
    <div class="hud-result-header">
      <div class="hud-result-title">KẾT QUẢ KIỂM TRA</div>
      <button class="hud-btn-close" onclick="closeResultPopup()">✕ ĐÓNG</button>
    </div>

    <!-- HUD status dot -->
    <div class="hud-res-status">
      <div class="hud-res-dot"></div>
      SCORE LOCKED
    </div>

    <!-- Clock ring -->
    <div class="hud-res-score-wrap">
      <div class="hud-res-clock">
        <div class="hud-res-ring-outer"></div>
        <!-- progress arc -->
        <svg class="hud-res-progress-svg" id="hudResProgressSvg" viewBox="0 0 222 222">
          <circle class="hud-res-track" cx="111" cy="111" r="103" />
          <circle class="hud-res-bar" id="hudResBar" cx="111" cy="111" r="103" />
        </svg>
        <div class="hud-res-ring-inner"></div>
        <!-- ticks -->
        <svg class="hud-res-ticks-svg" id="hudResTicksSvg" viewBox="0 0 190 190"></svg>
        <!-- corner accents -->
        <div class="hud-res-accent tl"></div>
        <div class="hud-res-accent tr"></div>
        <div class="hud-res-accent bl"></div>
        <div class="hud-res-accent br"></div>
        <!-- face with 7-seg -->
        <div class="hud-res-face">
          <div class="hud-res-seg-display" id="hudResSegDisplay">
            <div class="hud-res-seg-digit"><svg id="hudResDig0" viewBox="0 0 22 38" class="hud-res-seg-svg"></svg></div>
            <div class="hud-res-seg-digit"><svg id="hudResDig1" viewBox="0 0 22 38" class="hud-res-seg-svg"></svg></div>
            <div class="hud-res-seg-digit"><svg id="hudResDig2" viewBox="0 0 22 38" class="hud-res-seg-svg"></svg></div>
            <div class="hud-res-seg-pct">%</div>
          </div>
        </div>
      </div>
    </div>

    <!-- PERFECT label (hidden by default, shown only for 100%) -->
    <div class="hud-res-perfect" id="hudResPerfect" style="display:none">PERFECT!</div>

    <!-- Stats row -->
    <div class="hud-res-stats">
      <div class="hud-res-stat">
        <div class="hud-res-stat-label">ĐÚNG</div>
        <div class="hud-res-stat-value correct" id="hudResCorrect">—</div>
      </div>
      <div class="hud-res-divider"></div>
      <div class="hud-res-stat">
        <div class="hud-res-stat-label">SAI</div>
        <div class="hud-res-stat-value wrong" id="hudResWrong">—</div>
      </div>
      <div class="hud-res-divider"></div>
      <div class="hud-res-stat">
        <div class="hud-res-stat-label">THỜI GIAN</div>
        <div class="hud-res-stat-value time" id="hudResTime">—</div>
      </div>
    </div>
  </div>

  <!-- ================================================================
         HUD TIMER + GHOST CLOCK SCRIPT
    ================================================================ -->
  <script>
    (function () {
      // ── Build main ticks ──
      const hudTicksEl = document.getElementById('hudTicks');
      for (let i = 0; i < 60; i++) {
        const el = document.createElement('div');
        const maj = i % 5 === 0;
        Object.assign(el.style, { position: 'absolute', left: '50%', top: '0', width: maj ? '1.5px' : '1px', height: (maj ? 8 : 5) + 'px', marginLeft: maj ? '-.75px' : '-.5px', background: 'var(--cyan)', opacity: maj ? '0.8' : '0.3', transformOrigin: '50% 65px', transform: `rotate(${i * 6}deg)`, boxShadow: maj ? '0 0 3px var(--cyan)' : 'none', borderRadius: '1px' });
        hudTicksEl.appendChild(el);
      }

      // ── 7-Segment engine ──
      const DIGITS = { 0: [1, 1, 1, 1, 1, 1, 0], 1: [0, 1, 1, 0, 0, 0, 0], 2: [1, 1, 0, 1, 1, 0, 1], 3: [1, 1, 1, 1, 0, 0, 1], 4: [0, 1, 1, 0, 0, 1, 1], 5: [1, 0, 1, 1, 0, 1, 1], 6: [1, 0, 1, 1, 1, 1, 1], 7: [1, 1, 1, 0, 0, 0, 0], 8: [1, 1, 1, 1, 1, 1, 1], 9: [1, 1, 1, 1, 0, 1, 1] };
      function makeSegPoints(W, H) {
        const t = 2.4, g = 0.5, r = t * 0.5, x0 = t + g, x1 = W - t - g, mid = H / 2;
        const by0 = t + g, by1 = mid - t / 2 - g, cy0 = mid + t / 2 + g, cy1 = H - t - g, gy = mid - t / 2, gr = r * 0.7;
        return [`${x0 + r},0 ${x1 - r},0 ${x1},${t} ${x0},${t}`, `${W - t},${by0 + r} ${W},${by0} ${W},${by1} ${W - t},${by1 - r}`, `${W - t},${cy0 + r} ${W},${cy0} ${W},${cy1} ${W - t},${cy1 - r}`, `${x0},${H - t} ${x1},${H - t} ${x1 - r},${H} ${x0 + r},${H}`, `${0},${cy0} ${t},${cy0 + r} ${t},${cy1 - r} ${0},${cy1}`, `${0},${by0} ${t},${by0 + r} ${t},${by1 - r} ${0},${by1}`, `${x0 + gr},${gy} ${x1 - gr},${gy} ${x1 - gr},${gy + t} ${x0 + gr},${gy + t}`];
      }
      const SEG_POLY = makeSegPoints(17, 30);
      function renderDigit(svgEl, num, onColor, offColor) {
        const segs = DIGITS[num] !== undefined ? DIGITS[num] : DIGITS[8]; svgEl.innerHTML = '';
        SEG_POLY.forEach((pts, i) => { const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); poly.setAttribute('points', pts); const on = segs[i] === 1; poly.setAttribute('fill', on ? onColor : offColor); if (on) poly.setAttribute('style', `filter:drop-shadow(0 0 1.5px ${onColor})`); svgEl.appendChild(poly); });
      }
      const dEls = [document.getElementById('hd4'), document.getElementById('hd0'), document.getElementById('hd1'), document.getElementById('hd2'), document.getElementById('hd3')];
      function renderTime(secs, colorOn, colorOff) {
        const m = Math.floor(secs / 60), s = secs % 60, d4 = Math.floor(m / 100), d0 = Math.floor((m % 100) / 10), d1 = m % 10, d2 = Math.floor(s / 10), d3 = s % 10;
        dEls[0].style.display = m >= 100 ? 'block' : 'none';
        [d4, d0, d1, d2, d3].forEach((n, i) => renderDigit(dEls[i], n, colorOn, colorOff));
      }

      // ── Timer state ──
      const CIRC = 2 * Math.PI * 66;
      const hudProgressBar = document.getElementById('hudProgressBar');
      hudProgressBar.setAttribute('stroke-dasharray', CIRC);
      const hudStatusText = document.getElementById('hudStatusText');
      const hudStatusDot = document.getElementById('hudStatusDot');
      const hudSegDisplay = document.getElementById('hudSegDisplay');
      const hcd1 = document.getElementById('hcd1');
      const hcd2 = document.getElementById('hcd2');
      const hudInputMin = document.getElementById('hudInputMin');
      const hudInputSec = document.getElementById('hudInputSec');

      let totalSec = 20 * 60, remaining = totalSec, timerID = null, running = false;
      const MILESTONES = new Set([300, 60, 30]);
      let firedMilestones = new Set();

      function setColonPause(p) { [hcd1, hcd2].forEach(d => p ? d.classList.add('paused') : d.classList.remove('paused')); }
      function updateDisplay(alarm) {
        const on = alarm ? '#ff3333' : 'var(--seg-on)', off = alarm ? 'rgba(255,51,51,0.06)' : 'var(--seg-off)';
        renderTime(remaining, on, off);
        const frac = totalSec > 0 ? remaining / totalSec : 0;
        hudProgressBar.style.strokeDashoffset = CIRC * (1 - frac);
        const warn = alarm || (remaining <= 10 && remaining > 0);
        hudProgressBar.style.stroke = warn ? '#ff3333' : 'var(--cyan)';
        hudProgressBar.style.filter = warn ? 'drop-shadow(0 0 5px #ff3333)' : 'drop-shadow(0 0 4px var(--cyan))';
      }
      function setStatus(s) {
        const map = { standby: { t: 'STANDBY', c: 'var(--green)', g: 'var(--green-glow)', a: true }, running: { t: 'RUNNING', c: 'var(--green)', g: 'var(--green-glow)', a: false }, paused: { t: 'PAUSED', c: '#ffaa00', g: 'rgba(255,170,0,.8)', a: true }, done: { t: 'COMPLETE', c: '#ff3333', g: 'rgba(255,51,51,.8)', a: false } };
        const d = map[s] || map.standby;
        hudStatusText.textContent = d.t; hudStatusDot.style.background = d.c; hudStatusDot.style.boxShadow = `0 0 6px ${d.g}`;
        hudStatusDot.style.animation = d.a ? 'hud-dot-pulse 1.5s ease-in-out infinite' : 'none';
      }
      function getInputTime() {
        const rawM = hudInputMin.value, rawS = hudInputSec.value;
        const m = (rawM === '' || isNaN(parseInt(rawM))) ? 20 : Math.max(0, Math.min(999, parseInt(rawM)));
        const s = (rawS === '' || isNaN(parseInt(rawS))) ? 0 : Math.max(0, Math.min(59, parseInt(rawS)));
        totalSec = m * 60 + s; if (totalSec <= 0) totalSec = 20 * 60; remaining = totalSec; firedMilestones.clear();
      }

      // ── Ghost clock setup ──
      const ghostTicksEl = document.getElementById('ghostTicks');
      for (let i = 0; i < 60; i++) { const el = document.createElement('div'); const maj = i % 5 === 0; Object.assign(el.style, { position: 'absolute', left: '50%', top: '0', width: maj ? '1.5px' : '1px', height: (maj ? 7 : 4) + 'px', marginLeft: maj ? '-.75px' : '-.5px', background: 'var(--cyan)', opacity: maj ? '0.75' : '0.28', transformOrigin: '50% 60px', transform: `rotate(${i * 6}deg)`, boxShadow: maj ? '0 0 3px var(--cyan)' : 'none', borderRadius: '1px' }); ghostTicksEl.appendChild(el); }
      const gSEG_POLY = makeSegPoints(15, 27);
      const gdEls = [document.getElementById('gd4'), document.getElementById('gd0'), document.getElementById('gd1'), document.getElementById('gd2'), document.getElementById('gd3')];
      const gcd1 = document.getElementById('gcd1'), gcd2 = document.getElementById('gcd2');
      const ghostProgressBar = document.getElementById('ghostProgressBar');
      const ghostClock = document.getElementById('ghostClock');
      const ghostLabel = document.getElementById('ghostLabel');
      const ghostHint = document.getElementById('ghostHint');
      const ghostShell = ghostClock.querySelector('.ghost-shell');
      const ghostSegDisplay = document.getElementById('ghostSegDisplay');
      const G_CIRC = 2 * Math.PI * 60;
      ghostProgressBar.setAttribute('stroke-dasharray', G_CIRC);

      let realClockVisible = true, ghostDismissed = false, ghostHoverTimeout = null, alertPopTimeout = null;
      // Ngưỡng để kéo vào góc dưới cùng để ẩn đồng hồ (px)
      const DOCK_HIDE_THRESHOLD = 50;
      // ===== BIẾN CHO KÉO THẢ =====
      let isDragging = false;           // Đang kéo hay không
      let dragStartX = 0, dragStartY = 0; // Vị trí bắt đầu kéo (tính theo con trỏ)
      let ghostStartLeft = 0, ghostStartTop = 0; // Vị trí ban đầu của đồng hồ
      let ghostCurrentLeft = null, ghostCurrentTop = null; // Vị trí hiện tại (nếu đã kéo)
      // ===== CẤU HÌNH BẾN ĐỖ (DOCK) =====
      const docks = [
        {
          name: 'top-right',
          // Vị trí góc trên bên phải: cách top 5px, right 5px
          getX: () => window.innerWidth - ghostClock.offsetWidth - 5,
          getY: () => 5,
          threshold: ghostClock ? ghostClock.offsetWidth * 2 : 120 // Đường kính gấp đôi
        },
        {
          name: 'top-left',
          // Vị trí góc trên bên trái: cách top 5px, left 5px
          getX: () => 5,
          getY: () => 5,
          threshold: ghostClock ? ghostClock.offsetWidth * 2 : 120
        }
      ];
      // ===== TẠO VÒNG TRÒN BẾN =====
      let dockCircles = [];
      // Reset tất cả vòng tròn về trạng thái ẩn
      function resetDockCircles() {
        dockCircles.forEach(circle => {
          circle.classList.remove('active');
        });
      }

      // Gọi reset khi cần (ví dụ khi reset đồng hồ)
      // Có thể thêm vào hàm resetTimer hoặc nơi phù hợp

      // ===== TẠO VÒNG TRÒN BẾN =====
      function createDockCircles() {
        // Xóa vòng tròn cũ nếu có
        dockCircles.forEach(circle => {
          if (circle && circle.parentNode) circle.parentNode.removeChild(circle);
        });
        dockCircles = [];

        // Tạo vòng tròn cho mỗi bến
        docks.forEach((dock, index) => {
          const circle = document.createElement('div');
          circle.className = `dock-circle ${dock.name}`;

          // Tính vị trí căn giữa theo tâm bến
          const dockX = dock.getX(); // Vị trí góc trên bên trái của đồng hồ khi ở bến
          const dockY = dock.getY();

          // Tâm bến = dockX + (chiều rộng đồng hồ/2)
          const centerX = dockX + (ghostClock.offsetWidth / 2);
          const centerY = dockY + (ghostClock.offsetHeight / 2);

          // Đặt vòng tròn (trừ đi 20px để căn giữa vì kích thước là 40x40)
          circle.style.left = (centerX - 20) + 'px';
          circle.style.top = (centerY - 20) + 'px';

          // Tạo 4 dấu vuông L ở 4 góc
          const corners = ['corner-tl', 'corner-tr', 'corner-br', 'corner-bl'];
          corners.forEach(corner => {
            const cornerEl = document.createElement('div');
            cornerEl.className = `dock-corner ${corner}`;
            circle.appendChild(cornerEl);
          });

          // Mặc định ẩn (KHÔNG thêm class 'active')
          circle.classList.remove('active');

          document.body.appendChild(circle);
          dockCircles.push(circle);
        });
      }
      // Gọi tạo vòng tròn sau khi trang đã tải xong
      setTimeout(() => {
        createDockCircles();
        console.log('✅ Đã tạo vòng tròn bến:', dockCircles.length);
      }, 500);

      // Cập nhật vị trí vòng tròn khi resize
      function updateDockCirclesPosition() {
        dockCircles.forEach((circle, index) => {
          if (!circle || !docks[index]) return;

          const dockX = docks[index].getX();
          const dockY = docks[index].getY();

          const centerX = dockX + (ghostClock.offsetWidth / 2);
          const centerY = dockY + (ghostClock.offsetHeight / 2);

          circle.style.left = (centerX - 20) + 'px';
          circle.style.top = (centerY - 20) + 'px';
        });
      }

      // ===== KIỂM TRA VÙNG ẨN Ở GÓC DƯỚI =====
      function checkHideProximity() {
        if (!ghostClock) return null;
        const rect = ghostClock.getBoundingClientRect();
        const bottomDist = window.innerHeight - (rect.top + rect.height);
        const leftDist = rect.left;
        const rightDist = window.innerWidth - (rect.left + rect.width);

        // Góc phải dưới
        if (bottomDist <= DOCK_HIDE_THRESHOLD && rightDist <= DOCK_HIDE_THRESHOLD) return 'bottom-right';
        // Góc trái dưới
        if (bottomDist <= DOCK_HIDE_THRESHOLD && leftDist <= DOCK_HIDE_THRESHOLD) return 'bottom-left';
        return null;
      }

      function updateHideCue() {
        // Không hiển thị cue khi ghost đã bị ẩn
        if (ghostDismissed) {
          ghostClock.classList.remove('hide-cue');
          return;
        }
        const side = checkHideProximity();
        if (side) ghostClock.classList.add('hide-cue'); else ghostClock.classList.remove('hide-cue');
      }

      // Gọi tạo vòng tròn sau khi ghostClock đã có kích thước
      let currentDockProximity = null; // Bến đang ở gần (tên bến)
      let dockSnapTimer = null;        // Timer để tránh snap liên tục
      // Hàm tính khoảng cách giữa hai điểm
      function getDistance(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      }

      // Hàm lấy tâm đồng hồ
      function getGhostCenter() {
        const rect = ghostClock.getBoundingClientRect();
        return {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
      }

      // Hàm kiểm tra bến gần nhất
      function checkDockProximity() {
        // Nếu ghost đã bị ẩn (dismissed) thì không hiển thị các dock
        if (ghostDismissed) {
          dockCircles.forEach(circle => circle.classList.remove('active'));
          currentDockProximity = null;
          updateDockEffect(null);
          return null;
        }

        const center = getGhostCenter();
        let nearestDock = null;
        let minDistance = Infinity;

        // Đếm số bến đang ở gần
        let activeDocks = 0;

        docks.forEach((dock, index) => {
          const dockX = dock.getX() + ghostClock.offsetWidth / 2; // Tâm bến
          const dockY = dock.getY() + ghostClock.offsetHeight / 2;
          const distance = getDistance(center.x, center.y, dockX, dockY);

          // Kiểm tra từng bến có ở gần không
          if (distance <= dock.threshold) {
            activeDocks++;
            if (distance < minDistance) {
              minDistance = distance;
              nearestDock = dock.name;
            }
          }

          // Cập nhật hiển thị vòng tròn cho từng bến
          if (dockCircles[index]) {
            if (distance <= dock.threshold) {
              dockCircles[index].classList.add('active');
            } else {
              dockCircles[index].classList.remove('active');
            }
          }
        });

        // Log để debug (có thể xóa sau)
        if (activeDocks > 0) {
          console.log('Đang ở gần', activeDocks, 'bến');
        }

        // Cập nhật hiệu ứng trên đồng hồ
        if (nearestDock !== currentDockProximity) {
          currentDockProximity = nearestDock;
          updateDockEffect(nearestDock);
        }

        return nearestDock;
      }

      // Hàm cập nhật hiệu ứng khi ở gần bến
      // Hàm cập nhật hiệu ứng khi ở gần bến - GIỜ KHÔNG CÒN HIỆU ỨNG TRÊN ĐỒNG HỒ
      function updateDockEffect(dockName) {
        // KHÔNG làm gì cả - xóa hết hiệu ứng cũ
        ghostClock.classList.remove('dock-proximity');
        docks.forEach(dock => {
          ghostClock.classList.remove(`dock-${dock.name}`);
        });

        // Có thể thêm hiệu ứng nhỏ nếu muốn (ví dụ: đổi màu chữ)
        if (dockName) {
          // Ví dụ: chỉ thay đổi màu chữ của ghostLabel
          const label = document.getElementById('ghostLabel');
          if (label) {
            if (dockName === 'top-right') label.style.color = '#ffaa00';
            else if (dockName === 'top-left') label.style.color = '#ff66ff';
          }
        } else {
          const label = document.getElementById('ghostLabel');
          if (label) label.style.color = 'var(--cyan)';
        }
      }

      function snapToNearestDock() {
        if (dockSnapTimer) return;

        const nearestDock = checkDockProximity();
        if (!nearestDock) {
          currentDockProximity = null;
          updateDockEffect(null);
          return;
        }

        const dock = docks.find(d => d.name === nearestDock);
        if (!dock) return;

        const snapX = dock.getX();
        const snapY = dock.getY();

        const rect = ghostClock.getBoundingClientRect();
        if (Math.abs(rect.left - snapX) < 5 && Math.abs(rect.top - snapY) < 5) {
          currentDockProximity = null;
          updateDockEffect(null);
          return;
        }

        ghostClock.classList.add('snapping');
        setGhostPosition(snapX, snapY);

        // Xóa hiệu ứng bến
        currentDockProximity = null;
        updateDockEffect(null);

        // 👉 TẮT VÒNG TRÒN
        dockCircles.forEach(circle => {
          circle.classList.remove('active');
        });

        // Hiệu ứng flash khi snap
        dockCircles.forEach((circle, index) => {
          if (docks[index].name === nearestDock) {
            circle.style.animation = 'none';
            circle.offsetHeight;
            circle.style.animation = 'dock-pulse 1.5s ease-in-out infinite';
            circle.classList.add('active');

            setTimeout(() => {
              // Sau 1 giây thì tắt vòng tròn
              setTimeout(() => {
                circle.classList.remove('active');
              }, 800);
            }, 100);
          }
        });

        dockSnapTimer = setTimeout(() => {
          ghostClock.classList.remove('snapping');
          dockSnapTimer = null;
        }, 300);
      }
      // ===== VÙNG PEEK ĐỘNG (LUÔN BÁM THEO ĐỒNG HỒ) =====
      let peekZone = null;
      let updatePeekZoneInterval = null;

      // Hàm tạo hoặc cập nhật vị trí vùng peek
      function updatePeekZonePosition() {
        if (!peekZone) {
          peekZone = document.createElement('div');
          Object.assign(peekZone.style, {
            position: 'fixed',
            zIndex: '10000',
            pointerEvents: 'auto',
            backgroundColor: 'transparent',
            display: 'none'
          });
          document.body.appendChild(peekZone);

          // Gắn sự kiện cho peekZone
          peekZone.addEventListener('mouseenter', () => {
            if (realClockVisible || !ghostDismissed || alertPopTimeout) return;
            clearTimeout(ghostHoverTimeout);
            ghostClock.classList.remove('should-show', 'alert-pop');
            ghostClock.classList.add('peek');
            ghostHint.textContent = '[ NHẤN ĐỂ HIỆN LẠI ]';
          });

          // Click vào vùng peek => hiện lại ghost nếu đang bị dismiss
          peekZone.addEventListener('click', () => {
            if (!ghostDismissed) return;
            ghostDismissed = false;
            ghostClock.classList.remove('dismissed');
            // Lấy vị trí lưu trong localStorage (đã được reset khi dismiss)
            try {
              const saved = localStorage.getItem('ghostClockPos');
              if (saved) {
                const p = JSON.parse(saved);
                if (p.left !== undefined && p.top !== undefined) setGhostPosition(p.left, p.top);
              }
            } catch (err) { /* ignore */ }
            ghostClock.classList.add('should-show');
            ghostHint.textContent = '[ NHẤN ĐỂ ẨN ]';
            updatePeekZonePosition();
          });

          peekZone.addEventListener('mouseleave', () => {
            if (!ghostClock.classList.contains('peek')) return;
            clearTimeout(ghostHoverTimeout);
            ghostHoverTimeout = setTimeout(() => {
              ghostClock.classList.remove('peek');
            }, 300);
          });
        }

        // Cập nhật vị trí và kích thước theo đồng hồ
        if (ghostClock && ghostClock.style.display !== 'none') {
          const rect = ghostClock.getBoundingClientRect();
          // Mở rộng vùng peek thêm 20px xung quanh đồng hồ
          peekZone.style.left = (rect.left - 20) + 'px';
          peekZone.style.top = (rect.top - 20) + 'px';
          peekZone.style.width = (rect.width + 40) + 'px';
          peekZone.style.height = (rect.height + 40) + 'px';
          peekZone.style.display = 'block';
        } else {
          peekZone.style.display = 'none';
        }
      }

      // Bắt đầu cập nhật vị trí peekZone liên tục
      function startPeekZoneUpdates() {
        if (updatePeekZoneInterval) clearInterval(updatePeekZoneInterval);
        updatePeekZoneInterval = setInterval(updatePeekZonePosition, 100); // Cập nhật 10 lần/giây
      }

      // Dừng cập nhật
      function stopPeekZoneUpdates() {
        if (updatePeekZoneInterval) {
          clearInterval(updatePeekZoneInterval);
          updatePeekZoneInterval = null;
        }
        if (peekZone) peekZone.style.display = 'none';
      }

      // Khởi động ngay khi trang load
      startPeekZoneUpdates();
      // Hàm cập nhật vị trí đồng hồ
      function setGhostPosition(left, top) {
        ghostClock.style.left = left + 'px';
        ghostClock.style.top = top + 'px';
        ghostClock.style.right = 'auto';  // Vô hiệu hóa right
        ghostClock.style.bottom = 'auto'; // Vô hiệu hóa bottom
        // Lưu vào localStorage để nhớ vị trí sau khi tải lại trang
        localStorage.setItem('ghostClockPos', JSON.stringify({ left, top }));
        ghostCurrentLeft = left;
        ghostCurrentTop = top;

        // 👉 THÊM DÒNG NÀY: cập nhật vùng peek ngay lập tức
        updatePeekZonePosition();
        checkDockProximity();
      }

      // Khôi phục vị trí từ localStorage nếu có
      try {
        const savedPos = localStorage.getItem('ghostClockPos');
        if (savedPos) {
          const pos = JSON.parse(savedPos);
          if (pos.left !== undefined && pos.top !== undefined) {
            ghostClock.style.left = pos.left + 'px';
            ghostClock.style.top = pos.top + 'px';
            ghostClock.style.right = 'auto';
            ghostClock.style.bottom = 'auto';
            ghostCurrentLeft = pos.left;
            ghostCurrentTop = pos.top;
          }
        }
      } catch (e) {
        console.log('Khôi phục vị trí ghost clock thất bại', e);
      }
      // ===== KÉO THẢ GHOST CLOCK =====
      ghostShell.addEventListener('mousedown', startDrag);
      ghostShell.addEventListener('touchstart', startDrag, { passive: false });

      function startDrag(e) {
        // Ngăn chặn hành vi mặc định (kéo thả ảnh, bôi đen text...)
        e.preventDefault();

        // Nếu đang có alert pop, tắt nó đi
        if (alertPopTimeout) {
          clearTimeout(alertPopTimeout);
          alertPopTimeout = null;
        }

        // Xác định tọa độ bắt đầu
        if (e.type === 'mousedown') {
          dragStartX = e.clientX;
          dragStartY = e.clientY;
        } else {
          dragStartX = e.touches[0].clientX;
          dragStartY = e.touches[0].clientY;
        }

        // Lấy vị trí hiện tại của đồng hồ
        const rect = ghostClock.getBoundingClientRect();
        ghostStartLeft = rect.left;
        ghostStartTop = rect.top;

        // Đánh dấu đang kéo và thêm class
        isDragging = true;
        ghostClock.classList.add('dragging');

        // Gắn sự kiện move và end cho toàn bộ window
        window.addEventListener('mousemove', onDrag);
        window.addEventListener('mouseup', stopDrag);
        window.addEventListener('touchmove', onDrag, { passive: false });
        window.addEventListener('touchend', stopDrag);
        window.addEventListener('touchcancel', stopDrag);
      }

      function onDrag(e) {
        if (!isDragging) return;
        e.preventDefault(); // Chống cuộn trang khi kéo trên mobile

        // Tính toán vị trí mới
        let clientX, clientY;
        if (e.type === 'mousemove') {
          clientX = e.clientX;
          clientY = e.clientY;
        } else {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }

        const deltaX = clientX - dragStartX;
        const deltaY = clientY - dragStartY;

        let newLeft = ghostStartLeft + deltaX;
        let newTop = ghostStartTop + deltaY;

        // Giới hạn trong màn hình (tùy chọn)
        const maxLeft = window.innerWidth - ghostClock.offsetWidth;
        const maxTop = window.innerHeight - ghostClock.offsetHeight;
        newLeft = Math.max(5, Math.min(maxLeft - 5, newLeft));
        newTop = Math.max(5, Math.min(maxTop - 5, newTop));

        // Cập nhật vị trí
        setGhostPosition(newLeft, newTop);
        checkDockProximity();
        // Cập nhật hiệu ứng báo vùng ẩn khi kéo
        try { updateHideCue(); } catch (err) { /* ignore */ }
      }

      function stopDrag(e) {
        if (!isDragging) return;
        e.preventDefault();

        // Gỡ bỏ sự kiện
        window.removeEventListener('mousemove', onDrag);
        window.removeEventListener('mouseup', stopDrag);
        window.removeEventListener('touchmove', onDrag);
        window.removeEventListener('touchend', stopDrag);
        window.removeEventListener('touchcancel', stopDrag);

        // Kết thúc kéo
        isDragging = false;
        ghostClock.classList.remove('dragging');

        // Cập nhật biến vị trí hiện tại
        const rect = ghostClock.getBoundingClientRect();
        ghostCurrentLeft = rect.left;
        ghostCurrentTop = rect.top;

        // Kiểm tra xem có thả vào vùng ẩn hay không
        const hideSide = checkHideProximity();
        if (hideSide) {
          // Thực hiện ẩn giống như click dismiss
          ghostDismissed = true;
          ghostClock.classList.remove('should-show', 'peek', 'alert-pop');
          ghostClock.classList.add('dismissed');
          ghostHint.textContent = '[ NHẤN ĐỂ HIỆN LẠI ]';
          resetDockCircles();

          // Reset vị trí về bến tương ứng
          const targetDockName = hideSide === 'bottom-right' ? 'top-right' : 'top-left';
          const targetDock = docks.find(d => d.name === targetDockName);
          if (targetDock) {
            // Đặt ngay vị trí bến và lưu vào localStorage
            setGhostPosition(targetDock.getX(), targetDock.getY());
          }

          // Ẩn hiệu ứng cảnh báo
          ghostClock.classList.remove('hide-cue');
          updatePeekZonePosition();
          return;
        }

        // Nếu không phải vùng ẩn thì xử lý snap bình thường
        snapToNearestDock();
        updatePeekZonePosition();
      }

      function renderGhostDigit(svgEl, num, onColor, offColor) {
        const segs = DIGITS[num] !== undefined ? DIGITS[num] : DIGITS[8]; svgEl.innerHTML = '';
        gSEG_POLY.forEach((pts, i) => { const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); poly.setAttribute('points', pts); const on = segs[i] === 1; poly.setAttribute('fill', on ? onColor : offColor); if (on) poly.setAttribute('style', `filter:drop-shadow(0 0 1.5px ${onColor})`); svgEl.appendChild(poly); });
      }
      function syncGhost(alarm) {
        const on = alarm ? '#ff3333' : 'var(--seg-on)', off = alarm ? 'rgba(255,51,51,0.06)' : 'var(--seg-off)';
        const m = Math.floor(remaining / 60), s = remaining % 60, d4 = Math.floor(m / 100), d0 = Math.floor((m % 100) / 10), d1 = m % 10, d2 = Math.floor(s / 10), d3 = s % 10;
        gdEls[0].style.display = m >= 100 ? 'block' : 'none';
        [d4, d0, d1, d2, d3].forEach((n, i) => renderGhostDigit(gdEls[i], n, on, off));
        const frac = totalSec > 0 ? remaining / totalSec : 0;
        ghostProgressBar.style.strokeDashoffset = G_CIRC * (1 - frac);
        const warn = alarm || (remaining <= 10 && remaining > 0);
        ghostProgressBar.style.stroke = warn ? '#ff3333' : 'var(--cyan)';
        ghostProgressBar.style.filter = warn ? 'drop-shadow(0 0 5px #ff3333)' : 'drop-shadow(0 0 4px var(--cyan))';
        [gcd1, gcd2].forEach(d => running ? d.classList.remove('paused') : d.classList.add('paused'));
        alarm ? ghostSegDisplay.classList.add('alarm') : ghostSegDisplay.classList.remove('alarm');
        ghostLabel.textContent = hudStatusText.textContent;
      }
      function applyGhostVisibility() {
        ghostClock.classList.remove('should-show', 'peek', 'alert-pop');

        // Quản lý hiển thị peekZone
        if (peekZone) {
          if (realClockVisible || !ghostDismissed) {
            peekZone.style.display = 'none'; // Không cần peekZone khi đồng hồ đang hiện
          } else {
            updatePeekZonePosition(); // Cập nhật vị trí và hiện peekZone
          }
        }

        // 👉 ẨN DOCK CIRCLES KHI GHOST CLOCK KHÔNG HIỂN THỊ
        if (realClockVisible || ghostDismissed) {
          resetDockCircles();
        }

        if (realClockVisible) return;
        if (!ghostDismissed) {
          ghostClock.classList.add('should-show');
          ghostHint.textContent = '[ NHẤN ĐỂ ẨN ]';
          // Đảm bảo right/bottom không ghi đè left/top nếu đã kéo
          if (ghostCurrentLeft !== null && ghostCurrentTop !== null) {
            ghostClock.style.right = 'auto';
            ghostClock.style.bottom = 'auto';
          }
        }
      }
      function triggerAlertPop() {
        if (alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        ghostClock.classList.remove('should-show', 'peek');
        ghostClock.classList.add('alert-pop');

        // 👉 THÊM DÒNG NÀY: tạm ẩn peekZone khi đang alert
        if (peekZone) peekZone.style.display = 'none';

        // 👉 ẨN DOCK CIRCLES KHI ALERT POP
        resetDockCircles();

        // Đảm bảo vị trí không bị reset
        if (ghostCurrentLeft !== null && ghostCurrentTop !== null) {
          ghostClock.style.right = 'auto';
          ghostClock.style.bottom = 'auto';
        }
        alertPopTimeout = setTimeout(() => {
          ghostClock.classList.remove('alert-pop');
          applyGhostVisibility();
          alertPopTimeout = null;
        }, 5000);
      }
      ghostShell.addEventListener('click', (e) => {
        // Nếu đang kéo thì không xử lý click
        if (isDragging) {
          e.stopPropagation();
          return;
        }
        if (alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        ghostClock.classList.remove('alert-pop', 'should-show', 'peek');
        if (!ghostDismissed) {
          ghostDismissed = true;
          ghostHint.textContent = '[ NHẤN ĐỂ HIỆN LẠI ]';
          // 👉 ẨN DOCK CIRCLES KHI DISMISS GHOST CLOCK
          resetDockCircles();
        } else {
          ghostDismissed = false;
          ghostHint.textContent = '[ NHẤN ĐỂ ẨN ]';
          if (!realClockVisible) ghostClock.classList.add('should-show');
        }
      });

      // Cho phép click trực tiếp vào dòng hint để hiện lại khi đang bị dismiss
      if (ghostHint) {
        ghostHint.addEventListener('click', (ev) => {
          ev.stopPropagation();
          if (!ghostDismissed) return;
          ghostDismissed = false;
          ghostClock.classList.remove('dismissed');
          try {
            const saved = localStorage.getItem('ghostClockPos');
            if (saved) {
              const p = JSON.parse(saved);
              if (p.left !== undefined && p.top !== undefined) setGhostPosition(p.left, p.top);
            }
          } catch (err) { }
          ghostClock.classList.add('should-show');
          ghostHint.textContent = '[ NHẤN ĐỂ ẨN ]';
          updatePeekZonePosition();
        });
      }

      ghostShell.addEventListener('mouseenter', () => clearTimeout(ghostHoverTimeout));
      ghostShell.addEventListener('mouseleave', () => {
        if (!ghostClock.classList.contains('peek')) return;
        ghostHoverTimeout = setTimeout(() => ghostClock.classList.remove('peek'), 300);
      });
      const observer = new IntersectionObserver((entries) => {
        realClockVisible = entries[0].isIntersecting;
        if (realClockVisible && alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        applyGhostVisibility();
      }, { threshold: 0.3 });
      observer.observe(document.getElementById('hudClockWrap'));

      // ── Tick functions ──
      function checkMilestone() {
        if (MILESTONES.has(remaining) && !firedMilestones.has(remaining)) {
          firedMilestones.add(remaining); if (!realClockVisible) triggerAlertPop();
        }
      }
      function tickWithGhost() {
        if (remaining <= 0) {
          clearInterval(timerID); timerID = null; running = false; remaining = 0;
          renderTime(0, '#ff3333', 'rgba(255,51,51,0.06)');
          hudProgressBar.style.strokeDashoffset = CIRC; hudProgressBar.style.stroke = '#ff3333'; hudProgressBar.style.filter = 'drop-shadow(0 0 5px #ff3333)';
          hudSegDisplay.classList.add('alarm'); setColonPause(true);
          document.getElementById('hudStartBtn').innerHTML = '▶ START'; setStatus('done'); syncGhost(true);
          if (!realClockVisible) triggerAlertPop(); return;
        }
        remaining--;
        const alarm = remaining <= 10 && remaining > 0, on = alarm ? '#ff3333' : 'var(--seg-on)', off = alarm ? 'rgba(255,51,51,0.06)' : 'var(--seg-off)';
        renderTime(remaining, on, off);
        const frac = totalSec > 0 ? remaining / totalSec : 0;
        hudProgressBar.style.strokeDashoffset = CIRC * (1 - frac); hudProgressBar.style.stroke = alarm ? '#ff3333' : 'var(--cyan)'; hudProgressBar.style.filter = alarm ? 'drop-shadow(0 0 5px #ff3333)' : 'drop-shadow(0 0 4px var(--cyan))';
        syncGhost(alarm); checkMilestone();
      }

      // ── Button wiring ──
      document.getElementById('hudStartBtn').addEventListener('click', () => {
        if (!running) {
          if (!timerID && remaining === 0) getInputTime();
          hudSegDisplay.classList.remove('alarm'); ghostSegDisplay.classList.remove('alarm'); setColonPause(false);[gcd1, gcd2].forEach(d => d.classList.remove('paused'));
          timerID = setInterval(tickWithGhost, 1000); running = true; document.getElementById('hudStartBtn').innerHTML = '⏸ PAUSE'; setStatus('running'); syncGhost(false);
        } else {
          clearInterval(timerID); timerID = null; running = false; setColonPause(true);[gcd1, gcd2].forEach(d => d.classList.add('paused'));
          document.getElementById('hudStartBtn').innerHTML = '▶ RESUME'; setStatus('paused'); syncGhost(false);
        }
      });
      document.getElementById('hudResetBtn').addEventListener('click', () => {
        clearInterval(timerID); timerID = null; running = false;
        hudSegDisplay.classList.remove('alarm'); ghostSegDisplay.classList.remove('alarm'); setColonPause(false);[gcd1, gcd2].forEach(d => d.classList.remove('paused'));
        if (alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        getInputTime(); renderTime(remaining, 'var(--seg-on)', 'var(--seg-off)');
        hudProgressBar.style.strokeDashoffset = 0; hudProgressBar.style.stroke = 'var(--cyan)'; hudProgressBar.style.filter = 'drop-shadow(0 0 4px var(--cyan))';
        document.getElementById('hudStartBtn').innerHTML = '▶ START'; setStatus('standby'); syncGhost(false); applyGhostVisibility();
      });
      hudInputMin.addEventListener('change', () => { if (!running) { getInputTime(); updateDisplay(false); syncGhost(false); } });
      hudInputSec.addEventListener('change', () => { if (!running) { getInputTime(); updateDisplay(false); syncGhost(false); } });
      // ── Cập nhật khi resize cửa sổ ──
      window.addEventListener('resize', function () {
        // Cập nhật threshold cho docks (vì kích thước đồng hồ có thể thay đổi)
        docks.forEach(dock => {
          dock.threshold = ghostClock ? ghostClock.offsetWidth * 2 : 120;
        });

        // Kiểm tra lại khoảng cách nếu đang hiển thị
        if (ghostClock.style.display !== 'none') {
          checkDockProximity();
        }

        // Cập nhật vị trí vòng tròn
        if (typeof updateDockCirclesPosition === 'function') {
          updateDockCirclesPosition();
        }
      });

      // ── Init ──
      getInputTime(); updateDisplay(false); setStatus('standby'); syncGhost(false); applyGhostVisibility();
      // ── Dọn dẹp khi trang đóng ──
      window.addEventListener('beforeunload', function () {
        stopPeekZoneUpdates();
        if (peekZone && peekZone.parentNode) {
          peekZone.parentNode.removeChild(peekZone);
        }

        // 👉 THÊM DÒNG NÀY: xóa vòng tròn bến
        dockCircles.forEach(circle => {
          if (circle && circle.parentNode) {
            circle.parentNode.removeChild(circle);
          }
        });
      });
    })();
  </script>

  <script>
    // ==================== INITIALIZATION ====================
    window.answers = JSON.parse(
      localStorage.getItem("customAnswers") || "{}",
    );
    let readingComprehensionCount = 0;
    const readingTimers = {};
    const savedRanges = {};


    // ==================== PROGRESS CONFIG (đồng bộ theo User ID) ====================
    const API_URL = "https://n1-license-server.onrender.com/api";
    const LS_DEVICE_ID = "n1_device_id";
    const LS_LICENSE = "n1_license";

    function getTestId() {
      const p = new URL(location.href).pathname;
      return p.split("/").pop() || "unknown.html";
    }

    function makeAttemptId() {
      return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    async function tryMarkPerfect() {
      const deviceId = localStorage.getItem(LS_DEVICE_ID) || "";
      const license = localStorage.getItem(LS_LICENSE) || "";
      if (!deviceId || !license) return;

      const moduleId = getTestId();
      //const attemptId = makeAttemptId();

      try {
        const res = await fetch(`${API_URL}/progress/mark-perfect`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ deviceId, license, moduleId }),
        });
        if (!res.ok) return;

        const data = await res.json();
        if (data && data.ok) {
          console.log("[PROGRESS] saved", { moduleId, ...data });
        }
      } catch (e) {
        console.log("progress api offline", e);
      }
    }


    // ==================== QUIZ DATA ====================
    const quizData = [
  {
    number: 1,
    question: '研ぐ',
    options: ['そぐ', 'とぐ', 'もぐ', 'ほぐ'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 2,
    question: 'とろける',
    options: ['Tan chảy', 'Liếm, nhấm nháp, mút(dùng lưỡi)', 'Mô phỏng, phỏng theo, bắt chước', 'Nhúng vào nước'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 3,
    question: 'なめる',
    options: ['Đơm, đổ,múc (cơm, thức ăn...)', 'Đón tiếp, tiếp đãi', 'Liếm, nhấm nháp, mút(dùng lưỡi)', 'Đổ, rót (nước, trà...)'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 4,
    question: '倣う',
    options: ['ながう', 'なかう', 'ねらう', 'ならう'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 5,
    question: '浸す',
    options: ['じたす', 'びたす', 'ひたす', 'きたす'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 6,
    question: '召す',
    options: ['けす', 'ぬす', 'めす', 'へす'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 7,
    question: 'もてなす',
    options: ['Nhúng vào nước', 'Đón tiếp, tiếp đãi', 'Đơm, đổ,múc (cơm, thức ăn...)', 'Đổ, rót (nước, trà...)'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 8,
    question: '盛る',
    options: ['もる', 'こる', 'そる', 'ほる'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 9,
    question: '炙る',
    options: ['あする', 'あくる', 'あふる', 'あぶる'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 10,
    question: '注ぐ',
    options: ['すすぐ', 'そそぐ', 'すしぐ', 'すきぐ'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 11,
    question: '生ぬるい',
    options: ['なまぬるい', 'せいぬるい', 'しょうぬるい', 'やぬるい'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 12,
    question: '平たい',
    options: ['ひだたい', 'ひらたい', 'ひさたい', 'ひまたい'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 13,
    question: '巧み',
    options: ['ばくみ', 'はくみ', 'だくみ', 'たくみ'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 14,
    question: '濃厚',
    options: ['のこ', 'のうこう', 'のこう', 'のうこ'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 15,
    question: '憩い',
    options: ['じこい', 'みこい', 'いこい', 'しこい'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 16,
    question: '起床',
    options: ['きそ', 'きしょう', 'きしょ', 'きそう'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 17,
    question: '基盤',
    options: ['きたん', 'きぱん', 'きはん', 'きばん'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 18,
    question: '幸運',
    options: ['こううん', 'こうん', 'こうふん', 'こうくん'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 19,
    question: '飼育',
    options: ['よういく', 'きょういく', 'しいく', 'かいく'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 20,
    question: 'しつけ',
    options: ['Thức dậy', 'Nền móng, nền tảng', 'Nuôi (gia súc..)', 'Giáo dục, nuôi dạy (trong gia đình)'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 21,
    question: 'Mài',
    options: ['研ぐ', '濯ぐ', '注ぐ', '寛ぐ'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 22,
    question: 'Tan chảy',
    options: ['どろける', 'とろける', 'とどける', 'とほける'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 23,
    question: 'Liếm, nhấm nháp, mút(dùng lưỡi)',
    options: ['なめる', 'なみる', 'なまる', 'なかる'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 24,
    question: 'Mô phỏng, phỏng theo, bắt chước',
    options: ['飼う', '逢う', '縫う', '倣う'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 25,
    question: 'Nhúng vào nước',
    options: ['潤す', '押す', '浸す', '召す'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 26,
    question: 'Tôn kính ngữ của động từ 「食う」「飲む」「着る」「(かぜを)引く」「乗る」「(ふろに)入る」「(気に)いる」「(年を)とる」',
    options: ['もてなす', '盛る', '召す', '浸す'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 27,
    question: 'Đón tiếp, tiếp đãi',
    options: ['もてなす', '浸す', '召す', '倣う'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 28,
    question: 'Đơm, đổ,múc (cơm, thức ăn...)',
    options: ['盛る', '狩る', '減る', '炙る'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 29,
    question: 'Khò, hơ (qua lửa)',
    options: ['盛る', '炙る', '注ぐ', '濯ぐ'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 30,
    question: 'Đổ, rót (nước, trà...)',
    options: ['急ぐ', '寛ぐ', '濯ぐ', '注ぐ'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 31,
    question: 'Âm ấm, nguội (không lạnh cũng không nóng hẳn)',
    options: ['温ぬるい', '生ぬるい', '暖ぬるい', '寒ぬるい'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 32,
    question: 'Bằng phẳng, dẹt',
    options: ['平さい', '平たい', '平まい', '平しい'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 33,
    question: 'Khéo léo',
    options: ['巧さ', '巧き', '巧し', '巧み'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 34,
    question: 'Đậm đà (vị, màu sắc, mùi...)',
    options: ['温厚', '濃厚', '分厚い', '手厚い'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 35,
    question: 'Nghỉ ngơi, thư giãn',
    options: ['臭い', '匂い', '憩い', '遅い'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 36,
    question: 'Thức dậy',
    options: ['起源', '起床', '起立', '起点'],
    answer: '2',
    detail: '',
    isReading: false
  },
  {
    number: 37,
    question: 'Nền móng, nền tảng',
    options: ['基数', '基質', '基本', '基盤'],
    answer: '4',
    detail: '',
    isReading: false
  },
  {
    number: 38,
    question: 'May mắn, vận may',
    options: ['幸運', '幸福', '不幸', '幸甚'],
    answer: '1',
    detail: '',
    isReading: false
  },
  {
    number: 39,
    question: 'Nuôi (gia súc..)',
    options: ['育成', '教育', '飼育', '飼料'],
    answer: '3',
    detail: '',
    isReading: false
  },
  {
    number: 40,
    question: 'Giáo dục, nuôi dạy (trong gia đình)',
    options: ['りつけ', 'きつけ', 'みつけ', 'しつけ'],
    answer: '4',
    detail: '',
    isReading: false
  }
]; 

    // ==================== READING TIMER FUNCTIONS ====================
    function setReadingTimer(idx) {
      const inputEl = document.getElementById(`readTimeInput-${idx}`);
      if (!inputEl) return;
      const minutes = parseInt(inputEl.value);
      if (isNaN(minutes) || minutes <= 0) {
        alert("Nhập số phút ≥ 1.");
        return;
      }
      readingTimers[idx] = {
        remaining: minutes * 60,
        original: minutes * 60,
        intervalId: null,
      };
      updateReadingTimerDisplay(idx);
    }

    function startReadingTimer(idx) {
      if (!readingTimers[idx])
        readingTimers[idx] = {
          remaining: 60,
          original: 60,
          intervalId: null,
        };
      if (readingTimers[idx].intervalId) return;
      readingTimers[idx].intervalId = setInterval(() => {
        const timerObj = readingTimers[idx];
        timerObj.remaining--;
        updateReadingTimerDisplay(idx);
        if (timerObj.remaining <= 0) {
          clearInterval(timerObj.intervalId);
          timerObj.intervalId = null;
          showTimeUpAlert(idx);
        }
      }, 1000);
    }

    function resetReadingTimer(idx) {
      const timerObj = readingTimers[idx];
      if (timerObj) {
        if (timerObj.intervalId) {
          clearInterval(timerObj.intervalId);
          timerObj.intervalId = null;
        }
        timerObj.remaining = timerObj.original || 0;
        updateReadingTimerDisplay(idx);
      }
    }

    function updateReadingTimerDisplay(idx) {
      const disp = document.getElementById(`readingTimerDisplay-${idx}`);
      if (!disp) return;
      const timerObj = readingTimers[idx] || { remaining: 0 };
      let sec = timerObj.remaining < 0 ? 0 : timerObj.remaining;
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      disp.textContent = `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    }

    function showTimeUpAlert(idx) {
      const readingBlock = document.querySelector(
        `.reading-comprehension[data-index='${idx}']`,
      );
      if (!readingBlock) return;
      const readingLabel = readingBlock.querySelector(".reading-label");
      const readingName = readingLabel
        ? readingLabel.textContent.trim()
        : `Đọc hiểu ${idx + 1}`;
      const alertDiv = document.createElement("div");
      alertDiv.innerHTML = `⏰ Hết thời gian của <strong>${readingName}</strong> rồi!`;
      alertDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #d32f2f; color: white; padding: 20px 40px; border-radius: 5px; font-size: 24px; z-index: 100000; box-shadow: 0 4px 8px rgba(0,0,0,0.2);`;
      document.body.appendChild(alertDiv);
      setTimeout(() => alertDiv.remove(), 3000);
    }

    // ==================== HIGHLIGHT FUNCTIONS ====================
    function highlightSelection(idx, color) {
      const selection = window.getSelection();
      const range =
        savedRanges[idx] ||
        (selection.rangeCount > 0
          ? selection.getRangeAt(0).cloneRange()
          : null);
      if (!range || range.collapsed) {
        alert(
          "Vui lòng bôi đen văn bản trong phần đọc hiểu trước khi đổi màu.",
        );
        return;
      }
      const readingBlock = document.querySelector(
        `.reading-comprehension[data-index="${idx}"]`,
      );
      if (
        !readingBlock ||
        !readingBlock.contains(range.commonAncestorContainer)
      ) {
        alert("Vui lòng chọn văn bản trong phần đọc hiểu tương ứng.");
        return;
      }
      const fragment = range.extractContents();
      const span = document.createElement("span");
      span.style.color = color;
      span.style.fontWeight = "bold";
      span.appendChild(fragment);
      range.insertNode(span);
      savedRanges[idx] = null;
      selection.removeAllRanges();
    }

    function removeHighlights(idx) {
      const readingBlock = document.querySelector(
        `.reading-comprehension[data-index="${idx}"]`,
      );
      if (!readingBlock) return;
      const highlightedSpans = readingBlock.querySelectorAll(
        'span[style*="color:"]',
      );
      highlightedSpans.forEach((span) => {
        const content = document.createDocumentFragment();
        while (span.firstChild) content.appendChild(span.firstChild);
        span.parentNode.insertBefore(content, span);
        span.parentNode.removeChild(span);
      });
    }

    function findAncestor(el, fn) {
      while (el) {
        if (fn(el)) return el;
        el = el.parentNode;
      }
      return null;
    }

    // Save selection for highlight
    document.addEventListener("mouseup", function (e) {
      const sel = window.getSelection();
      if (sel.isCollapsed) return;
      const range = sel.getRangeAt(0);
      const readingBlock = findAncestor(
        range.commonAncestorContainer,
        (el) =>
          el.classList && el.classList.contains("reading-comprehension"),
      );
      if (readingBlock) {
        const idx = parseInt(readingBlock.getAttribute("data-index"));
        savedRanges[idx] = range.cloneRange();
      }
    });

    // ==================== RENDER QUIZ ====================

    // Bookmark helpers: storage + server sync
    function getTestIdFromUrl() {
      try { const u = new URL(window.location.href); return u.searchParams.get('testId') || u.searchParams.get('test') || document.title || 'unknown_test'; } catch(e) { return document.title || 'unknown_test'; }
    }

    // userId helpers: do NOT prompt on load; prompt only when user attempts to bookmark and no id available
    function getStoredUserId() { try { return localStorage.getItem('hq_userId'); } catch(e) { return null; } }
    function setStoredUserId(id) { try { if (id) localStorage.setItem('hq_userId', id); } catch(e){} }
    function getUserIdFromUrl() { try { const u = new URL(window.location.href); return u.searchParams.get('userId') || u.searchParams.get('uid') || null; } catch(e){ return null; } }
    function getUserId() {
      // prefer global variable `n1_user_id` if set by server/template
      if (typeof window.n1_user_id !== 'undefined' && window.n1_user_id) return window.n1_user_id;
      if (window._hq_userId !== undefined && window._hq_userId) { window.n1_user_id = window._hq_userId; return window.n1_user_id; }
      const fromUrl = getUserIdFromUrl();
      if (fromUrl) { window.n1_user_id = fromUrl; return window.n1_user_id; }
      const stored = getStoredUserId();
      if (stored) { window.n1_user_id = stored; return window.n1_user_id; }
      window.n1_user_id = null;
      return null;
    }

    function storageKey(testId, userId) { return `bookmarks:${testId}:user:${userId || '__anon'}`; }
    function loadBookmarks(testId, userId) { try { const r = localStorage.getItem(storageKey(testId, userId)); return r ? JSON.parse(r) : []; } catch(e){ return []; } }
    function saveBookmarks(testId, userId, arr) { localStorage.setItem(storageKey(testId, userId), JSON.stringify(arr)); }

    async function postBookmark(bookmark) { try { const res = await fetch('/api/bookmarks', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(bookmark) }); return res.ok; } catch(e) { return false; } }

    function createStar(element, questionKey, questionText, questionNumber) {
      const testId = getTestIdFromUrl();
      const btn = document.createElement('span');
      btn.className = 'bookmark-star';
      btn.setAttribute('role','button');
      btn.title = 'Đánh dấu (Shift+click để thêm ghi chú)';
      btn.innerHTML = '<i class="fa-regular fa-star"></i>';

      // ensure star is positioned relative to the element it's attached to
      try {
        const cs = window.getComputedStyle(element);
        if (!cs || cs.position === 'static') element.style.position = 'relative';
      } catch (e) { element.style.position = 'relative'; }

      let storedUserId = getUserId();
      const stored = loadBookmarks(testId, storedUserId).find(b => b.questionKey === questionKey);
      if (stored) { btn.classList.add('starred'); btn.innerHTML = '<i class="fa-solid fa-star"></i>'; }

      btn.addEventListener('click', async (ev) => {
        ev.stopPropagation();
        // determine userId (ask user if none found)
        let userId = getUserId();
        if (!userId) {
          const input = prompt('Nhập userId để lưu bookmark theo user (hủy để lưu tạm cho guest):', '');
          if (input) { setStoredUserId(input); window.n1_user_id = input; userId = input; }
        }

        // re-evaluate stored bookmark for this user
        const localStored = loadBookmarks(testId, userId).find(b => b.questionKey === questionKey);
        const note = ev.shiftKey ? (prompt('Ghi chú cho câu hỏi (tùy chọn):', localStored && localStored.note ? localStored.note : '') || '') : (localStored && localStored.note ? localStored.note : '');
        const bookmark = {
          id: `${questionKey}_${Date.now()}`,
          questionKey: questionKey,
          questionText: (questionText||'').slice(0,500),
          questionNumber: questionNumber || '',
          testId: testId,
          userId: userId || null,
          timestamp: Date.now(),
          note: note || '',
          synced: false
        };

        const arr = loadBookmarks(testId, userId);
        const exists = arr.findIndex(b => b.questionKey === questionKey) !== -1;
        if (exists) {
          const newArr = arr.filter(b => b.questionKey !== questionKey);
          saveBookmarks(testId, userId, newArr);
          btn.classList.remove('starred'); btn.innerHTML = '<i class="fa-regular fa-star"></i>';
        } else {
          arr.push(bookmark); saveBookmarks(testId, userId, arr);
          btn.classList.add('starred'); btn.innerHTML = '<i class="fa-solid fa-star"></i>';
          postBookmark(bookmark).then(ok => { if (ok) { const a = loadBookmarks(testId, userId); const idx = a.findIndex(x=>x.id===bookmark.id); if (idx!==-1){ a[idx].synced = true; saveBookmarks(testId,userId,a);} } });
        }
      });

      element.appendChild(btn);
    }

    function renderQuiz() {
      const form = document.getElementById("quizForm");
      if (!form) return;
      form.innerHTML = "";
      readingComprehensionCount = 0;

      quizData.forEach((q, index) => {
        const div = document.createElement("div");
        div.classList.add("question-block");

        if (q.isReading) {
          readingComprehensionCount++;
          let subQuestionsHtml = "";
          if (q.subQuestions && q.subQuestions.length > 0) {
            subQuestionsHtml = q.subQuestions
              .map(
                (subQ, subIndex) => `
              <div class="sub-question-container">
                <div class="sub-question-box">
                  <p><strong>${subQ.number}.</strong> ${subQ.subQuestion} <span class="sub-question-key">[key: q${index}_${subIndex}]</span></p>
                  <div class="sub-question-options">
                    ${subQ.options
                    .map(
                      (opt, optIndex) => `
                      <label class="answer-option">
                        <input type="radio" name="q${index}_${subIndex}" value="${optIndex + 1}">
                        ${opt}
                      </label>
                    `,
                    )
                    .join("")}
                  </div>
                </div>
              </div>
            `,
              )
              .join("");
          }

          div.innerHTML = `
            <div class="reading-comprehension" data-index="${index}">
              <div class="reading-title">
                <span class="reading-label">ĐỌC HIỂU ${readingComprehensionCount}</span>
              </div>
              <div class="highlight-controls">
                <div class="highlight-btn red" onclick="highlightSelection(${index}, '#ff3333'); event.preventDefault();" title="Đỏ"></div>
                <div class="highlight-btn blue" onclick="highlightSelection(${index}, '#00a8ff'); event.preventDefault();" title="Xanh"></div>
                <div class="highlight-btn purple" onclick="highlightSelection(${index}, '#aa00ff'); event.preventDefault();" title="Tím"></div>
                <div class="highlight-btn black" onclick="highlightSelection(${index}, '#000000'); event.preventDefault();" title="Đen"></div>
                <div class="highlight-btn remove-btn" onclick="removeHighlights(${index}); event.preventDefault();" title="Xóa highlight"><i class="fas fa-times"></i></div>
              </div>
              <div class="reading-timer-container" data-timer-index="${index}">
                <input type="number" class="reading-timer-input" id="readTimeInput-${index}" placeholder="1" min="1" max="120" value="5">
                <button type="button" class="reading-timer-btn" onclick="setReadingTimer(${index}); event.preventDefault();"><i class="fas fa-clock"></i> Đặt</button>
                <button type="button" class="reading-timer-btn" onclick="startReadingTimer(${index}); event.preventDefault();"><i class="fas fa-play"></i></button>
                <button type="button" class="reading-timer-btn" onclick="resetReadingTimer(${index}); event.preventDefault();"><i class="fas fa-undo"></i></button>
                <span class="reading-timer-display" id="readingTimerDisplay-${index}">00:00</span>
              </div>
              <div class="reading-content">
                <p><strong>${q.question}</strong></p>
                ${q.content ? `<p>${q.content}</p>` : ``}
              </div>
              ${subQuestionsHtml}
            </div>
          `;
          // attach stars: sub-questions only (no star on the main reading passage)
          if (q.subQuestions) {
            q.subQuestions.forEach((subQ, subIndex) => {
              if (!window.quizAnswers) window.quizAnswers = {};
              window.quizAnswers[`q${index}_${subIndex}`] = subQ.answer;
            });
          }
        } else {
          div.innerHTML = `
            <div class="question-number"><span style="background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow)); color: #0a0e17; padding: 5px 12px; border-radius: 20px; font-size: 16px;">Câu ${q.number}</span></div>
            <p class="question-text">${q.question}</p>
          `;
          q.options.forEach((opt, i) => {
            const label = document.createElement("label");
            label.classList.add("answer-option");
            label.innerHTML = `<input type="radio" name="q${index}" value="${i + 1}"> ${opt}`;
            div.appendChild(label);
          });
          const detailBtn = document.createElement("button");
          detailBtn.classList.add("detail-btn");
          detailBtn.innerHTML =
            '<i class="fas fa-info-circle"></i> Xem chi tiết';
          detailBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showQuestionDetail(index);
          });
          div.appendChild(detailBtn);
          if (!window.quizAnswers) window.quizAnswers = {};
          window.quizAnswers[`q${index}`] = q.answer;
          // attach star for this simple question
          createStar(div, `q${index}`, q.question || '', q.number || (index+1).toString());
        }
        form.appendChild(div);
      });
    }

    // ==================== SIDEBAR TOGGLE ====================
    function toggleSidebar(side) {
      const panel = document.getElementById(`${side}SidebarPanel`);
      const floatingBtn = document.getElementById(`${side}FloatingBtn`);
      const wrapper = document.getElementById("mainContentWrapper");
      const isActive = panel.classList.contains("active");
      if (!isActive) {
        panel.classList.add("active");
        floatingBtn.classList.add("hidden");
        if (side === "left") wrapper.classList.add("left-expanded");
        else wrapper.classList.add("right-expanded");
      } else {
        panel.classList.remove("active");
        floatingBtn.classList.remove("hidden");
        if (side === "left") wrapper.classList.remove("left-expanded");
        else wrapper.classList.remove("right-expanded");
      }
      localStorage.setItem(`${side}SidebarActive`, !isActive);
    }

    function forceCloseSidebar(side) {
      const panel = document.getElementById(`${side}SidebarPanel`);
      const floatingBtn = document.getElementById(`${side}FloatingBtn`);
      const wrapper = document.getElementById("mainContentWrapper");
      panel.classList.remove("active");
      floatingBtn.classList.remove("hidden");
      if (side === "left") wrapper.classList.remove("left-expanded");
      else wrapper.classList.remove("right-expanded");
      localStorage.setItem(`${side}SidebarActive`, "false");
    }
    // ==================== FIREWORKS EFFECT ====================
    function launchFireworks() {
      // Tạo container nếu chưa có
      let container = document.querySelector(".fireworks-container");
      if (!container) {
        container = document.createElement("div");
        container.className = "fireworks-container";
        document.body.appendChild(container);
      }

      // Số lượng pháo hoa
      const particleCount = 150;

      for (let i = 0; i < particleCount; i++) {
        setTimeout(() => {
          createFireworkParticle(container);
        }, i * 20); // Mỗi hạt cách nhau 20ms
      }

      // Thêm confetti rơi
      for (let i = 0; i < 50; i++) {
        setTimeout(() => {
          createConfetti();
        }, i * 30);
      }

      // Tự động xóa container sau 5 giây
      setTimeout(() => {
        if (container) container.remove();
      }, 5000);
    }

    function createFireworkParticle(container) {
      const particle = document.createElement("div");
      particle.className = "firework-particle";

      // Màu sắc ngẫu nhiên rực rỡ
      const colors = [
        "#ff3333",
        "#ff9933",
        "#ffff33",
        "#33ff33",
        "#33ffff",
        "#3366ff",
        "#9933ff",
        "#ff33ff",
        "#ff0066",
        "#ff6600",
        "#ffcc00",
        "#00ffcc",
      ];
      const color = colors[Math.floor(Math.random() * colors.length)];
      particle.style.backgroundColor = color;
      particle.style.boxShadow = `0 0 15px ${color}`;

      // Vị trí trung tâm màn hình
      const x = window.innerWidth / 2 + (Math.random() - 0.5) * 300;
      const y = window.innerHeight / 2 + (Math.random() - 0.5) * 200;

      particle.style.left = x + "px";
      particle.style.top = y + "px";

      // Hướng bay ngẫu nhiên
      const tx = (Math.random() - 0.5) * 500;
      const ty = (Math.random() - 0.5) * 500;

      particle.style.setProperty("--tx", tx + "px");
      particle.style.setProperty("--ty", ty + "px");

      container.appendChild(particle);

      // Tự xóa sau khi animation kết thúc
      setTimeout(() => particle.remove(), 1500);
    }

    function createConfetti() {
      const confetti = document.createElement("div");
      confetti.className = "confetti";

      // Màu sắc ngẫu nhiên
      const colors = [
        "#f00",
        "#0f0",
        "#00f",
        "#ff0",
        "#f0f",
        "#0ff",
        "#ff8800",
      ];
      confetti.style.backgroundColor =
        colors[Math.floor(Math.random() * colors.length)];

      // Hình dạng ngẫu nhiên (vuông, tròn, chữ nhật)
      const shapes = ["50%", "0", "20%"];
      confetti.style.borderRadius =
        shapes[Math.floor(Math.random() * shapes.length)];

      // Vị trí ngẫu nhiên
      confetti.style.left = Math.random() * 100 + "%";

      // Kích thước ngẫu nhiên
      const size = 5 + Math.random() * 10;
      confetti.style.width = size + "px";
      confetti.style.height = size + "px";

      // Thời gian rơi ngẫu nhiên
      const duration = 3 + Math.random() * 4;
      confetti.style.animation = `confetti-fall ${duration}s linear forwards`;

      document.body.appendChild(confetti);

      // Tự xóa sau khi rơi xong
      setTimeout(() => confetti.remove(), duration * 1000);
    }

    // Thêm hiệu ứng âm thanh (tùy chọn)
    function playVictorySound() {
      try {
        const audioContext = new (
          window.AudioContext || window.webkitAudioContext
        )();

        // Tạo âm thanh đơn giản
        const osc = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        osc.type = "sine";
        osc.frequency.value = 523.25; // C5

        gainNode.gain.value = 0.1;
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 2,
        );

        osc.connect(gainNode);
        gainNode.connect(audioContext.destination);

        osc.start();
        osc.stop(audioContext.currentTime + 2);
      } catch (e) {
        console.log("Không thể phát âm thanh", e);
      }
    }

    // ==================== QUIZ FUNCTIONS ====================
    // placeholder definitions so submitQuiz can call them safely
    function pauseTimer() {
      // no-op; legacy stub for compatibility
    }
    function resetTimer() {
      // stub
    }

    function submitQuiz() {
      const form = document.getElementById("quizForm");
      let correctAnswers = 0;
      let totalQuestions = 0;

      quizData.forEach((q) => {
        if (q.isReading && q.subQuestions)
          totalQuestions += q.subQuestions.length;
        else totalQuestions++;
      });

      quizData.forEach((q, index) => {
        if (q.isReading && q.subQuestions) {
          q.subQuestions.forEach((subQ, subIndex) => {
            const name = `q${index}_${subIndex}`;
            const selected = form.querySelector(
              `input[name='${name}']:checked`,
            );
            const correct =
              (window.answers && window.answers[name]) ||
              (window.quizAnswers && window.quizAnswers[name]);
            if (selected && selected.value === String(correct)) {
              correctAnswers++;
              selected.parentElement.innerHTML +=
                ' <span class="correct-answer">✅ Đúng</span>';
            } else if (selected) {
              selected.parentElement.innerHTML +=
                ' <span class="wrong-answer">❌ Sai</span>';
              saveWrongAnswer(
                name,
                subQ.subQuestion,
                selected.value,
                correct,
              );
            }
          });
        } else {
          const name = `q${index}`;
          const selected = form.querySelector(
            `input[name='${name}']:checked`,
          );
          const correct =
            (window.answers && window.answers[name]) ||
            (window.quizAnswers && window.quizAnswers[name]);
          if (selected && selected.value === String(correct)) {
            correctAnswers++;
            selected.parentElement.innerHTML +=
              ' <span class="correct-answer">✅ Đúng</span>';
          } else if (selected) {
            selected.parentElement.innerHTML +=
              ' <span class="wrong-answer">❌ Sai</span>';
            saveWrongAnswer(name, q.question, selected.value, correct);
          }
        }
      });

      const percentage = Math.round((correctAnswers / totalQuestions) * 100);
      console.log("submitQuiz computed", correctAnswers, "/", totalQuestions, "=>", percentage, "%");
      saveQuizHistory(correctAnswers, percentage);
      document.getElementById("showAnswersBtn").style.display = "flex";
      form
        .querySelectorAll("input")
        .forEach((input) => (input.disabled = true));
      // safe call, avoid ReferenceError
      if (typeof pauseTimer === 'function') {
        pauseTimer();
      } else {
        console.warn('pauseTimer not defined');
      }

      // ===== HUD RESULT PANEL =====
      const _elapsed = Math.round((Date.now() - (window._quizStartTime || Date.now())) / 1000);
      if (typeof window.showHudResult === 'function') {
        window.showHudResult(correctAnswers, totalQuestions, _elapsed);
      }

      // Keep server notification for 100%
      if (percentage === 100) {
        tryMarkPerfect();
      }
    }

    function resetQuiz() {
      const form = document.getElementById("quizForm");
      if (form) form.reset();
      Object.values(readingTimers).forEach((obj) => {
        if (obj.intervalId) clearInterval(obj.intervalId);
      });
      renderQuiz();
      closeResultPopup();

      // XÓA HIỆU ỨNG 100 ĐIỂM (HUD panel, no old classes needed)
      const popup = document.getElementById("resultPopup");
      popup.classList.remove("perfect-score");
      // Reset start time for elapsed tracking
      window._quizStartTime = Date.now();

      document.getElementById("showAnswersBtn").style.display = "none";
      document.getElementById("showAnswersBtn").disabled = false;
      resetTimer();
    }

    function showCorrectAnswers() {
      quizData.forEach((q, idx) => {
        if (q.isReading && q.subQuestions) {
          q.subQuestions.forEach((subQ, subIdx) => {
            const name = `q${idx}_${subIdx}`;
            const correct =
              (window.answers && window.answers[name]) ||
              (window.quizAnswers && window.quizAnswers[name]);
            document
              .querySelectorAll(`input[name='${name}']`)
              .forEach((input) => {
                const label = input.parentElement;
                if (
                  input.value === correct &&
                  !label.innerHTML.includes("✅ Đáp án đúng")
                ) {
                  label.innerHTML +=
                    ' <span class="correct-answer">✅ Đáp án đúng</span>';
                }
              });
          });
        } else {
          const name = `q${idx}`;
          const correct =
            (window.answers && window.answers[name]) ||
            (window.quizAnswers && window.quizAnswers[name]);
          document
            .querySelectorAll(`input[name='${name}']`)
            .forEach((input) => {
              const label = input.parentElement;
              if (
                input.value === correct &&
                !label.innerHTML.includes("✅ Đáp án đúng")
              ) {
                label.innerHTML +=
                  ' <span class="correct-answer">✅ Đáp án đúng</span>';
              }
            });
        }
      });
      document.getElementById("showAnswersBtn").disabled = true;
    }
    let __scrollY = 0;

    function lockBodyScroll() {
      __scrollY = window.scrollY || document.documentElement.scrollTop || 0;

      // bù độ rộng scrollbar để khỏi “giật” layout
      const scrollbarWidth =
        window.innerWidth - document.documentElement.clientWidth;

      document.body.classList.add("modal-open");
      document.body.style.position = "fixed";
      document.body.style.top = `-${__scrollY}px`;
      document.body.style.left = "0";
      document.body.style.right = "0";
      document.body.style.width = "100%";
      document.body.style.paddingRight = scrollbarWidth
        ? `${scrollbarWidth}px`
        : "";
    }

    function unlockBodyScroll() {
      document.body.classList.remove("modal-open");
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.left = "";
      document.body.style.right = "";
      document.body.style.width = "";
      document.body.style.paddingRight = "";

      window.scrollTo(0, __scrollY);
    }

    function showQuestionDetail(index) {
      const question = quizData[index];
      const detailValue = question.detail || "Không có chi tiết bổ sung";

      // Tạo popup
      const detailPopup = document.createElement("div");
      detailPopup.className = "detail-popup";

      detailPopup.innerHTML = `
    <div class="detail-popup-inner">
      <div class="detail-popup-header">
        <h3 class="detail-popup-title">
          <i class="fas fa-info-circle"></i> GIẢI THÍCH
        </h3>
        <button class="detail-popup-close test-modal-close" type="button">
          Đóng
        </button>
      </div>

      <div class="detail-scroll">
        <p style="margin:0;">${detailValue}</p>
      </div>
    </div>
  `;

      // ===== HÀM ĐÓNG POPUP =====
      function closePopup() {
        // Xóa event listeners TRƯỚC KHI xóa popup để tránh lỗi
        document.removeEventListener("mousedown", handleClickOutside);
        document.removeEventListener("keydown", handleEsc);

        // Xóa popup khỏi DOM
        detailPopup.remove();

        // Restore scroll position
        unlockBodyScroll();
      }

      // ===== ĐÓNG BẰNG NÚT =====
      const closeBtn = detailPopup.querySelector(".detail-popup-close");
      closeBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        closePopup();
      });

      // ===== CLICK RA NGOÀI ĐỂ ĐÓNG (THÊM MỚI) =====
      function handleClickOutside(e) {
        // Kiểm tra nếu click vào phần tử không nằm trong popup
        if (!detailPopup.contains(e.target)) {
          e.stopPropagation();
          closePopup();
        }
      }

      // ===== NGĂN CLICK BÊN TRONG POPUP TRIGGER CLOSEMODAL =====
      detailPopup.addEventListener("mousedown", (e) => {
        e.stopPropagation();
      });

      // Thêm event listener cho toàn bộ document
      document.addEventListener("mousedown", handleClickOutside);

      // ===== ĐÓNG BẰNG ESC =====
      function handleEsc(e) {
        if (e.key === "Escape") {
          e.preventDefault();
          e.stopPropagation();
          closePopup();
        }
      }

      document.addEventListener("keydown", handleEsc);

      // ===== KHÓA SCROLL NGOÀI =====
      lockBodyScroll();

      // Thêm popup vào body
      document.body.appendChild(detailPopup);
    }

    function getResultComment(percentage) {
      if (percentage >= 90) return "🏆 素晴らしいいいい - Xuất sắc!";
      if (percentage >= 70) return "🌟 いいね！ - Khá tốt!";
      if (percentage >= 50) return "📚 いいよー - Cần cố gắng thêm!";
      return "💪 大丈夫、頑張れ！ - Đừng nản, cố lên!";
    }

    function saveQuizHistory(score, percentage) {
      const list = document.getElementById("quizHistory");
      if (!list) return;
      const time = new Date().toLocaleTimeString("vi-VN");
      const li = document.createElement("li");
      li.innerHTML = `<span><i class="fas fa-clock"></i> ${time}</span><span style="color: var(--secondary-glow);">${score}/${Object.keys(window.quizAnswers || {}).length} (${percentage}%)</span><button onclick="this.parentElement.remove()" style="background: none; border: none; color: #ff6b6b; cursor: pointer;">×</button>`;
      list.prepend(li);
    }

    function closeResultPopup() {
      document.getElementById("resultPopup").style.display = "none";
      document.getElementById("resultOverlay").style.display = "none";
      // Xóa class perfect-score nếu có
      document
        .getElementById("resultPopup")
        .classList.remove("perfect-score");
    }

    // ==================== WRONG ANSWERS ====================
    function saveWrongAnswer(
      questionKey,
      questionText,
      userAnswer,
      correctAnswer,
    ) {
      let wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      wrongAnswers.push({
        id: Date.now(),
        questionKey,
        questionText,
        userAnswer,
        correctAnswer,
        timestamp: new Date().toLocaleString("vi-VN"),
      });
      localStorage.setItem("wrongAnswers", JSON.stringify(wrongAnswers));
      updateWrongAnswersBadge();
      displayWrongAnswers();
    }

    function displayWrongAnswers() {
      const wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      const container = document.getElementById("wrongAnswersList");
      if (!container) return;
      if (wrongAnswers.length === 0) {
        container.innerHTML =
          '<p style="text-align: center; color: #999; padding: 20px;">🎉 Chưa có câu sai nào!</p>';
        return;
      }
      let html = "";
      wrongAnswers
        .sort((a, b) => b.timestamp.localeCompare(a.timestamp))
        .forEach((item, index) => {
          html += `
          <div class="wrong-answer-item">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <strong style="color: #ff3366;">#${index + 1}</strong>
              <button onclick="removeWrongAnswer(${item.id})" style="background: none; border: none; color: #ff3366; cursor: pointer; font-size: 16px;">✕</button>
            </div>
            <p style="margin-bottom: 8px; font-size: 14px;">${item.questionText}</p>
            <div style="display: flex; gap: 15px; font-size: 13px;">
              <span style="color: #ff6b6b;">❌ ${item.userAnswer}</span>
              <span style="color: #00ff88;">✅ ${item.correctAnswer}</span>
              <span style="color: #999;">${item.timestamp}</span>
            </div>
          </div>
        `;
        });
      container.innerHTML = html;
    }

    function updateWrongAnswersBadge() {
      const wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      const badge = document.getElementById("wrongAnswersBadge");
      if (badge) {
        badge.textContent = wrongAnswers.length;
        badge.style.display = wrongAnswers.length > 0 ? "flex" : "none";
      }
    }

    function showWrongAnswers() {
      displayWrongAnswers();
      const leftPanel = document.getElementById("leftSidebarPanel");
      const leftFloatingBtn = document.getElementById("leftFloatingBtn");
      const wrapper = document.getElementById("mainContentWrapper");
      if (!leftPanel.classList.contains("active")) {
        leftPanel.classList.add("active");
        leftFloatingBtn.classList.add("hidden");
        wrapper.classList.add("left-expanded");
        localStorage.setItem("leftSidebarActive", "true");
      }
    }

    function removeWrongAnswer(id) {
      let wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      wrongAnswers = wrongAnswers.filter((item) => item.id !== id);
      localStorage.setItem("wrongAnswers", JSON.stringify(wrongAnswers));
      displayWrongAnswers();
      updateWrongAnswersBadge();
    }

    function clearWrongAnswers() {
      if (confirm("Bạn có chắc muốn xóa tất cả lịch sử câu sai?")) {
        localStorage.removeItem("wrongAnswers");
        displayWrongAnswers();
        updateWrongAnswersBadge();
      }
    }

    function practiceWrongAnswers() {
      const wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      if (wrongAnswers.length === 0) {
        alert("🎉 Chưa có câu sai nào để luyện tập!");
        return;
      }
      alert("🚀 Chức năng luyện tập đang phát triển!");
    }

    // ==================== CẬP NHẬT ĐÁP ÁN - SỬA THEO YÊU CẦU ====================
    function findKeyBySubQNumber(number) {
      for (let i = 0; i < quizData.length; i++) {
        const q = quizData[i];
        if (!q.isReading) {
          if (q.number == number) return `q${i}`;
        } else if (q.subQuestions) {
          for (let j = 0; j < q.subQuestions.length; j++) {
            const subQ = q.subQuestions[j];
            if (subQ.number == number) return `q${i}_${j}`;
          }
        }
      }
      return null;
    }

    function updateAnswer() {
      let keyOrNumber = document.getElementById("editKey").value.trim();
      const value = document.getElementById("editValue").value.trim();

      if (!window.answers) window.answers = {};

      // Nếu nhập số, tự động dò key theo subQ.number
      if (/^\d+(\.\d+)?$/.test(keyOrNumber)) {
        const mappedKey = findKeyBySubQNumber(keyOrNumber);
        if (!mappedKey) {
          alert(`❌ Không tìm thấy câu hỏi số ${keyOrNumber}!`);
          return;
        }
        keyOrNumber = mappedKey;
      }

      if (keyOrNumber && value) {
        window.answers[keyOrNumber] = value;
        localStorage.setItem("customAnswers", JSON.stringify(window.answers));
        alert(
          `✅ Đáp án của ${keyOrNumber} đã được cập nhật thành ${value}.`,
        );
        document.getElementById("editKey").value = "";
        document.getElementById("editValue").value = "";
      } else {
        alert("❌ Vui lòng nhập đầy đủ thông tin!");
      }
    }

    function clearUpdatedAnswers() {
      const ok = confirm("Bạn có chắc muốn xóa cập nhật đáp án không?");
      if (!ok) return;
      localStorage.removeItem("customAnswers");
      window.answers = {};
      alert("✅ Đã xóa hết các cập nhật đáp án.");
    }

    /* Dark mode toggle functions removed */
    // ==================== BACK TO TOP ====================
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function updateBackToTopVisibility() {
      const btn = document.getElementById("backToTopBtn");
      if (!btn) return;
      if (window.scrollY > 300) btn.classList.add("show");
      else btn.classList.remove("show");
    }

    // ==================== INITIALIZATION ====================
    window.onload = function () {
      renderQuiz();
      if (typeof updateTimerDisplay === "function") updateTimerDisplay();
      displayWrongAnswers();
      updateWrongAnswersBadge();

      /* Dark mode feature removed; no persisted setting applied */

      const leftActive = localStorage.getItem("leftSidebarActive") === "true";
      const rightActive =
        localStorage.getItem("rightSidebarActive") === "true";
      const wrapper = document.getElementById("mainContentWrapper");

      if (leftActive) {
        document.getElementById("leftSidebarPanel").classList.add("active");
        document.getElementById("leftFloatingBtn").classList.add("hidden");
        wrapper.classList.add("left-expanded");
      }
      if (rightActive) {
        document.getElementById("rightSidebarPanel").classList.add("active");
        document.getElementById("rightFloatingBtn").classList.add("hidden");
        wrapper.classList.add("right-expanded");
      }
    };

    // Scroll handler
    window.addEventListener("scroll", function () {
      updateBackToTopVisibility();
    });

    // Event listeners
    document
      .getElementById("clearAnswersBtn")
      .addEventListener("click", clearUpdatedAnswers);
    // ==================== MAIN AUDIO PLAYER FUNCTIONS - GIỮ NGUYÊN TRẠNG THÁI BAN ĐẦU THEO EXCEL ====================
    let mainAudio = null;
    let isMainAudioPlaying = false;
    let previousVolume = 1; // Lưu volume trước khi mute
    let isSeeking = false; // Đang tua thì không cập nhật thanh trượt

    // Sử dụng multiple event listeners để đảm bảo DOM đã sẵn sàng
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOMContentLoaded - Đang khởi tạo audio player...");
        setTimeout(initAudioPlayer, 100);
      });
    } else {
      console.log("DOM đã sẵn sàng - Đang khởi tạo audio player...");
      setTimeout(initAudioPlayer, 100);
    }

    // Hàm khởi tạo chính
    function getHtmlSelectedOption(selectEl) {
      // Lấy option có ATTRIBUTE selected trong HTML (không phải property do browser restore)
      let opt = selectEl.querySelector("option[selected]");
      if (!opt) {
        // fallback an toàn: nếu không có, dùng option đang selectedIndex hoặc option đầu
        opt =
          selectEl.options[selectEl.selectedIndex] ||
          selectEl.options[0] ||
          null;
      }
      return opt;
    }

    function forceBackToHtmlDefault(selectEl) {
      const htmlSelected = getHtmlSelectedOption(selectEl);
      if (!htmlSelected) return null;

      // Ép select quay đúng về default theo HTML
      selectEl.value = htmlSelected.value;
      return htmlSelected;
    }

    function disableAudioControls(reasonText) {
      const btn = document.getElementById("mainPlayPauseBtn");
      const seekBar = document.getElementById("mainSeekBar");

      if (btn) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.cursor = "not-allowed";
        btn.title = reasonText ? reasonText : "Không có file audio hợp lệ";
      }

      if (seekBar) {
        seekBar.disabled = true;
        seekBar.style.opacity = "0.5";
        seekBar.style.cursor = "not-allowed";
      }

      if (mainAudio) {
        mainAudio.pause();
        isMainAudioPlaying = false;
        mainAudio.removeAttribute("src");
        while (mainAudio.firstChild)
          mainAudio.removeChild(mainAudio.firstChild);
        mainAudio.load();
      }
    }

    function loadFromHtmlSelectedOption() {
      const audioSelect = document.getElementById("mainAudioSelect");
      if (!audioSelect) return;

      // 1) MỖI LẦN LOAD: ép về option có attribute selected trong HTML
      const htmlSelected = forceBackToHtmlDefault(audioSelect);
      if (!htmlSelected) return;

      // 2) JS LUÔN LẤY option đang selected TRONG SELECT để load
      const opt = audioSelect.options[audioSelect.selectedIndex];
      const val = opt ? opt.value : "";

      if (val) {
        changeAudioFile(val);
      } else {
        // Trường hợp warning option (disabled + selected) hoặc option trống
        disableAudioControls(opt ? opt.textContent.trim() : "");
      }

      // 3) CHỈ restore tốc độ phát (được phép)
      restorePlaybackSpeed();
    }

    function initAudioPlayer() {
      initMainAudio();
      // ===== THÊM ĐOẠN NÀY ĐỂ ĐẢM BẢO VOLUME 50% =====
      const volumeSlider = document.getElementById("mainVolumeSlider");
      if (mainAudio && volumeSlider) {
        mainAudio.volume = 0.5;
        volumeSlider.value = 0.5;
        previousVolume = 0.5; // Cập nhật previousVolume
        updateVolumeIcon();
      }

      // Load mặc định ngay sau khi init
      loadFromHtmlSelectedOption();
    }

    // DOM ready
    document.addEventListener("DOMContentLoaded", initAudioPlayer);

    // BẮT BUỘC: xử lý back/forward cache + refresh kiểu restore form state
    window.addEventListener("pageshow", function () {
      loadFromHtmlSelectedOption();
    });

    // Hàm load audio mặc định từ selected option
    function loadDefaultAudio() {
      console.log("loadDefaultAudio được gọi");

      const audioSelect = document.getElementById("mainAudioSelect");
      if (!audioSelect) {
        console.error("Không tìm thấy mainAudioSelect");
        return;
      }

      // Log để debug
      console.log("Số lượng options:", audioSelect.options.length);
      for (let i = 0; i < audioSelect.options.length; i++) {
        console.log(
          `Option ${i}: value="${audioSelect.options[i].value}", selected=${audioSelect.options[i].selected}, text="${audioSelect.options[i].text}"`,
        );
      }

      // Lấy option đang được selected trong HTML (do Java code set)
      const selectedIndex = audioSelect.selectedIndex;
      console.log("selectedIndex:", selectedIndex);

      if (selectedIndex === -1) {
        console.log("Không có option nào được selected");
        return;
      }

      const selectedOption = audioSelect.options[selectedIndex];
      console.log("Selected option:", selectedOption);

      if (!selectedOption) {
        console.log("Không tìm thấy selected option");
        return;
      }

      const selectedValue = selectedOption.value;
      console.log("Selected value:", selectedValue);

      // KHÔNG lưu vào localStorage, chỉ dựa vào selected từ HTML
      if (selectedValue && selectedValue !== "") {
        // Có file được chọn (file Excel tồn tại)
        console.log("Load file mặc định từ Excel:", selectedValue);
        changeAudioFile(selectedValue);
      } else {
        // Không có giá trị (option thông báo đang được selected)
        console.log("File Excel không tồn tại, hiển thị thông báo");

        // Disable nút play
        const btn = document.getElementById("mainPlayPauseBtn");
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.cursor = "not-allowed";
          btn.title =
            "Không tìm thấy file audio từ Excel: " +
            (selectedOption.text || "").replace("⚠️ ", "");
        }

        // Disable thanh seek bar
        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.disabled = true;
          seekBar.style.opacity = "0.5";
          seekBar.style.cursor = "not-allowed";
        }

        // Reset audio element
        if (mainAudio) {
          mainAudio.pause();
          mainAudio.removeAttribute("src");
          while (mainAudio.firstChild) {
            mainAudio.removeChild(mainAudio.firstChild);
          }
          mainAudio.load();
        }
      }

      // Khôi phục tốc độ phát (giữ nguyên nếu muốn)
      restorePlaybackSpeed();
    }

    function initMainAudio() {
      mainAudio = document.getElementById("mainAudio");
      if (!mainAudio) {
        // Tạo element audio động nếu chưa có trong HTML
        mainAudio = document.createElement("audio");
        mainAudio.id = "mainAudio";
        mainAudio.preload = "auto";
        document.body.appendChild(mainAudio);
        console.log("Đã tạo element audio động.");
      }
      console.log("Đã tìm thấy mainAudio");
      mainAudio.volume = 0.5;  // 0.5 = 50%

      // Volume control
      const volumeSlider = document.getElementById("mainVolumeSlider");
      if (volumeSlider) {
        volumeSlider.value = 0.5;
        volumeSlider.addEventListener("input", function (e) {
          if (mainAudio) {
            const volume = parseFloat(e.target.value);
            mainAudio.volume = volume;
            mainAudio.muted = volume === 0;
            previousVolume = volume > 0 ? volume : previousVolume;
            updateVolumeIcon();
            console.log("Volume:", volume);
          }
        });
      }

      // Time update
      mainAudio.addEventListener("timeupdate", function () {
        if (!isSeeking) {
          updateSeekBar();
        }
        updateMainAudioTime();
        updateCurrentTime();
      });

      // Audio ended
      mainAudio.addEventListener("ended", function () {
        console.log("Audio kết thúc");
        isMainAudioPlaying = false;
        const btn = document.getElementById("mainPlayPauseBtn");
        if (btn) {
          btn.innerHTML = '<i class="fas fa-play"></i> Phát';
          btn.style.background = "linear-gradient(135deg, #00cc66, #00ff88)";
        }

        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.value = 0;
        }
      });

      // Load metadata
      mainAudio.addEventListener("loadedmetadata", function () {
        console.log("Đã tải metadata, duration:", mainAudio.duration);
        updateMainAudioTime();
        updateDuration();

        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.max = 100;
        }

        // Áp dụng tốc độ đã lưu
        const savedSpeed = localStorage.getItem("audioPlaybackSpeed");
        if (savedSpeed && mainAudio) {
          mainAudio.playbackRate = parseFloat(savedSpeed);
        }

        // Tự động phát lại nếu đang ở chế độ phát
        if (isMainAudioPlaying) {
          mainAudio
            .play()
            .catch((e) => console.log("Không thể tự động phát:", e));
        }
      });

      // Error handling
      mainAudio.addEventListener("error", function (e) {
        console.error("Lỗi audio:", e);
        showAudioError();
      });
    }

    // Hàm thay đổi file audio từ dropdown
    function changeAudioFile(fileName) {
      console.log("changeAudioFile được gọi với fileName:", fileName);

      if (!fileName || fileName === "") {
        console.log("fileName rỗng, disable controls");

        // Disable các controls
        const btn = document.getElementById("mainPlayPauseBtn");
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.cursor = "not-allowed";
          btn.title = "Vui lòng chọn file audio hợp lệ";
        }

        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.disabled = true;
          seekBar.style.opacity = "0.5";
          seekBar.style.cursor = "not-allowed";
        }

        // Dừng audio hiện tại
        if (mainAudio) {
          mainAudio.pause();
          isMainAudioPlaying = false;
        }

        return;
      }

      console.log("Chuyển sang file audio:", fileName);
      loadAudioFile(fileName);

      // Enable các controls
      const btn = document.getElementById("mainPlayPauseBtn");
      if (btn) {
        btn.disabled = false;
        btn.style.opacity = "1";
        btn.style.cursor = "pointer";
        btn.title = "";
      }

      const seekBar = document.getElementById("mainSeekBar");
      if (seekBar) {
        seekBar.disabled = false;
        seekBar.style.opacity = "1";
        seekBar.style.cursor = "pointer";
      }
    }

    // Hàm tải file audio
    function loadAudioFile(fileName) {
      if (!fileName) return;

      console.log("loadAudioFile:", fileName);

      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
        if (!mainAudio) {
          console.error("Không tìm thấy mainAudio trong loadAudioFile");
          return;
        }
      }

      // Dừng audio hiện tại
      mainAudio.pause();
      isMainAudioPlaying = false;

      // Cập nhật UI
      const btn = document.getElementById("mainPlayPauseBtn");
      if (btn) {
        btn.innerHTML = '<i class="fas fa-play"></i> Phát';
        btn.style.background = "linear-gradient(135deg, #00cc66, #00ff88)";
      }

      // Tạo đường dẫn mới
      const audioPath = "audios/" + fileName;
      console.log("Đang tải audio:", audioPath);

      // Xóa các source cũ
      while (mainAudio.firstChild) {
        mainAudio.removeChild(mainAudio.firstChild);
      }

      // Thêm source mới
      const fileExt = fileName.split(".").pop().toLowerCase();
      let mimeType = "audio/mpeg";
      if (fileExt === "m4a") mimeType = "audio/mp4";
      else if (fileExt === "wav") mimeType = "audio/wav";
      else if (fileExt === "ogg") mimeType = "audio/ogg";

      const source = document.createElement("source");
      source.src = audioPath;
      source.type = mimeType;
      mainAudio.appendChild(source);

      // Load lại audio
      mainAudio.load();

      // Reset seek bar
      const seekBar = document.getElementById("mainSeekBar");
      if (seekBar) {
        seekBar.value = 0;
        seekBar.disabled = false;
      }

      // Reset thời gian hiển thị
      document.getElementById("mainCurrentTime").textContent = "00:00";
      document.getElementById("mainDuration").textContent = "00:00";
      document.getElementById("mainAudioTime").textContent = "00:00";
    }

    // Hàm khôi phục tốc độ phát
    function restorePlaybackSpeed() {
      const savedSpeed = localStorage.getItem("audioPlaybackSpeed");
      const speedSelect = document.getElementById("mainSpeedSelect");

      if (savedSpeed && speedSelect) {
        speedSelect.value = savedSpeed;
        console.log("Đã khôi phục tốc độ phát:", savedSpeed);

        if (mainAudio) {
          mainAudio.playbackRate = parseFloat(savedSpeed);
        }
      }
    }

    // Hàm thay đổi tốc độ phát
    function changePlaybackSpeed(speed) {
      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
      }

      if (mainAudio) {
        const speedValue = parseFloat(speed);
        mainAudio.playbackRate = speedValue;
        console.log("Tốc độ phát:", mainAudio.playbackRate);

        // Lưu tốc độ vào localStorage (chỉ lưu tốc độ, không lưu file)
        localStorage.setItem("audioPlaybackSpeed", speed);

        showSpeedNotification(speed);
      }
    }

    // Các hàm còn lại giữ nguyên...
    function showSpeedNotification(speed) {
      const oldNotif = document.getElementById("speedNotification");
      if (oldNotif) oldNotif.remove();

      const notif = document.createElement("div");
      notif.id = "speedNotification";
      notif.innerHTML = `⚡ Tốc độ: ${speed}x`;
      notif.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow));
        color: #0a0e17;
        padding: 10px 25px;
        border-radius: 30px;
        font-weight: bold;
        z-index: 100000;
        animation: speedFade 2s forwards;
        box-shadow: 0 0 20px rgba(0,255,204,0.5);
        border: 2px solid white;
    `;

      const style = document.createElement("style");
      style.innerHTML = `
        @keyframes speedFade {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    `;
      document.head.appendChild(style);

      document.body.appendChild(notif);

      setTimeout(() => {
        if (notif) notif.remove();
        if (style) style.remove();
      }, 2000);
    }

    function updateVolumeIcon() {
      const icon = document.getElementById("mainVolumeIcon");
      if (!icon || !mainAudio) return;

      if (mainAudio.muted || mainAudio.volume === 0) {
        icon.className = "fas fa-volume-mute";
      } else if (mainAudio.volume < 0.5) {
        icon.className = "fas fa-volume-down";
      } else {
        icon.className = "fas fa-volume-up";
      }
    }

    function toggleMute(event) {
      if (event) {
        event.stopPropagation();
      }

      console.log("toggleMute được gọi");

      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
        if (!mainAudio) {
          alert("Không tìm thấy audio!");
          return;
        }
      }

      const icon = document.getElementById("mainVolumeIcon");
      const volumeSlider = document.getElementById("mainVolumeSlider");

      if (!icon || !volumeSlider) return;

      if (mainAudio.muted) {
        mainAudio.muted = false;
        mainAudio.volume = previousVolume;
        volumeSlider.value = previousVolume;
      } else {
        previousVolume = mainAudio.volume > 0 ? mainAudio.volume : 1;
        mainAudio.muted = true;
        volumeSlider.value = 0;
      }

      updateVolumeIcon();
      console.log("Mute state:", mainAudio.muted);
    }

    function toggleMainAudio() {
      console.log("toggleMainAudio được gọi");

      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
        if (!mainAudio) {
          alert("Không tìm thấy audio! Vui lòng load lại trang.");
          return;
        }
      }

      const btn = document.getElementById("mainPlayPauseBtn");
      if (!btn) return;

      if (isMainAudioPlaying) {
        mainAudio.pause();
        btn.innerHTML = '<i class="fas fa-play"></i> Phát';
        btn.style.background = "linear-gradient(135deg, #00cc66, #00ff88)";
        isMainAudioPlaying = false;
        console.log("Đã tạm dừng audio");
      } else {
        console.log("Đang thử phát audio...");

        // Kiểm tra xem có source không
        if (!mainAudio.querySelector("source") && !mainAudio.src) {
          // Nếu không có source, lấy từ dropdown hiện tại
          const audioSelect = document.getElementById("mainAudioSelect");
          if (audioSelect && audioSelect.value) {
            loadAudioFile(audioSelect.value);
          } else {
            alert("Không có file audio nào được chọn!");
            return;
          }
        }

        var playPromise = mainAudio.play();

        if (playPromise !== undefined) {
          playPromise
            .then(function () {
              console.log("Play audio thành công!");
              btn.innerHTML = '<i class="fas fa-pause"></i> Dừng';
              btn.style.background =
                "linear-gradient(135deg, #ff3333, #ff6600)";
              isMainAudioPlaying = true;
              updateDuration();

              const savedSpeed = localStorage.getItem("audioPlaybackSpeed");
              if (
                savedSpeed &&
                mainAudio.playbackRate !== parseFloat(savedSpeed)
              ) {
                mainAudio.playbackRate = parseFloat(savedSpeed);
              }
            })
            .catch(function (error) {
              console.error("Lỗi khi play audio:", error);

              if (error.name === "NotAllowedError") {
                alert(
                  "Trình duyệt chặn phát audio. Vui lòng nhấn nút Phát lại!",
                );
              } else if (error.name === "NotSupportedError") {
                alert("Định dạng audio không được hỗ trợ!");
              } else {
                alert("Không thể phát audio. Lỗi: " + error.message);
              }

              btn.innerHTML = '<i class="fas fa-play"></i> Phát lại';
              btn.style.background =
                "linear-gradient(135deg, #00cc66, #00ff88)";
            });
        }
      }
    }

    function updateMainAudioTime() {
      const timeSpan = document.getElementById("mainAudioTime");
      if (!timeSpan || !mainAudio) return;

      const remaining = Math.max(
        0,
        (mainAudio.duration || 0) - (mainAudio.currentTime || 0),
      );
      const remainingFormatted = formatTime(remaining);
      timeSpan.textContent = remainingFormatted;
    }

    function formatTime(seconds) {
      if (isNaN(seconds) || seconds === Infinity || seconds <= 0)
        return "00:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
    }

    function updateDuration() {
      const durationSpan = document.getElementById("mainDuration");
      if (durationSpan && mainAudio) {
        durationSpan.textContent = formatTime(mainAudio.duration || 0);
      }
    }

    function updateCurrentTime() {
      const currentSpan = document.getElementById("mainCurrentTime");
      if (currentSpan && mainAudio) {
        currentSpan.textContent = formatTime(mainAudio.currentTime || 0);
      }
    }

    function updateSeekBar() {
      const seekBar = document.getElementById("mainSeekBar");
      if (seekBar && mainAudio && mainAudio.duration && !seekBar.disabled) {
        const percent = (mainAudio.currentTime / mainAudio.duration) * 100;
        seekBar.value = percent;
      }
    }

    function seekAudio(value) {
      if (!mainAudio || !mainAudio.duration) return;

      isSeeking = true;
      const seekTime = (value / 100) * mainAudio.duration;
      mainAudio.currentTime = seekTime;

      updateCurrentTime();

      setTimeout(() => {
        isSeeking = false;
      }, 100);
    }

    function showAudioError() {
      const btn = document.getElementById("mainPlayPauseBtn");
      if (btn) {
        btn.innerHTML =
          '<i class="fas fa-exclamation-triangle"></i> Lỗi file';
        btn.style.background = "linear-gradient(135deg, #ff3333, #ff6600)";
      }
    }

    // Hàm reset tốc độ về mặc định (1x)
    function resetPlaybackSpeed() {
      const defaultSpeed = "1";

      localStorage.removeItem("audioPlaybackSpeed");

      const speedSelect = document.getElementById("mainSpeedSelect");
      if (speedSelect) {
        speedSelect.value = defaultSpeed;
      }

      if (mainAudio) {
        mainAudio.playbackRate = 1;
      }

      showSpeedNotification(defaultSpeed);
      console.log("Đã reset tốc độ về 1x");
    }

  </script>
  <!-- SCRIPT LOADING -->
  <script>
    let __loadingTimer = null;
    let __loadingPct = 0;

    // Khởi chạy progress bar ngay lập tức (loading đã hiển thị sẵn qua CSS)
    ; (function () {
      const pctEl = document.getElementById("cyberLoadingPercent");
      const bar = document.querySelector(".cyber-loading-bar-fill");
      const textEl = document.getElementById("cyberLoadingText");
      if (textEl) textEl.textContent = "ĐANG TẢI BÀI TEST";
      __loadingPct = 0;
      if (__loadingTimer) clearInterval(__loadingTimer);
      __loadingTimer = setInterval(() => {
        const step = __loadingPct < 50 ? 3 : __loadingPct < 80 ? 2 : 1;
        __loadingPct = Math.min(90, __loadingPct + step);
        if (pctEl) pctEl.textContent = __loadingPct + "%";
        if (bar) bar.style.width = __loadingPct + "%";
      }, 120);
    })();

    function showCyberLoading(text) {
      text = text || "ĐANG TẢI DỮ LIỆU";
      const loading = document.getElementById("cyberLoading");
      const textEl = document.getElementById("cyberLoadingText");
      const pctEl = document.getElementById("cyberLoadingPercent");
      const bar = document.querySelector(".cyber-loading-bar-fill");

      // Nếu đang hiển thị rồi thì chỉ đổi text, không reset %
      if (!loading.classList.contains("hide")) {
        if (textEl) textEl.textContent = text;
        return;
      }

      if (textEl) textEl.textContent = text;
      __loadingPct = 0;
      if (pctEl) pctEl.textContent = "0%";
      if (bar) bar.style.width = "0%";

      loading.classList.remove("hide");

      if (__loadingTimer) clearInterval(__loadingTimer);
      __loadingTimer = setInterval(() => {
        const step = __loadingPct < 50 ? 3 : __loadingPct < 80 ? 2 : 1;
        __loadingPct = Math.min(90, __loadingPct + step);
        if (pctEl) pctEl.textContent = __loadingPct + "%";
        if (bar) bar.style.width = __loadingPct + "%";
      }, 120);
    }

    function hideCyberLoading() {
      const loading = document.getElementById("cyberLoading");
      const pctEl = document.getElementById("cyberLoadingPercent");
      const bar = document.querySelector(".cyber-loading-bar-fill");

      if (__loadingTimer) clearInterval(__loadingTimer);
      __loadingTimer = null;

      __loadingPct = 100;
      if (pctEl) pctEl.textContent = "100%";
      if (bar) bar.style.width = "100%";

      // Giữ 1 nhịp để người dùng thấy 100% rồi mới tắt
      setTimeout(() => {
        loading.classList.add("hide");
      }, 180);
    }

    // Ẩn khi trang load xong
    window.addEventListener('load', function () {
      hideCyberLoading();
    });

    // Fallback: ẩn sau 5 giây
    setTimeout(function () {
      hideCyberLoading();
    }, 5000);
  </script>

  <!-- CSS CYBER LOADING BOX/BAR (phần overlay đã được chuyển lên head) -->
  <style>
    /* ================= CYBER LOADING BOX/BAR ================= */
    .cyber-loading-box {
      width: 420px;
      padding: 30px;
      border: 2px solid #00a8ff;
      border-radius: 14px;
      background: rgba(0, 20, 40, 0.95);
      text-align: center;
      box-shadow:
        0 0 25px rgba(0, 168, 255, 0.7),
        0 0 60px rgba(0, 100, 255, 0.4);
      animation: cyberGlow 3s infinite alternate;
    }

    @keyframes cyberGlow {
      0% {
        box-shadow: 0 0 20px rgba(0, 168, 255, 0.6);
      }

      100% {
        box-shadow: 0 0 50px rgba(0, 255, 204, 0.8);
      }
    }

    .cyber-loading-title {
      font-family: "Orbitron", sans-serif;
      font-size: 20px;
      letter-spacing: 2px;
      color: #00ffcc;
      margin-bottom: 20px;
      text-shadow: 0 0 15px rgba(0, 255, 204, 0.8);
      animation: cyberTextPulse 2.5s infinite alternate;
    }

    @keyframes cyberTextPulse {
      0% {
        opacity: 0.6;
      }

      100% {
        opacity: 1;
      }
    }

    .cyber-loading-bar {
      height: 8px;
      background: rgba(0, 50, 100, 0.4);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .cyber-loading-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #0066cc, #00ffcc);
      transition: width 120ms linear;
      /* chạy mượt theo % */
    }

    .cyber-loading-sub {
      font-size: 12px;
      color: #88d3ff;
      letter-spacing: 1px;
    }
  </style>
  <script>
// ════════════════════════════════════════════════════════════════════════════
// ⚡ CYBERPUNK QUIZ — CPU OPTIMIZER v2.0
// Tắt animation khi không nhìn thấy → tiết kiệm CPU, pin, nhiệt máy
//
// Chiến lược tổng thể:
//   1. IntersectionObserver  → pause CSS animation toàn bộ header khi scroll qua
//   2. Page Visibility API   → pause mọi thứ khi chuyển tab / minimize
//   3. Scroll depth          → tắt hẳn bg scanline khi scroll > 50% trang
//   4. Mobile detection      → giảm animation phức tạp từ đầu trên thiết bị yếu
//   5. Interval management   → expose hooks để pause readingTimers khi tab ẩn
//   6. Cleanup / unload      → dọn observer + RAF khi rời trang
// ════════════════════════════════════════════════════════════════════════════
(function () {
  'use strict';

  // ─── Utilities ────────────────────────────────────────────────────────────
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel, root) => (root || document).querySelectorAll(sel);

  /** Pause mọi CSS animation của element và tất cả con cháu */
  function pauseTree(el) {
    if (!el) return;
    el.style.animationPlayState = 'paused';
    $$('>*', el).forEach(child => {
      child.style.animationPlayState = 'paused';
    });
    $('*', el) && $$('*', el).forEach(desc => {
      desc.style.animationPlayState = 'paused';
    });
  }

  /** Resume: xoá inline animationPlayState để trả về trạng thái CSS gốc */
  function resumeTree(el) {
    if (!el) return;
    el.style.animationPlayState = '';
    $$('*', el).forEach(desc => {
      desc.style.animationPlayState = '';
    });
  }

  /**
   * Toggle .pause-animations trên element.
   * CSS rule đã có sẵn trong file:
   *   .pause-animations *, ::before, ::after { animation: none !important }
   * Phù hợp với các element có pseudo-element (cyber-line::before)
   */
  function setClassPause(el, pause) {
    if (!el) return;
    el.classList.toggle('pause-animations', !!pause);
  }

  // ─── 1. MOBILE DETECTION — Giảm animation ngay từ đầu ────────────────────
  const isMobile = /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent)
    || ('ontouchstart' in window && window.innerWidth < 1024);
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const isLowEndDevice = isMobile || prefersReducedMotion
    || (navigator.hardwareConcurrency != null && navigator.hardwareConcurrency <= 2);

  if (isLowEndDevice) {
    const mobileCSS = document.createElement('style');
    mobileCSS.id = 'cpu-mobile-reduce';
    mobileCSS.textContent = `
      /* ── Mobile / Low-end: tắt animation trang trí nặng ── */

      /* Glitch effect (cực nặng vì dùng clip-path liên tục) */
      .hq-main-title::before,
      .hq-main-title::after       { animation: none !important; display: none !important; }

      /* Scanline overlay trên title */
      .hq-main-title-scanline     { animation: none !important; opacity: 0 !important; }

      /* Ticker chạy chậm hơn 2x → ít paint */
      .hq-ticker-inner            { animation-duration: 44s !important; }

      /* Gradient flow + glow breathe trên title text */
      .hq-main-title              { animation: none !important;
                                    background: var(--primary-glow) !important;
                                    -webkit-background-clip: text !important; }

      /* Dot blink trên status bar */
      .hq-status-dot.green,
      .hq-status-dot.cyan,
      .hq-status-dot.orange       { animation: none !important; }

      /* Ghost clock ring pulse */
      .g-ring-outer               { animation: none !important; }

      /* HUD ring pulse */
      .hud-ring-outer             { animation: none !important; }

      /* Dock scale pulse khi hover bến */
      .dock-circle                { animation: none !important; }

      /* Scanline bg: ẩn trên mobile, không cần */
      .cyber-line                 { display: none !important; }
    `;
    document.head.appendChild(mobileCSS);
    if (window.__cpuDebug) console.log('[CPU] Mobile/low-end → reduced animations applied');
  }

  // ─── State chung ──────────────────────────────────────────────────────────
  let headerVisible    = true;   // Là header đang trong viewport không?
  let tabVisible       = true;   // Tab đang được focus không?
  let deepScrolled     = false;  // Đã scroll > 50% trang chưa?
  const allObservers   = [];     // Để disconnect khi unload

  // ─── Element references (collect sau DOMContentLoaded) ────────────────────
  let elTitleBlock, elTitleCard, elCyberLine, elGhostClock;

  function collectElements() {
    elTitleBlock = $('.hq-title-block');
    elTitleCard  = $('.hq-title-card');
    elCyberLine  = $('.cyber-line');
    elGhostClock = $('#ghostClock');
  }

  // ─── Apply state logic ────────────────────────────────────────────────────

  /**
   * Header zone (hq-title-block + hq-title-card):
   * Pause khi: không trong viewport HOẶC tab ẩn
   */
  function applyHeaderState() {
    const shouldPause = !headerVisible || !tabVisible;
    // Dùng class-based pause để cover cả ::before / ::after pseudo-elements
    setClassPause(elTitleBlock, shouldPause);
    setClassPause(elTitleCard,  shouldPause);
    if (window.__cpuDebug)
      console.log('[CPU] header', shouldPause ? '⏸ PAUSED' : '▶ RUNNING',
        { headerVisible, tabVisible });
  }

  /**
   * Background scanline (.cyber-line::before):
   * Pause khi: tab ẩn HOẶC user đã scroll > 50%
   * (cyber-grid không có animation, chỉ là static background-image → skip)
   */
  function applyBgState() {
    const shouldPause = !tabVisible || deepScrolled;
    setClassPause(elCyberLine, shouldPause);
    if (window.__cpuDebug)
      console.log('[CPU] bg scanline', shouldPause ? '⏸ PAUSED' : '▶ RUNNING',
        { tabVisible, deepScrolled });
  }

  /**
   * Ghost clock: là element fixed position, luôn hiển thị dù scroll.
   * Chỉ pause khi tab ẩn — không pause khi scroll.
   */
  function applyGhostState() {
    if (!elGhostClock) return;
    if (!tabVisible) {
      pauseTree(elGhostClock);
    } else {
      resumeTree(elGhostClock);
    }
    if (window.__cpuDebug)
      console.log('[CPU] ghost clock', !tabVisible ? '⏸ PAUSED' : '▶ RUNNING');
  }

  /**
   * readingTimers (setInterval trong quiz questions):
   * Không nên pause các timer này khi scroll vì chúng đếm thời gian thực.
   * Chỉ pause khi tab ẩn để không gây sai lệch timing.
   * Các timer này nằm trong object readingTimers ở scope ngoài — access qua window ref.
   */
  function applyReadingTimersState() {
    // readingTimers là const ở scope ngoài IIFE → không trực tiếp accessible
    // Dùng custom event để notify IIFE gốc
    const evt = new CustomEvent('cpuOptimizer:tabVisibility', { detail: { visible: tabVisible } });
    document.dispatchEvent(evt);
  }

  // ─── 2. INTERSECTIONOBSERVER — Header zone ────────────────────────────────
  function initHeaderObserver() {
    if (!window.IntersectionObserver) return; // Fallback: không support → luôn chạy

    // Quan sát hq-title-card (phần tử lớn nhất, chứa cả timer lẫn title)
    // Khi nó ra khỏi viewport → header không còn nhìn thấy
    const target = elTitleCard || elTitleBlock;
    if (!target) return;

    const io = new IntersectionObserver(
      (entries) => {
        // isIntersecting = false khi toàn bộ element đã cuộn ra khỏi màn hình
        headerVisible = entries[0].isIntersecting;
        applyHeaderState();
      },
      {
        threshold: 0,          // Trigger ngay khi bắt đầu ra/vào viewport
        rootMargin: '0px'      // Không buffer thêm
      }
    );

    io.observe(target);
    allObservers.push(io);
    if (window.__cpuDebug) console.log('[CPU] IntersectionObserver → observing', target.className);
  }

  // ─── 3. PAGE VISIBILITY API — Tab switch ──────────────────────────────────
  function initPageVisibility() {
    document.addEventListener('visibilitychange', () => {
      tabVisible = document.visibilityState === 'visible';
      applyHeaderState();
      applyBgState();
      applyGhostState();
      applyReadingTimersState();
      if (window.__cpuDebug)
        console.log('[CPU] Page Visibility:', tabVisible ? 'VISIBLE' : 'HIDDEN');
    });
  }

  // ─── 4. SCROLL DEPTH — Tắt bg effects khi scroll sâu ─────────────────────
  let scrollRAF = null;

  function onScroll() {
    // Throttle bằng rAF để không chạy mỗi pixel
    if (scrollRAF) return;
    scrollRAF = requestAnimationFrame(() => {
      scrollRAF = null;

      const scrollY      = window.scrollY || window.pageYOffset;
      const maxScroll    = document.documentElement.scrollHeight - window.innerHeight;
      const scrollDepth  = maxScroll > 0 ? scrollY / maxScroll : 0;

      const wasDeep = deepScrolled;
      deepScrolled  = scrollDepth > 0.50; // Ngưỡng 50%

      // Chỉ update nếu state thay đổi (tránh re-paint không cần thiết)
      if (wasDeep !== deepScrolled) {
        applyBgState();
        if (window.__cpuDebug)
          console.log('[CPU] Scroll depth:', Math.round(scrollDepth * 100) + '%',
            deepScrolled ? '→ bg PAUSED' : '→ bg RESUMED');
      }
    });
  }

  window.addEventListener('scroll', onScroll, { passive: true });

  // ─── 5. CSS bổ sung cho pseudo-elements ──────────────────────────────────
  // .pause-animations đã xử lý ::before/::after của *children*, nhưng
  // cyber-line::before là pseudo của chính element được add class → cần rule riêng
  const extraCSS = document.createElement('style');
  extraCSS.id = 'cpu-optimizer-extra';
  extraCSS.textContent = `
    /* Pseudo-elements của chính element mang .pause-animations */
    .cyber-line.pause-animations::before,
    .cyber-line.pause-animations::after  { animation: none !important; }

    /* Đảm bảo ticker dừng đúng chỗ (không reset về đầu) */
    .hq-title-block.pause-animations .hq-ticker-inner,
    .hq-title-card.pause-animations  .hq-ticker-inner {
      animation-play-state: paused !important;
    }

    /* HUD ring pulse trong title card */
    .hq-title-card.pause-animations .hud-ring-outer,
    .hq-title-card.pause-animations .g-ring-outer     { animation: none !important; }

    /* Ghost clock: data attribute pause state */
    #ghostClock[data-paused="true"] *  { animation-play-state: paused !important; }
  `;
  document.head.appendChild(extraCSS);

  // ─── 6. CLEANUP — Dọn dẹp khi rời trang ─────────────────────────────────
  function cleanup() {
    // Disconnect tất cả IntersectionObservers
    allObservers.forEach(io => io.disconnect());
    allObservers.length = 0;

    // Cancel RAF scroll throttle nếu đang pending
    if (scrollRAF) {
      cancelAnimationFrame(scrollRAF);
      scrollRAF = null;
    }

    // Pause toàn bộ body animation để dọn sạch trước khi unload
    document.body.style.animationPlayState = 'paused';

    if (window.__cpuDebug) console.log('[CPU] Cleanup complete on page unload');
  }

  // pagehide đáng tin cậy hơn unload/beforeunload trên mobile
  window.addEventListener('pagehide', cleanup);
  // Fallback cho desktop
  window.addEventListener('beforeunload', cleanup);

  // ─── INIT ─────────────────────────────────────────────────────────────────
  function init() {
    collectElements();
    initHeaderObserver();
    initPageVisibility();

    // Trigger scroll check ngay lập tức
    // (phòng trường hợp trang load mà browser đã restore scroll position)
    onScroll();

    if (window.__cpuDebug) {
      console.log('[CPU] CPU Optimizer v2.0 initialized ✅');
      console.log('[CPU] Elements:', {
        titleBlock: !!elTitleBlock,
        titleCard:  !!elTitleCard,
        cyberLine:  !!elCyberLine,
        ghostClock: !!elGhostClock,
      });
      console.log('[CPU] Device:', isMobile ? 'Mobile' : 'Desktop',
        '| Low-end:', isLowEndDevice,
        '| Reduced motion:', prefersReducedMotion);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init(); // DOM đã ready (script ở cuối body)
  }

  // ─── EXPOSE để các script khác có thể query state ────────────────────────
  window.cpuOptimizer = {
    isTabVisible:   () => tabVisible,
    isHeaderVisible:() => headerVisible,
    isDeepScrolled: () => deepScrolled,
    isMobile:       isMobile,
    isLowEnd:       isLowEndDevice,
  };

})();
  </script>

  <!-- ===== HUD RESULT PANEL JS ===== -->
  <script>
    (function () {
      // ── Track quiz start time ──
      window._quizStartTime = Date.now();

      // Reset start time when resetQuiz is called (làm lại)
      const _origResetQuiz = window.resetQuiz;
      // We patch resetQuiz below after DOMContentLoaded

      // ── 7-segment helpers ──
      const W = 22, H = 38, T = 3, G = 2;
      const SEG_COORDS = {
        a: [[T + G, T / 2], [W - T - G, T / 2]],
        d: [[T + G, H - T / 2], [W - T - G, H - T / 2]],
        g: [[T + G, H / 2], [W - T - G, H / 2]],
        b: [[W - T / 2, T + G], [W - T / 2, H / 2 - G]],
        c: [[W - T / 2, H / 2 + G], [W - T / 2, H - T - G]],
        e: [[T / 2, H / 2 + G], [T / 2, H - T - G]],
        f: [[T / 2, T + G], [T / 2, H / 2 - G]],
      };
      const DIGIT_SEGS = {
        0: 'abcdef', 1: 'bc', 2: 'abdeg', 3: 'abcdg',
        4: 'bcfg', 5: 'acdfg', 6: 'acdefg', 7: 'abc',
        8: 'abcdefg', 9: 'abcdfg'
      };
      function drawDigit(svgEl, ch, onColor) {
        svgEl.innerHTML = '';
        const ON = onColor || '#ffc107';
        const OFF = 'rgba(255,193,7,0.07)';
        const segs = (ch === ' ' || ch === undefined) ? '' : (DIGIT_SEGS[ch] || '');
        'abcdefg'.split('').forEach(s => {
          const [p1, p2] = SEG_COORDS[s];
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', p1[0]); line.setAttribute('y1', p1[1]);
          line.setAttribute('x2', p2[0]); line.setAttribute('y2', p2[1]);
          const on = segs.includes(s);
          line.setAttribute('stroke', on ? ON : OFF);
          line.setAttribute('stroke-width', T);
          line.setAttribute('stroke-linecap', 'square');
          if (on) line.setAttribute('style', `filter:drop-shadow(0 0 3px ${ON})`);
          svgEl.appendChild(line);
        });
      }

      function setScoreDigits(val, onColor) {
        const s = String(Math.min(100, Math.max(0, val))).padStart(3, ' ');
        ['hudResDig0', 'hudResDig1', 'hudResDig2'].forEach((id, i) => {
          const el = document.getElementById(id);
          if (el) drawDigit(el, s[i].trim() === '' ? ' ' : s[i], onColor);
        });
      }

      // Animate digit counter from 0 → target
      function animateScore(target, onColor) {
        let start = null;
        function step(ts) {
          if (!start) start = ts;
          const p = Math.min((ts - start) / 1400, 1);
          const ease = p < 0.5 ? 2 * p * p : -1 + (4 - 2 * p) * p;
          setScoreDigits(Math.round(ease * target), onColor);
          if (p < 1) requestAnimationFrame(step);
          else setScoreDigits(target, onColor);
        }
        requestAnimationFrame(step);
      }

      // Draw tick marks
      function initTicks() {
        const svg = document.getElementById('hudResTicksSvg');
        if (!svg) return;
        const cx = 95, cy = 95;
        for (let i = 0; i < 60; i++) {
          const angle = (i / 60) * 2 * Math.PI - Math.PI / 2;
          const maj = i % 5 === 0;
          const r1 = maj ? 80 : 84, r2 = 90;
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', cx + r1 * Math.cos(angle));
          line.setAttribute('y1', cy + r1 * Math.sin(angle));
          line.setAttribute('x2', cx + r2 * Math.cos(angle));
          line.setAttribute('y2', cy + r2 * Math.sin(angle));
          line.setAttribute('stroke', maj ? 'rgba(0,229,255,0.65)' : 'rgba(0,229,255,0.2)');
          line.setAttribute('stroke-width', maj ? '2' : '1');
          svg.appendChild(line);
        }
      }

      // Fireworks
      let fwParticles = [], fwAnimId = null;
      function fwBurst(canvas, x, y) {
        const colors = ['#ffc107', '#ff6b35', '#00e5ff', '#ff2d55', '#00ff88', '#fff'];
        for (let i = 0; i < 40; i++) {
          const angle = (i / 40) * Math.PI * 2, speed = 1.5 + Math.random() * 3;
          fwParticles.push({
            x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
            life: 1, color: colors[~~(Math.random() * colors.length)], size: 1.5 + Math.random() * 2
          });
        }
      }
      function fwLoop(canvas, ctx, ts) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = fwParticles.length - 1; i >= 0; i--) {
          const p = fwParticles[i];
          p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life -= 0.015;
          if (p.life <= 0) { fwParticles.splice(i, 1); continue; }
          ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
          ctx.shadowColor = p.color; ctx.shadowBlur = 6;
          ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill();
        }
        ctx.globalAlpha = 1; ctx.shadowBlur = 0;
        fwAnimId = requestAnimationFrame(ts2 => fwLoop(canvas, ctx, ts2));
      }
      let fwBurstTimer = null, fwBurstIdx = 0;
      function startFireworks() {
        const canvas = document.getElementById('hudFwCanvas');
        if (!canvas) return;
        // Full-screen canvas
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        canvas.style.display = 'block';
        const ctx = canvas.getContext('2d');
        fwParticles = []; fwBurstIdx = 0;
        if (fwAnimId) cancelAnimationFrame(fwAnimId);
        fwAnimId = requestAnimationFrame(ts => fwLoop(canvas, ctx, ts));
        // Burst positions spread across full screen, concentrated around panel center
        const positions = () => {
          const cx = window.innerWidth / 2, cy = window.innerHeight / 2;
          const w = window.innerWidth, h = window.innerHeight;
          return [
            [cx - w * .25, cy - h * .15], [cx + w * .25, cy - h * .15],
            [cx - w * .3, cy + h * .1], [cx + w * .3, cy + h * .1],
            [cx, cy - h * .2], [cx - w * .15, cy],
            [cx + w * .15, cy]
          ];
        };
        fwBurstTimer = setInterval(() => {
          const pos = positions();
          fwBurst(canvas, pos[fwBurstIdx % pos.length][0], pos[fwBurstIdx % pos.length][1]);
          fwBurstIdx++;
        }, 500);
      }
      function stopFireworks() {
        if (fwBurstTimer) { clearInterval(fwBurstTimer); fwBurstTimer = null; }
        if (fwAnimId) { cancelAnimationFrame(fwAnimId); fwAnimId = null; }
        fwParticles = [];
        const canvas = document.getElementById('hudFwCanvas');
        if (canvas) {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          canvas.style.display = 'none';
        }
      }

      // Main show function — called from submitQuiz
      window.showHudResult = function (correctAnswers, totalQuestions, elapsedSeconds) {
        const percentage = Math.round((correctAnswers / totalQuestions) * 100);
        const wrongAnswers = totalQuestions - correctAnswers;

        // Determine color scheme
        let ringColor = 'cyan';   // default
        let barClass = '';
        let onColor = '#ffc107';
        if (percentage < 10) {
          ringColor = 'red-blink';
          barClass = 'red';
          onColor = '#ff2d55';
        } else if (percentage < 100) {
          ringColor = 'yellow';
          barClass = 'yellow';
          onColor = '#ffc107';
        }

        // Fill stats
        document.getElementById('hudResCorrect').textContent = correctAnswers + '/' + totalQuestions;
        document.getElementById('hudResWrong').textContent = wrongAnswers;
        const mm = String(Math.floor(elapsedSeconds / 60)).padStart(2, '0');
        const ss = String(elapsedSeconds % 60).padStart(2, '0');
        document.getElementById('hudResTime').textContent = mm + ':' + ss;

        // Ring color
        const ring = document.querySelector('.hud-res-ring-outer');
        ring.className = 'hud-res-ring-outer';
        if (ringColor !== 'cyan') ring.classList.add(ringColor);

        // Progress bar arc
        const bar = document.getElementById('hudResBar');
        bar.className = 'hud-res-bar';
        if (barClass) bar.classList.add(barClass);
        // Set final dashoffset (fill to percentage)
        const CIRC = 647;
        bar.style.strokeDashoffset = CIRC * (1 - percentage / 100);
        if (barClass === 'red') {
          bar.style.stroke = '#ff2d55';
          bar.style.filter = 'drop-shadow(0 0 5px #ff2d55)';
        } else if (barClass === 'yellow') {
          bar.style.stroke = '#ffc107';
          bar.style.filter = 'drop-shadow(0 0 5px #ffc107)';
        } else {
          bar.style.stroke = 'var(--hud-cyan)';
          bar.style.filter = 'drop-shadow(0 0 5px var(--hud-cyan))';
        }

        // PERFECT label
        const perfectEl = document.getElementById('hudResPerfect');
        if (percentage === 100) {
          perfectEl.style.display = 'block';
          startFireworks();
        } else {
          perfectEl.style.display = 'none';
          stopFireworks();
        }

        // Show panel
        document.getElementById('resultOverlay').style.display = 'block';
        document.getElementById('resultPopup').style.display = 'block';

        // Animate digits after short delay
        setTimeout(() => animateScore(percentage, onColor), 300);
      };

      // Patch closeResultPopup to also stop fireworks & reset start time
      const _origClose = window.closeResultPopup;
      window.closeResultPopup = function () {
        stopFireworks();
        if (_origClose) _origClose();
      };

      document.addEventListener('DOMContentLoaded', function () {
        initTicks();

        // Reset start time when quiz resets (làm lại)
        const origResetQuiz = window.resetQuiz;
        window.resetQuiz = function () {
          window._quizStartTime = Date.now();
          stopFireworks();
          if (origResetQuiz) origResetQuiz();
        };
      });

    })();
  </script>

</body>

</html>
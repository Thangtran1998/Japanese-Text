<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Từ vựng Mimikara Unit 2 (111-130) - Cyberpunk Quiz</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link
    href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;600&family=Share+Tech+Mono&display=swap"
    rel="stylesheet" />
  <style>
    /* ===== RESET & VARIABLES ===== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary-glow: #00a8ff;
      --secondary-glow: #00ffcc;
      --danger-glow: #ff3366;
      --warning-glow: #ff9900;
      --bg-primary: #0a0e17;
      --bg-secondary: rgba(0, 20, 40, 0.6);
      --bg-tertiary: rgba(0, 30, 60, 0.5);
      --border-glow: rgba(0, 150, 255, 0.3);
      --text-primary: #e0f7ff;
      --text-secondary: #a0c8e0;
      --transition-smooth: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      --sidebar-width: 320px;
      --sidebar-collapsed-width: 60px;
    }

    body {
      font-family: "Exo 2", sans-serif;
      background-color: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      background-image:
        radial-gradient(circle at 20% 30%,
          rgba(16, 64, 120, 0.15) 0%,
          transparent 20%),
        radial-gradient(circle at 80% 70%,
          rgba(0, 150, 200, 0.1) 0%,
          transparent 20%),
        linear-gradient(to bottom, #0a0e17, #0c1220);
      padding: 20px;
      max-width: 1600px;
      margin: auto;
      position: relative;
      z-index: 1;
    }

    /* ===== BACKGROUND EFFECTS ===== */
    .cyber-grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image:
        linear-gradient(rgba(0, 150, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 150, 255, 0.05) 1px, transparent 1px);
      background-size: 40px 40px;
      z-index: -1;
      opacity: 0.4;
    }

    .cyber-line {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .cyber-line::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 1px;
      background: linear-gradient(to right,
          transparent,
          #00ffcc,
          transparent);
      animation: scan 4s linear infinite;
    }

    @keyframes scan {
      0% {
        top: 0%;
      }

      100% {
        top: 100%;
      }
    }

    /* ===== FLOATING BUTTONS ===== */
    .floating-btn-container {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      gap: 15px;
      transition: var(--transition-smooth);
    }

    .floating-btn-container.left {
      left: 20px;
    }

    .floating-btn-container.right {
      right: 20px;
    }

    .floating-btn-container.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .floating-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: linear-gradient(135deg, #1a2a3a, #0f1a24);
      border: 2px solid var(--primary-glow);
      color: var(--primary-glow);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 0 20px rgba(0, 168, 255, 0.3);
      transition: var(--transition-smooth);
      position: relative;
    }

    .floating-btn:hover {
      transform: scale(1.1);
      border-color: var(--secondary-glow);
      color: var(--secondary-glow);
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.5);
    }

    .floating-btn .badge {
      position: absolute;
      top: -5px;
      right: -5px;
      background: linear-gradient(135deg, #ff3366, #ff0066);
      color: white;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      border: 2px solid var(--bg-primary);
    }

    .btn-tooltip {
      position: absolute;
      background: rgba(0, 20, 40, 0.95);
      color: var(--secondary-glow);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: var(--transition-smooth);
      border: 1px solid var(--border-glow);
      font-family: "Orbitron", sans-serif;
      font-weight: 500;
      backdrop-filter: blur(10px);
    }

    .floating-btn.left .btn-tooltip {
      left: 70px;
    }

    .floating-btn.right .btn-tooltip {
      right: 70px;
    }

    .floating-btn:hover .btn-tooltip {
      opacity: 1;
    }

    /* ===== SIDEBAR PANELS ===== */
    .sidebar-panel {
      position: fixed;
      top: 155px;
      bottom: 30px;
      width: var(--sidebar-width);
      background: rgba(0, 15, 30, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid var(--border-glow);
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
      z-index: 9998;
      transition: var(--transition-smooth);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      border-radius: 25px;
    }

    .sidebar-panel.left {
      left: 20px;
      transform: translateX(calc(var(--sidebar-collapsed-width) - var(--sidebar-width) - 20px));
      border-right: 2px solid var(--danger-glow);
    }

    .sidebar-panel.right {
      right: 20px;
      transform: translateX(calc(var(--sidebar-width) - var(--sidebar-collapsed-width) + 20px));
      border-left: 2px solid var(--primary-glow);
    }

    .sidebar-panel.left.active,
    .sidebar-panel.right.active {
      transform: translateX(0);
    }

    .sidebar-panel.left:not(.active) .sidebar-content,
    .sidebar-panel.right:not(.active) .sidebar-content {
      opacity: 0;
      visibility: hidden;
    }

    .sidebar-panel.left:not(.active) .sidebar-header,
    .sidebar-panel.right:not(.active) .sidebar-header {
      justify-content: center;
      padding: 20px 0;
      height: 100%;
      display: flex;
      align-items: center;
    }

    .sidebar-panel.left:not(.active) .sidebar-header h3 span,
    .sidebar-panel.right:not(.active) .sidebar-header h3 span {
      display: none;
    }

    .sidebar-panel.left:not(.active) .sidebar-header h3 i,
    .sidebar-panel.right:not(.active) .sidebar-header h3 i {
      margin: 0;
      font-size: 28px;
    }

    .sidebar-panel.left:not(.active) .sidebar-close,
    .sidebar-panel.right:not(.active) .sidebar-close {
      display: none;
    }

    .sidebar-toggle {
      position: absolute;
      width: 30px;
      height: 60px;
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      border: none;
      border-radius: 8px;
      color: #0a0e17;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      transition: var(--transition-smooth);
      z-index: 100;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      top: 50%;
      transform: translateY(-50%);
    }

    .sidebar-panel.left.active .sidebar-toggle {
      right: -15px;
      display: flex;
    }

    .sidebar-panel.right.active .sidebar-toggle {
      left: -15px;
      display: flex;
    }

    .sidebar-toggle:hover {
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px 25px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.3);
      transition: var(--transition-smooth);
    }

    .sidebar-header h3 {
      font-family: "Orbitron", sans-serif;
      color: var(--secondary-glow);
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0;
    }

    .sidebar-close {
      background: rgba(255, 50, 50, 0.2);
      border: 1px solid rgba(255, 50, 50, 0.5);
      color: #ff6666;
      width: 36px;
      height: 36px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s;
      font-family: Orbitron, sans-serif;
    }

    .sidebar-close:hover {
      background: rgba(255, 50, 50, 0.4);
      box-shadow: 0 0 10px rgba(255, 50, 50, 0.4);
      transform: translateY(-1px);
    }

    .sidebar-close i {
      font-size: 16px;
      /* Điều chỉnh kích thước icon nếu cần */
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
      transition: var(--transition-smooth);
    }

    /* ===== MAIN CONTENT WRAPPER ===== */
    .main-content-wrapper {
      margin-left: calc(var(--sidebar-collapsed-width) + 20px);
      margin-right: calc(var(--sidebar-collapsed-width) + 20px);
      transition: var(--transition-smooth);
      padding: 20px;
      margin-top: 20px;
    }

    .main-content-wrapper.left-expanded {
      margin-left: calc(var(--sidebar-width) + 40px);
    }

    .main-content-wrapper.right-expanded {
      margin-right: calc(var(--sidebar-width) + 40px);
    }

    .main-quiz-container {
      background: rgba(0, 20, 40, 0.6);
      border-radius: 16px;
      padding: 30px;
      border: 1px solid var(--border-glow);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }

    .main-quiz-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(to right,
          var(--primary-glow),
          var(--secondary-glow));
    }

    /* ===== QUIZ STYLES ===== */
    .question-block {
      background: var(--bg-tertiary);
      border-radius: 12px;
      padding: 25px;
      margin-bottom: 25px;
      border: 1px solid rgba(0, 150, 255, 0.2);
      transition: var(--transition-smooth);
      position: relative;
    }

    .question-block:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 30px rgba(0, 100, 255, 0.3);
      border-color: var(--primary-glow);
    }

    .question-number {
      font-size: 20px;
      font-weight: 700;
      color: var(--secondary-glow);
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .question-text {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .answer-option {
      display: block;
      margin-bottom: 12px;
      padding: 15px 20px;
      background: rgba(0, 40, 80, 0.4);
      border: 1px solid rgba(0, 150, 255, 0.2);
      border-radius: 10px;
      color: var(--text-primary);
      cursor: pointer;
      transition: var(--transition-smooth);
    }

    .answer-option:hover {
      background: rgba(0, 80, 160, 0.5);
      border-color: var(--primary-glow);
      transform: translateX(8px);
      box-shadow: 0 5px 15px rgba(0, 100, 255, 0.3);
    }

    .answer-option input[type="radio"] {
      margin-right: 15px;
      transform: scale(1.2);
      accent-color: var(--secondary-glow);
    }

    .detail-btn {
      padding: 12px 24px;
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      color: #0a0e17;
      border: none;
      border-radius: 8px;
      font-family: "Orbitron", sans-serif;
      font-weight: 600;
      cursor: pointer;
      margin-top: 15px;
      transition: var(--transition-smooth);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .detail-btn:hover {
      background: linear-gradient(135deg,
          var(--secondary-glow),
          var(--primary-glow));
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
      transform: translateY(-2px);
    }

    /* ===== READING COMPREHENSION ===== */
    .reading-comprehension {
      background: rgba(0, 30, 80, 0.6);
      border-left: 4px solid var(--secondary-glow);
      padding: 25px;
      border-radius: 12px;
      position: relative;
      margin-bottom: 20px;
      padding-top: 70px;
    }

    .reading-title {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.2);
      position: relative;
      z-index: 5;
    }

    .reading-timer-container {
      position: absolute;
      top: 15px;
      right: 25px;
      width: 350px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border-glow);
      border-radius: 30px;
      padding: 8px 15px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 20;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      transition: var(--transition-smooth);
    }

    .highlight-controls {
      position: absolute;
      top: 15px;
      right: 400px;
      display: flex;
      gap: 8px;
      background: rgba(0, 20, 40, 0.9);
      padding: 8px 15px;
      border-radius: 30px;
      border: 1px solid var(--border-glow);
      z-index: 20;
      backdrop-filter: blur(10px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      align-items: center;
      height: 46px;
      width: auto;
    }

    .highlight-btn {
      width: 30px;
      height: 30px;
      border-radius: 8px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .highlight-btn:hover {
      transform: scale(1.15);
      box-shadow: 0 0 15px currentColor;
      border-color: white;
    }

    .highlight-btn.red {
      background-color: #ff3333;
      color: white;
    }

    .highlight-btn.blue {
      background-color: #00a8ff;
      color: white;
    }

    .highlight-btn.purple {
      background-color: #aa00ff;
      color: white;
    }

    .highlight-btn.black {
      background-color: #000000;
      color: white;
      border-color: rgba(255, 255, 255, 0.5);
    }

    .highlight-btn.remove-btn {
      background: linear-gradient(135deg, #ff3333, #ff6600);
      color: white;
      font-size: 16px;
      font-weight: bold;
    }

    .reading-timer-input {
      width: 50px;
      height: 32px;
      background: rgba(0, 10, 25, 0.9);
      border: 1px solid rgba(0, 150, 255, 0.4);
      border-radius: 20px;
      color: var(--text-primary);
      text-align: center;
      font-size: 13px;
      padding: 0 8px;
      transition: var(--transition-smooth);
    }

    .reading-timer-input:focus {
      outline: none;
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    .reading-timer-btn {
      padding: 6px 14px;
      background: linear-gradient(135deg, #0066cc, var(--primary-glow));
      border: none;
      border-radius: 20px;
      color: white;
      font-size: 12px;
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      font-weight: 500;
      white-space: nowrap;
    }

    .reading-timer-btn i {
      font-size: 11px;
    }

    .reading-timer-btn:hover {
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 168, 255, 0.4);
    }

    .reading-timer-display {
      font-family: "Orbitron", sans-serif;
      font-size: 16px;
      font-weight: 700;
      color: var(--secondary-glow);
      padding: 0 8px;
      min-width: 60px;
      text-align: center;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 20px;
      padding: 4px 10px;
      border: 1px solid rgba(0, 255, 204, 0.3);
      letter-spacing: 1px;
    }

    .reading-label {
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      color: #0a0e17;
      padding: 5px 18px;
      border-radius: 30px;
      font-family: "Orbitron", sans-serif;
      font-weight: 700;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 15px rgba(0, 168, 255, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.3);
      position: relative;
      overflow: hidden;
      transition: var(--transition-smooth);
      animation: reading-pulse 3s infinite ease-in-out;
    }

    .reading-label::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent);
      transition: left 0.5s ease;
    }

    .reading-label:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
    }

    .reading-label:hover::before {
      left: 100%;
    }

    @keyframes reading-pulse {
      0% {
        box-shadow: 0 0 15px rgba(0, 168, 255, 0.3);
      }

      50% {
        box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
      }

      100% {
        box-shadow: 0 0 15px rgba(0, 168, 255, 0.3);
      }
    }

    .sub-question-container {
      margin: 25px 0 15px 25px;
      padding-left: 20px;
      border-left: 3px solid rgba(0, 150, 255, 0.3);
    }

    .sub-question-box {
      background: rgba(0, 40, 80, 0.4);
      border: 1px solid rgba(0, 150, 255, 0.2);
      border-radius: 10px;
      padding: 20px;
      margin-top: 15px;
    }

    .sub-question-box p {
      font-weight: 600;
      color: var(--secondary-glow);
      margin-bottom: 15px;
      font-size: 17px;
    }

    .sub-question-options {
      margin-top: 15px;
    }

    .sub-question-key {
      font-size: 12px;
      color: #888;
      margin-left: 10px;
      font-family: monospace;
    }

    /* ===== QUIZ HISTORY ===== */
    #quizHistory {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 15px;
    }

    #quizHistory li {
      background: rgba(0, 40, 80, 0.5);
      padding: 10px;
      margin-bottom: 8px;
      border-radius: 6px;
      border-left: 3px solid var(--primary-glow);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* ===== WRONG ANSWERS LIST ===== */
    .wrong-answers-list {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .wrong-answer-item {
      background: rgba(255, 51, 51, 0.1);
      border-left: 4px solid #ff3366;
      padding: 15px;
      border-radius: 8px;
      transition: var(--transition-smooth);
    }

    .wrong-answer-item:hover {
      background: rgba(255, 51, 51, 0.2);
      transform: translateX(5px);
    }

    /* ===== BUTTON STYLES ===== */
    .cyber-button {
      width: 100%;
      padding: 12px;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #0066cc, var(--primary-glow));
      color: white;
      border: none;
      border-radius: 10px;
      font-family: "Orbitron", sans-serif;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }

    .cyber-button::before {
      content: "";
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent);
      transition: left 0.5s;
    }

    .cyber-button:hover {
      background: linear-gradient(135deg,
          var(--primary-glow),
          var(--secondary-glow));
      transform: translateY(-2px);
      box-shadow: 0 0 20px rgba(0, 168, 255, 0.5);
    }

    .cyber-button:hover::before {
      left: 100%;
    }

    /* ===== DETAIL POPUP (GIẢI THÍCH) - NEW STYLE ===== */
    .detail-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(760px, 94vw);
      max-height: 82vh;
      overflow: hidden;

      background: rgba(0, 18, 36, 0.98);
      border: 3px solid rgba(0, 255, 204, 0.65);
      /* ✅ viền dày */
      border-radius: 18px;

      box-shadow:
        0 25px 60px rgba(0, 0, 0, 0.85),
        0 0 30px rgba(0, 255, 204, 0.18);
      backdrop-filter: blur(18px);

      z-index: 200000;
      animation: popup-appear 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .detail-popup::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      height: 5px;
      width: 100%;
      background: linear-gradient(90deg,
          var(--primary-glow),
          var(--secondary-glow));
      opacity: 0.9;
    }

    .detail-popup-inner {
      padding: 22px 22px 18px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .detail-popup-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.22);
    }

    .detail-popup-title {
      margin: 0;
      font-family: Orbitron, sans-serif;
      color: var(--secondary-glow);
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* ✅ Nút Đóng giống hệt style bạn đưa */
    .detail-popup-close.test-modal-close {
      background: rgba(255, 50, 50, 0.2);
      border: 1px solid rgba(255, 50, 50, 0.5);
      color: #ff6666;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.25s;
      font-size: 13px;
      font-family: Orbitron, sans-serif;
    }

    .detail-popup-close.test-modal-close:hover {
      background: rgba(255, 50, 50, 0.4);
      box-shadow: 0 0 10px rgba(255, 50, 50, 0.4);
      transform: translateY(-1px);
    }

    /* Nội dung cuộn */
    .detail-popup .detail-scroll {
      overflow-y: auto;
      max-height: calc(82vh - 120px);
      padding-right: 10px;
      line-height: 1.85;
      font-size: 16px;

      background: rgba(0, 0, 0, 0.18);
      border: 1px solid rgba(0, 255, 204, 0.18);
      border-radius: 12px;
      padding: 14px 14px;
    }

    /* Scrollbar đẹp (Chrome/Edge) */
    .detail-popup .detail-scroll::-webkit-scrollbar {
      width: 10px;
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 204, 0.35);
      border-radius: 10px;
      border: 2px solid rgba(0, 18, 36, 0.98);
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    }

    /* ===== DETAIL POPUP SCROLL ===== */
    .detail-popup .detail-scroll {
      overflow-y: auto;
      max-height: calc(80vh - 120px);
      /* trừ phần header + padding */
      padding-right: 10px;
      /* chừa chỗ cho scrollbar */
    }

    /* (Tuỳ chọn) làm scrollbar đẹp hơn trên Chrome/Edge */
    .detail-popup .detail-scroll::-webkit-scrollbar {
      width: 10px;
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 204, 0.35);
      border-radius: 10px;
      border: 2px solid rgba(0, 20, 40, 0.98);
    }

    .detail-popup .detail-scroll::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    }

    /* Dark mode toggle removed */

    /* ===== CORRECT / WRONG ANSWER STYLES ===== */
    .correct-answer {
      color: #2e7d32;
      font-weight: bold;
      margin-left: 8px;
    }

    .wrong-answer {
      color: #c62828;
      font-weight: bold;
      margin-left: 8px;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .sidebar-panel {
        width: 100%;
        left: 0 !important;
        right: 0 !important;
        top: 0 !important;
        bottom: 0 !important;
        border-radius: 0;
      }

      .main-content-wrapper {
        margin-left: 0 !important;
        margin-right: 0 !important;
      }

      .floating-btn-container {
        display: none;
      }

      .highlight-controls {
        position: relative;
        top: auto;
        right: auto;
        margin-top: 15px;
      }
    }

    @media (max-width: 900px) {
      .reading-timer-container {
        position: relative;
        top: auto;
        right: auto;
        width: 100%;
        margin-top: 15px;
        margin-bottom: 10px;
        border-radius: 15px;
      }

      .highlight-controls {
        position: relative;
        top: auto;
        right: auto;
        width: 100%;
        margin-top: 10px;
        margin-bottom: 15px;
        justify-content: center;
        height: auto;
      }

      .reading-comprehension {
        padding-top: 25px;
      }
    }

    /* ===== BACK TO TOP BUTTON ===== */
    #backToTopBtn {
      position: fixed;
      bottom: 30px;
      /* nằm phía trên nút dark mode để không đè nhau */
      left: 10px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(0, 20, 40, 0.95);
      border: 2px solid var(--secondary-glow);
      color: var(--secondary-glow);
      cursor: pointer;
      font-size: 22px;
      z-index: 10002;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 20px rgba(0, 255, 204, 0.25);
      backdrop-filter: blur(10px);
      transition: var(--transition-smooth);

      /* ẩn mặc định */
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transform: translateY(10px);
    }

    #backToTopBtn.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transform: translateY(0);
    }

    #backToTopBtn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 204, 0.45);
      border-color: var(--primary-glow);
      color: var(--primary-glow);
    }

    /* ===== FIREWORKS EFFECT ===== */
    .fireworks-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999999;
    }

    .firework-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      animation: firework-explode 1.5s ease-out forwards;
    }

    @keyframes firework-explode {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }

      100% {
        transform: translate(var(--tx), var(--ty)) scale(0.2);
        opacity: 0;
      }
    }

    /* Hiệu ứng confetti rơi (thay thế hoặc bổ sung) */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background-color: #f00;
      position: fixed;
      top: -10px;
      z-index: 999999;
      animation: confetti-fall linear forwards;
    }

    @keyframes confetti-fall {
      to {
        transform: translateY(100vh) rotate(720deg);
      }
    }

    @keyframes bounce {
      from {
        transform: translateX(-50%) translateY(0);
      }

      to {
        transform: translateX(-50%) translateY(-20px);
      }
    }

    /* Khóa scroll ngoài khi mở popup */
    body.modal-open {
      overflow: hidden;
    }

    /* (Tuỳ chọn) mượt hơn trên mobile */
    body.modal-open {
      touch-action: none;
    }

    /* ===== RESULT POPUP - GIỐNG DETAIL POPUP ===== */
    .result-popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(500px, 90vw);
      max-height: 82vh;
      overflow: hidden;

      background: rgba(0, 18, 36, 0.98);

      /* 2 ĐƯỜNG VIỀN */
      border: 6px solid #00ffcc;
      /* Viền ngoài dày */
      outline: 4px solid rgba(255, 102, 0, 0.3);
      /* Viền trong mờ */
      outline-offset: -10px;
      /* Điều chỉnh vị trí viền trong */

      border-radius: 24px;

      box-shadow:
        0 25px 60px rgba(0, 0, 0, 0.85),
        0 0 40px rgba(255, 102, 0, 0.5);
      backdrop-filter: blur(18px);

      z-index: 200000;
      animation: popup-appear 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .result-popup-inner {
      padding: 22px 22px 18px;
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .result-popup-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(0, 255, 204, 0.22);
    }

    .result-popup-title {
      margin: 0;
      font-family: Orbitron, sans-serif;
      color: var(--secondary-glow);
      font-size: 18px;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 10px;
      text-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    .result-popup-content {
      overflow-y: auto;
      max-height: calc(82vh - 120px);
      padding-right: 10px;

      background: transparent;
      /* KHÔNG tô màu đặc */
      border: 1px solid rgba(0, 255, 204, 0.18);
      border-radius: 12px;
      padding: 20px 20px;
      text-align: center;
    }

    /* Scrollbar đẹp cho result popup */
    .result-popup-content::-webkit-scrollbar {
      width: 10px;
    }

    .result-popup-content::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 204, 0.35);
      border-radius: 10px;
      border: 2px solid rgba(0, 18, 36, 0.98);
    }

    .result-popup-content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.25);
      border-radius: 10px;
    }

    /* Hiệu ứng đặc biệt cho điểm 100% */
    .result-popup.perfect-score {
      animation:
        popup-appear 0.3s,
        glow-pulse 1s infinite;
      border-color: gold;
      box-shadow: 0 0 80px gold;
    }

    @keyframes glow-pulse {

      0%,
      100% {
        box-shadow: 0 0 50px gold;
      }

      50% {
        box-shadow: 0 0 100px #ffaa00;
      }
    }

    /* Trophy icon styling */
    .result-popup .fa-trophy {
      font-size: 50px;
      color: #ffd700;
      margin-bottom: 15px;
      filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.5));
    }

    /* Score styling */
    #popupScore {
      font-size: 56px;
      font-weight: 900;
      font-family: "Orbitron", sans-serif;
      color: var(--secondary-glow);
      text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
      margin: 15px 0;
      letter-spacing: 2px;
    }

    /* Comment styling */
    #popupComment {
      font-size: 20px;
      color: var(--text-primary);
      padding: 15px 20px;
      background: linear-gradient(135deg,
          rgba(0, 150, 255, 0.1),
          rgba(0, 255, 204, 0.1));
      border-radius: 50px;
      display: inline-block;
      border: 1px solid rgba(0, 255, 204, 0.3);
    }

    /* Hiệu ứng đặc biệt cho điểm 100% */
    .result-popup.perfect-score {
      animation:
        popup-appear 0.3s,
        glow-pulse 1s infinite;
      border-color: gold;
      box-shadow: 0 0 80px gold;
    }

    @keyframes glow-pulse {

      0%,
      100% {
        box-shadow: 0 0 50px gold;
      }

      50% {
        box-shadow: 0 0 100px #ffaa00;
      }
    }

    /* ===== TIME UP ALERT - CŨNG CẦN THÊM ===== */
    .time-up-alert {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #d32f2f, #b71c1c);
      color: white;
      padding: 30px 50px;
      border-radius: 20px;
      font-size: 28px;
      font-weight: bold;
      z-index: 200000;
      box-shadow: 0 0 50px rgba(211, 47, 47, 0.5);
      border: 2px solid #ff8a80;
      text-align: center;
      animation: popup-appear 0.3s;
    }

    /* Overlay làm tối màn hình */
    .result-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      /* Độ tối 70% */
      backdrop-filter: blur(5px);
      /* Hiệu ứng mờ (tùy chọn) */
      z-index: 199999;
      /* Thấp hơn popup một chút */
      display: none;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* ===== MAIN AUDIO PLAYER STYLES ===== */
    #mainAudioSelect {
      outline: none;
      transition: var(--transition-smooth);
    }

    #mainAudioSelect:hover {
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    #mainAudioSelect option {
      background: #0a0e17;
      color: var(--text-primary);
    }

    #mainPlayPauseBtn {
      background: linear-gradient(135deg, #00cc66, #00ff88);
      border: none;
      border-radius: 5px;
      color: #0a0e17;
      padding: 8px 15px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: var(--transition-smooth);
    }

    #mainPlayPauseBtn:hover {
      background: linear-gradient(135deg, #00ff88, var(--secondary-glow));
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
    }

    #mainPlayPauseBtn.playing {
      background: linear-gradient(135deg, #ff3333, #ff6600);
    }

    #mainVolumeSlider {
      -webkit-appearance: none;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      height: 4px;
      background: linear-gradient(90deg,
          var(--primary-glow),
          var(--secondary-glow));
      border-radius: 2px;
      outline: none;
    }

    #mainVolumeSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--secondary-glow);
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 0 10px var(--secondary-glow);
    }

    /* Responsive */
    @media (max-width: 900px) {
      .main-quiz-container>div:first-child {
        flex-direction: column;
        gap: 15px;
      }

      .main-quiz-container>div:first-child>div {
        width: 100%;
        flex-wrap: wrap;
      }

      #mainAudioSelect {
        min-width: 150px;
      }
    }

    /* ===== CUSTOM SEEK BAR STYLES ===== */
    #mainSeekBar {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: linear-gradient(90deg,
          var(--primary-glow),
          var(--secondary-glow));
      border-radius: 3px;
      outline: none;
    }

    #mainSeekBar::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 2px solid var(--secondary-glow);
      box-shadow: 0 0 10px var(--secondary-glow);
      transition: all 0.2s;
    }

    #mainSeekBar::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px var(--secondary-glow);
    }

    #mainSeekBar::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 2px solid var(--secondary-glow);
      box-shadow: 0 0 10px var(--secondary-glow);
      transition: all 0.2s;
    }

    #mainSeekBar::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px var(--secondary-glow);
    }

    /* Speed select styling */
    #mainSpeedSelect {
      background: rgba(0, 10, 25, 0.9);
      color: var(--text-primary);
      border: 1px solid rgba(0, 150, 255, 0.4);
      border-radius: 5px;
      padding: 5px;
      cursor: pointer;
      outline: none;
      transition: all 0.3s;
    }

    #mainSpeedSelect:hover {
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    #mainSpeedSelect option {
      background: #0a0e17;
      color: var(--text-primary);
    }

    /* ===== CUSTOM DROPDOWN STYLES ===== */
    #mainAudioSelect {
      background: rgba(0, 10, 25, 0.9);
      color: var(--text-primary);
      border: 1px solid rgba(0, 150, 255, 0.6);
      border-radius: 5px;
      padding: 8px 15px;
      min-width: 250px;
      cursor: pointer;
      outline: none;
      font-family: monospace;
      transition: all 0.3s;
    }

    #mainAudioSelect:hover {
      border-color: var(--secondary-glow);
      box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
    }

    #mainAudioSelect option {
      background: #0a0e17;
      color: var(--text-primary);
      padding: 10px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      #mainAudioSelect {
        min-width: 100%;
        margin-bottom: 10px;
      }
    }

    /* Style cho option disabled */
    #mainAudioSelect option:disabled {
      color: #ff6666;
      font-style: italic;
      background: rgba(255, 50, 50, 0.1);
    }

    /* ===== HUD TIMER EXTRA VARS ===== */
    :root {
      --cyan: #00e5ff;
      --cyan-glow: rgba(0, 229, 255, 0.6);
      --green: #00ff88;
      --green-glow: rgba(0, 255, 136, 0.8);
      --seg-on: #00ff88;
      --seg-off: rgba(0, 255, 136, 0.07);
    }

    /* Scanlines overlay */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0, 0, 0, 0.03) 3px, rgba(0, 0, 0, 0.03) 4px);
      pointer-events: none;
      z-index: 9999;
    }

    /* ================================================================
         TITLE BLOCK WRAPPER
      ================================================================ */
    .hq-title-block {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      position: relative;
      user-select: none;
    }

    /* --- TICKER --- */
    .hq-ticker {
      width: 100%;
      overflow: hidden;
      border-top: 1px solid rgba(0, 255, 204, 0.18);
      border-bottom: 1px solid rgba(0, 255, 204, 0.18);
      background: rgba(0, 255, 204, 0.03);
      padding: 5px 0;
      margin-bottom: 18px;
      opacity: 0;
      animation: hq-fadein 0.5s 0.1s ease forwards;
    }

    .hq-ticker-inner {
      display: flex;
      gap: 0;
      white-space: nowrap;
      animation: hq-ticker-scroll 22s linear infinite;
    }

    .hq-ticker-item {
      font-family: 'Share Tech Mono', monospace;
      font-size: 11px;
      color: rgba(0, 255, 204, 0.5);
      letter-spacing: 2px;
      padding: 0 32px;
    }

    .hq-ticker-item b {
      color: rgba(0, 255, 204, 0.9);
    }

    @keyframes hq-ticker-scroll {
      0% {
        transform: translateX(0)
      }

      100% {
        transform: translateX(-50%)
      }
    }

    /* ================================================================
         MAIN CARD — 2 columns
      ================================================================ */
    .hq-title-card {
      position: relative;
      width: 90%;
      display: grid;
      grid-template-columns: 1fr 2fr;
      align-items: stretch;
      background: linear-gradient(180deg, rgba(0, 40, 80, 0.55) 0%, rgba(0, 20, 50, 0.35) 60%, transparent 100%);
      border-top: 2px solid transparent;
      border-image: linear-gradient(90deg, transparent 0%, rgba(0, 168, 255, 0.6) 20%, rgba(0, 255, 204, 0.9) 50%, rgba(0, 168, 255, 0.6) 80%, transparent 100%) 1;
      overflow: visible;
    }

    .hq-col-sep {
      position: absolute;
      left: 33.33%;
      top: 12px;
      bottom: 12px;
      width: 1px;
      background: linear-gradient(180deg, transparent, rgba(0, 255, 204, 0.3) 20%, rgba(0, 255, 204, 0.3) 80%, transparent);
    }

    .hq-corner {
      position: absolute;
      width: 28px;
      height: 28px;
      opacity: 0;
      animation: hq-fadein 0.4s ease forwards;
    }

    .hq-corner.tl {
      top: -1px;
      left: 0;
      animation-delay: 0.6s;
    }

    .hq-corner.tr {
      top: -1px;
      right: 0;
      animation-delay: 0.7s;
      transform: scaleX(-1);
    }

    .hq-corner line {
      stroke: #00ffcc;
      stroke-width: 2;
    }

    /* ================================================================
         LEFT COLUMN — HUD Timer
      ================================================================ */
    .hq-timer-col {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px 20px;
      gap: 0;
    }

    .hud-status {
      display: flex;
      align-items: center;
      gap: 7px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 9px;
      letter-spacing: 2.5px;
      color: var(--cyan);
      text-shadow: 0 0 8px var(--cyan-glow);
      opacity: .8;
      margin-bottom: 12px;
    }

    .hud-status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--green);
      box-shadow: 0 0 6px var(--green-glow);
      animation: hud-dot-pulse 1.5s ease-in-out infinite;
      flex-shrink: 0;
    }

    @keyframes hud-dot-pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: .3;
        transform: scale(.6);
      }
    }

    .hud-clock-wrap {
      position: relative;
      width: 130px;
      height: 130px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .hud-ring-outer {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 1.5px solid var(--cyan);
      box-shadow: 0 0 12px var(--cyan-glow), 0 0 30px rgba(0, 229, 255, .15), inset 0 0 12px rgba(0, 229, 255, .07);
      animation: hud-pulse-ring 3s ease-in-out infinite;
    }

    @keyframes hud-pulse-ring {

      0%,
      100% {
        box-shadow: 0 0 12px var(--cyan-glow), 0 0 30px rgba(0, 229, 255, .15), inset 0 0 12px rgba(0, 229, 255, .07);
      }

      50% {
        box-shadow: 0 0 20px var(--cyan-glow), 0 0 50px rgba(0, 229, 255, .28), inset 0 0 18px rgba(0, 229, 255, .13);
      }
    }

    .hud-progress-svg {
      position: absolute;
      inset: -7px;
      width: calc(100% + 14px);
      height: calc(100% + 14px);
      transform: rotate(-90deg);
      pointer-events: none;
    }

    .hud-progress-track {
      fill: none;
      stroke: rgba(0, 229, 255, 0.1);
      stroke-width: 4;
    }

    .hud-progress-bar {
      fill: none;
      stroke: var(--cyan);
      stroke-width: 4;
      stroke-linecap: round;
      filter: drop-shadow(0 0 5px var(--cyan));
      transition: stroke-dashoffset 1s linear;
    }

    .hud-ring-inner {
      position: absolute;
      inset: 9px;
      border-radius: 50%;
      border: 1px dashed rgba(0, 229, 255, 0.22);
    }

    .hud-ticks {
      position: absolute;
      inset: 0;
    }

    .hud-accent {
      position: absolute;
      width: 11px;
      height: 11px;
      border-color: var(--cyan);
      border-style: solid;
      opacity: 0.5;
    }

    .hud-accent.tl {
      top: 9px;
      left: 9px;
      border-width: 1.5px 0 0 1.5px;
    }

    .hud-accent.tr {
      top: 9px;
      right: 9px;
      border-width: 1.5px 1.5px 0 0;
    }

    .hud-accent.bl {
      bottom: 9px;
      left: 9px;
      border-width: 0 0 1.5px 1.5px;
    }

    .hud-accent.br {
      bottom: 9px;
      right: 9px;
      border-width: 0 1.5px 1.5px 0;
    }

    .hud-face {
      position: relative;
      width: 88px;
      height: 88px;
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0, 229, 255, 0.05) 0%, rgba(0, 0, 0, 0.97) 70%);
      border: 1px solid rgba(0, 229, 255, 0.15);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .hud-seg-display {
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .hud-seg-display.alarm {
      animation: hud-seg-alarm .75s step-start infinite;
    }

    @keyframes hud-seg-alarm {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: .08;
      }
    }

    .hud-colon-wrap {
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 5px;
      padding-bottom: 2px;
    }

    .hud-colon-dot {
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: var(--seg-on);
      animation: hud-colon-blink 1s step-start infinite;
    }

    @keyframes hud-colon-blink {

      0%,
      49% {
        opacity: 1;
      }

      50%,
      100% {
        opacity: .12;
      }
    }

    .hud-colon-dot.paused {
      animation: none;
      opacity: .12;
    }

    .hud-controls-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 14px;
      width: 100%;
    }

    .hud-input-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
    }

    .hud-time-input {
      background: rgba(0, 10, 25, 0.9);
      border: 1px solid rgba(0, 150, 255, 0.45);
      border-radius: 6px;
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      width: 62px;
      height: 32px;
      text-align: center;
      outline: none;
      text-shadow: 0 0 6px var(--cyan-glow);
      transition: all .2s;
    }

    .hud-time-input:focus {
      border-color: var(--cyan);
      box-shadow: 0 0 8px rgba(0, 229, 255, .3);
    }

    .hud-time-input::placeholder {
      color: rgba(0, 229, 255, .25);
    }

    .hud-input-label {
      font-size: 8px;
      letter-spacing: 2px;
      color: rgba(0, 229, 255, .42);
      font-family: 'Orbitron', monospace;
    }

    .hud-sep {
      color: var(--cyan);
      font-size: 18px;
      opacity: .5;
      font-family: 'Orbitron', monospace;
      padding-bottom: 10px;
    }

    .hud-btn {
      height: 32px;
      min-width: 54px;
      padding: 0 10px;
      background: transparent;
      border: 1px solid var(--cyan);
      color: var(--cyan);
      font-family: 'Orbitron', monospace;
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      cursor: pointer;
      clip-path: polygon(5px 0%, 100% 0%, calc(100% - 5px) 100%, 0% 100%);
      transition: all .2s;
      text-shadow: 0 0 6px var(--cyan-glow);
      box-shadow: 0 0 8px rgba(0, 229, 255, .1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      white-space: nowrap;
    }

    .hud-btn:hover {
      background: rgba(0, 229, 255, .1);
      box-shadow: 0 0 16px var(--cyan-glow);
      color: #fff;
    }

    .hud-btn:active {
      transform: scale(.97);
    }

    .hud-btn.primary {
      border-color: var(--green);
      color: var(--green);
      text-shadow: 0 0 6px var(--green-glow);
      box-shadow: 0 0 8px rgba(0, 255, 136, .1);
    }

    .hud-btn.primary:hover {
      background: rgba(0, 255, 136, .1);
      box-shadow: 0 0 16px var(--green-glow);
    }

    /* ================================================================
         RIGHT COLUMN — Title content
      ================================================================ */
    .hq-title-col {
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 28px 32px 28px 36px;
      gap: 0;
    }

    .hq-status-bar {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 14px;
      opacity: 0;
      animation: hq-slidein-down 0.5s 0.3s ease forwards;
      flex-wrap: wrap;
    }

    .hq-status-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: 'Share Tech Mono', monospace;
      font-size: 10px;
      color: rgba(160, 200, 224, 0.65);
      letter-spacing: 1.5px;
      text-transform: uppercase;
    }

    .hq-status-dot {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      animation: hq-dot-blink 1.8s ease infinite;
    }

    .hq-status-dot.green {
      background: #00ff88;
      box-shadow: 0 0 6px #00ff88;
    }

    .hq-status-dot.cyan {
      background: #00ffcc;
      box-shadow: 0 0 6px #00ffcc;
      animation-delay: 0.4s;
    }

    .hq-status-dot.orange {
      background: #ff9900;
      box-shadow: 0 0 6px #ff9900;
      animation-delay: 0.8s;
    }

    @keyframes hq-dot-blink {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.2
      }
    }

    .hq-divider {
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.3) 50%, transparent);
      margin-bottom: 18px;
      opacity: 0;
      animation: hq-fadein 0.4s 0.5s ease forwards;
    }

    .hq-main-title-scanline {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, transparent 0%, rgba(0, 255, 204, 0.7) 30%, rgba(0, 255, 204, 0.7) 70%, transparent 100%);
      mix-blend-mode: screen;
      pointer-events: none;
      animation: hq-scan-title 4s 1.5s linear infinite;
      opacity: 0;
    }

    @keyframes hq-scan-title {
      0% {
        top: -5px;
        opacity: 0;
      }

      5% {
        opacity: 0.6;
      }

      95% {
        opacity: 0.6;
      }

      100% {
        top: calc(100% + 5px);
        opacity: 0;
      }
    }

    .hq-main-title {
      font-family: 'Orbitron', sans-serif;
      font-weight: 900;
      font-size: clamp(22px, 3.5vw, 46px);
      text-align: left;
      line-height: 1.15;
      letter-spacing: clamp(1px, 0.35vw, 5px);
      text-transform: uppercase;
      position: relative;
      display: inline-block;
      background: linear-gradient(135deg, #e0f7ff 0%, #00e5ff 25%, #00ffcc 45%, #e0f7ff 62%, #00a8ff 80%, #00ffcc 100%);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 18px rgba(0, 255, 204, 0.55)) drop-shadow(0 0 40px rgba(0, 168, 255, 0.30));
      animation: hq-title-appear 0.7s 0.55s cubic-bezier(0.16, 1, 0.3, 1) both, hq-gradient-flow 5s 1.3s ease infinite, hq-glow-breathe 3s 1.3s ease infinite alternate;
    }

    @keyframes hq-gradient-flow {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes hq-glow-breathe {
      from {
        filter: drop-shadow(0 0 12px rgba(0, 255, 204, 0.40)) drop-shadow(0 0 30px rgba(0, 168, 255, 0.20));
      }

      to {
        filter: drop-shadow(0 0 28px rgba(0, 255, 204, 0.75)) drop-shadow(0 0 55px rgba(0, 168, 255, 0.45));
      }
    }

    @keyframes hq-title-appear {
      from {
        opacity: 0;
        transform: translateY(22px) skewX(-3deg);
        letter-spacing: 12px;
      }

      to {
        opacity: 1;
        transform: translateY(0) skewX(0deg);
      }
    }

    .hq-main-title::before,
    .hq-main-title::after {
      content: attr(data-text);
      position: absolute;
      inset: 0;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      opacity: 0;
    }

    .hq-main-title::before {
      background: linear-gradient(135deg, #ff3366, #ff6600);
      animation: hq-glitch-a 7s 2s infinite linear;
    }

    .hq-main-title::after {
      background: linear-gradient(135deg, #00ffcc, #00a8ff);
      animation: hq-glitch-b 7s 2.3s infinite linear;
    }

    @keyframes hq-glitch-a {

      0%,
      89%,
      100% {
        opacity: 0;
        clip-path: none;
        transform: none;
      }

      90% {
        opacity: .7;
        clip-path: polygon(0 18%, 100% 18%, 100% 32%, 0 32%);
        transform: translate(4px, 0);
      }

      92% {
        opacity: .5;
        clip-path: polygon(0 55%, 100% 55%, 100% 67%, 0 67%);
        transform: translate(-3px, 0);
      }

      94% {
        opacity: .6;
        clip-path: polygon(0 40%, 100% 40%, 100% 50%, 0 50%);
        transform: translate(2px, 0);
      }

      96% {
        opacity: 0;
      }
    }

    @keyframes hq-glitch-b {

      0%,
      86%,
      100% {
        opacity: 0;
        clip-path: none;
        transform: none;
      }

      87% {
        opacity: .6;
        clip-path: polygon(0 60%, 100% 60%, 100% 72%, 0 72%);
        transform: translate(-4px, 0);
      }

      90% {
        opacity: .4;
        clip-path: polygon(0 8%, 100% 8%, 100% 20%, 0 20%);
        transform: translate(3px, 0);
      }

      93% {
        opacity: 0;
      }
    }

    .hq-chips-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 20px;
      flex-wrap: wrap;
      opacity: 0;
      animation: hq-slidein-up 0.5s 1.1s ease forwards;
    }

    .hq-chip {
      display: flex;
      align-items: center;
      gap: 7px;
      padding: 6px 16px;
      border-radius: 3px;
      font-family: 'Orbitron', sans-serif;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 1px;
      text-transform: uppercase;
      position: relative;
      overflow: hidden;
      transition: all 0.3s;
      cursor: default;
      background: rgba(0, 10, 25, 0.7);
      border: 1px solid rgba(0, 150, 255, 0.25);
      color: rgba(160, 200, 224, 0.85);
      clip-path: polygon(6px 0%, 100% 0%, calc(100% - 6px) 100%, 0% 100%);
    }

    .hq-chip::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.06), transparent);
      transform: translateX(-100%);
      transition: transform 0.5s;
    }

    .hq-chip:hover {
      border-color: rgba(0, 255, 204, 0.5);
      color: #00ffcc;
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0, 255, 204, 0.15);
    }

    .hq-chip:hover::before {
      transform: translateX(100%);
    }

    .hq-chip.accent-cyan {
      border-color: rgba(0, 255, 204, 0.35);
    }

    .hq-chip-icon {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .hq-chip-icon.cyan {
      background: #00ffcc;
      box-shadow: 0 0 8px #00ffcc;
    }

    .hq-chip-sep {
      width: 1px;
      height: 18px;
      background: linear-gradient(180deg, transparent, rgba(0, 255, 204, 0.3), transparent);
    }

    .hq-bottom-bar {
      width: 100%;
      height: 3px;
      margin-top: 20px;
      background: rgba(0, 100, 200, 0.1);
      border-radius: 2px;
      overflow: hidden;
      opacity: 0;
      animation: hq-fadein 0.4s 1.3s ease forwards;
    }

    @keyframes hq-fadein {
      from {
        opacity: 0
      }

      to {
        opacity: 1
      }
    }

    @keyframes hq-slidein-down {
      from {
        opacity: 0;
        transform: translateY(-12px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    @keyframes hq-slidein-up {
      from {
        opacity: 0;
        transform: translateY(12px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    /* ================================================================
         GHOST CLOCK — fixed bottom-right
      ================================================================ */
    .ghost-clock {
      position: fixed;
      top: 5px;
      right: 5px;
      z-index: 10001;
      opacity: 0;
      pointer-events: none;
      transform: translateY(18px) scale(0.85);
      transition: opacity 0.35s cubic-bezier(0.4, 0, 0.2, 1), transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      padding-bottom: 28px;
    }

    .ghost-clock.should-show {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }

    .ghost-clock.peek {
      opacity: 0.85;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }

    .ghost-clock.alert-pop {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0) scale(1);
    }

    .ghost-shell {
      position: relative;
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(4, 12, 28, 0.85);
      border-radius: 50%;
      backdrop-filter: blur(12px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(0, 229, 255, 0.2);
      cursor: pointer;
      transition: box-shadow 0.2s, transform 0.15s;
    }

    .ghost-shell:hover {
      box-shadow: 0 8px 36px rgba(0, 0, 0, 0.7), 0 0 0 1.5px rgba(0, 229, 255, 0.55), 0 0 20px rgba(0, 229, 255, 0.2);
      transform: scale(1.04);
    }

    .ghost-shell:active {
      transform: scale(0.97);
    }

    .ghost-shell .g-ring-outer {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 1.5px solid var(--cyan);
      box-shadow: 0 0 12px var(--cyan-glow), 0 0 30px rgba(0, 229, 255, .15), inset 0 0 12px rgba(0, 229, 255, .07);
      animation: hud-pulse-ring 3s ease-in-out infinite;
      pointer-events: none;
    }

    .ghost-shell .g-progress-svg {
      position: absolute;
      inset: -7px;
      width: calc(100% + 14px);
      height: calc(100% + 14px);
      transform: rotate(-90deg);
      pointer-events: none;
    }

    .ghost-shell .g-ring-inner {
      position: absolute;
      inset: 9px;
      border-radius: 50%;
      border: 1px dashed rgba(0, 229, 255, 0.22);
      pointer-events: none;
    }

    .ghost-shell .g-accent {
      position: absolute;
      width: 10px;
      height: 10px;
      border-color: var(--cyan);
      border-style: solid;
      opacity: 0.45;
      pointer-events: none;
    }

    .ghost-shell .g-accent.tl {
      top: 8px;
      left: 8px;
      border-width: 1.5px 0 0 1.5px;
    }

    .ghost-shell .g-accent.tr {
      top: 8px;
      right: 8px;
      border-width: 1.5px 1.5px 0 0;
    }

    .ghost-shell .g-accent.bl {
      bottom: 8px;
      left: 8px;
      border-width: 0 0 1.5px 1.5px;
    }

    .ghost-shell .g-accent.br {
      bottom: 8px;
      right: 8px;
      border-width: 0 1.5px 1.5px 0;
    }

    .ghost-shell .g-ticks {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .ghost-shell .g-face {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0, 229, 255, 0.05) 0%, rgba(0, 0, 0, 0.97) 70%);
      border: 1px solid rgba(0, 229, 255, 0.13);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .ghost-label {
      position: absolute;
      bottom: 4px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Share Tech Mono', monospace;
      font-size: 9px;
      letter-spacing: 2px;
      color: var(--cyan);
      text-shadow: 0 0 6px var(--cyan-glow);
      white-space: nowrap;
      opacity: 0.7;
      pointer-events: none;
    }

    .ghost-hint {
      position: absolute;
      top: -26px;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Share Tech Mono', monospace;
      font-size: 8px;
      letter-spacing: 1.5px;
      color: rgba(0, 229, 255, 0.5);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }

    .ghost-clock.should-show:hover .ghost-hint {
      opacity: 1;
    }

    @keyframes ghost-alert-ring {
      0% {
        box-shadow: 0 0 0 0 rgba(0, 229, 255, 0.7);
      }

      70% {
        box-shadow: 0 0 0 12px rgba(0, 229, 255, 0);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(0, 229, 255, 0);
      }
    }

    .ghost-clock.alert-pop .ghost-shell {
      animation: ghost-alert-ring 0.6s ease-out 2;
    }

    /* ================================================================
         LAYOUT ADJUST — push main content below new title block
      ================================================================ */
    .main-content-wrapper {
      margin-top: 20px !important;
    }

    /* ================================================================
         RESPONSIVE HUD
      ================================================================ */
    @media (max-width:768px) {
      .hq-title-card {
        grid-template-columns: 1fr;
      }

      .hq-col-sep {
        display: none;
      }

      .hq-title-col {
        padding: 20px 16px;
      }

      .hq-timer-col {
        padding: 20px 16px;
        border-bottom: 1px solid rgba(0, 255, 204, 0.15);
      }

      .hq-main-title {
        text-align: center;
      }

      .hq-chips-row {
        justify-content: center;
      }
    }

    @media (max-width:480px) {
      .hud-controls-wrap {
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
      }
    }
  </style>
</head>

<body>
  <!-- Background Effects -->
  <div class="cyber-grid"></div>
  <div class="cyber-line"></div>

  <!-- ================================================================
         HQ TITLE BLOCK (replaces old h1 + timer-container)
    ================================================================ -->
  <div class="hq-title-block">

    <!-- Ticker -->
    <div class="hq-ticker" aria-hidden="true">
      <div class="hq-ticker-inner">
        <span class="hq-ticker-item">◈ SYS_ACTIVE</span>
        <span class="hq-ticker-item"><b>QUIZ_MODULE</b> :: TEST</span>
        <span class="hq-ticker-item">◈ READY</span>
        <span class="hq-ticker-item"><b>39 QUESTIONS</b> :: ARMED</span>
        <span class="hq-ticker-item">◈ NEURAL_LINK :: ONLINE</span>
        <span class="hq-ticker-item"><b>CYBERPUNK ENGINE</b> :: ACTIVE</span>
        <span class="hq-ticker-item">◈ SYS_ACTIVE</span>
        <span class="hq-ticker-item"><b>QUIZ_MODULE</b> :: TEST</span>
        <span class="hq-ticker-item">◈ READY</span>
        <span class="hq-ticker-item"><b>39 QUESTIONS</b> :: ARMED</span>
      </div>
    </div>

    <!-- 2-column card -->
    <div class="hq-title-card">

      <!-- Corner decorations -->
      <svg class="hq-corner tl" viewBox="0 0 28 28" fill="none">
        <line x1="0" y1="1" x2="28" y2="1" />
        <line x1="1" y1="0" x2="1" y2="28" />
      </svg>
      <svg class="hq-corner tr" viewBox="0 0 28 28" fill="none">
        <line x1="0" y1="1" x2="28" y2="1" />
        <line x1="1" y1="0" x2="1" y2="28" />
      </svg>

      <!-- Vertical separator -->
      <div class="hq-col-sep"></div>

      <!-- ═══ LEFT: HUD TIMER ═══ -->
      <div class="hq-timer-col">
        <div class="hud-status">
          <div class="hud-status-dot" id="hudStatusDot"></div>
          <span id="hudStatusText">STANDBY</span>
        </div>

        <div class="hud-clock-wrap" id="hudClockWrap">
          <div class="hud-ring-outer"></div>
          <svg class="hud-progress-svg" viewBox="0 0 144 144">
            <circle class="hud-progress-track" cx="72" cy="72" r="66" />
            <circle class="hud-progress-bar" id="hudProgressBar" cx="72" cy="72" r="66" stroke-dasharray="414.7"
              stroke-dashoffset="0" />
          </svg>
          <div class="hud-ticks" id="hudTicks"></div>
          <div class="hud-ring-inner"></div>
          <div class="hud-accent tl"></div>
          <div class="hud-accent tr"></div>
          <div class="hud-accent bl"></div>
          <div class="hud-accent br"></div>
          <div class="hud-face">
            <div class="hud-seg-display" id="hudSegDisplay">
              <svg id="hd4" width="17" height="30" viewBox="0 0 17 30" style="display:none"></svg>
              <svg id="hd0" width="17" height="30" viewBox="0 0 17 30"></svg>
              <svg id="hd1" width="17" height="30" viewBox="0 0 17 30"></svg>
              <div class="hud-colon-wrap">
                <div class="hud-colon-dot" id="hcd1"></div>
                <div class="hud-colon-dot" id="hcd2"></div>
              </div>
              <svg id="hd2" width="17" height="30" viewBox="0 0 17 30"></svg>
              <svg id="hd3" width="17" height="30" viewBox="0 0 17 30"></svg>
            </div>
          </div>
        </div>

        <div class="hud-controls-wrap">
          <button class="hud-btn" id="hudResetBtn">↺ RESET</button>
          <div style="display:flex;align-items:center;gap:4px;">
            <div class="hud-input-group">
              <input class="hud-time-input" id="hudInputMin" type="number" min="0" max="999" placeholder="20"
                value="20">
              <div class="hud-input-label">MIN</div>
            </div>
            <div class="hud-sep">:</div>
            <div class="hud-input-group">
              <input class="hud-time-input" id="hudInputSec" type="number" min="0" max="59" placeholder="00" value="0">
              <div class="hud-input-label">SEC</div>
            </div>
          </div>
          <button class="hud-btn primary" id="hudStartBtn">▶ START</button>
        </div>
      </div><!-- end .hq-timer-col -->

      <!-- ═══ RIGHT: TITLE ═══ -->
      <div class="hq-title-col">
        <div class="hq-status-bar">
          <div class="hq-status-item"><span class="hq-status-dot green"></span>SYS ONLINE</div>
          <div class="hq-status-item"><span class="hq-status-dot cyan"></span>MODULE : QUIZ</div>
          <div class="hq-status-item"><span class="hq-status-dot orange"></span>STATUS : READY</div>
        </div>
        <div class="hq-divider"></div>
        <div style="position:relative;">
          <div class="hq-main-title-scanline"></div>
          <!-- SỬA: placeholder TỪ VỰNG MIMIKARA UNIT 2 (111-130) được giữ nguyên -->
          <h1 class="hq-main-title" data-text="TỪ VỰNG MIMIKARA UNIT 2 (111-130)">TỪ VỰNG MIMIKARA UNIT 2 (111-130)</h1>
        </div>
        <div class="hq-chips-row">
          <!-- SỬA: placeholder 39 được giữ nguyên -->
          <div class="hq-chip accent-cyan"><span class="hq-chip-icon cyan"></span>39 Câu hỏi</div>
          <div class="hq-chip-sep"></div>
          <div class="hq-chip accent-cyan"><span class="hq-chip-icon cyan"></span>CYBERPUNK QUIZ</div>
        </div>
        <div class="hq-bottom-bar"></div>
      </div><!-- end .hq-title-col -->

    </div><!-- end .hq-title-card -->
  </div><!-- end .hq-title-block -->

  <!-- GHOST CLOCK (fixed bottom-right, mirrors HUD timer) -->
  <div class="ghost-clock" id="ghostClock" title="Click vào để ẩn">
    <div class="ghost-shell">
      <div class="g-ring-outer"></div>
      <svg class="g-progress-svg" viewBox="0 0 134 134">
        <circle fill="none" stroke="rgba(0,229,255,0.1)" stroke-width="3.5" cx="67" cy="67" r="60" />
        <circle id="ghostProgressBar" fill="none" stroke="var(--cyan)" stroke-width="3.5" stroke-linecap="round" cx="67"
          cy="67" r="60" style="filter:drop-shadow(0 0 4px var(--cyan));transition:stroke-dashoffset 1s linear;" />
      </svg>
      <div class="g-ticks" id="ghostTicks"></div>
      <div class="g-ring-inner"></div>
      <div class="g-accent tl"></div>
      <div class="g-accent tr"></div>
      <div class="g-accent bl"></div>
      <div class="g-accent br"></div>
      <div class="g-face">
        <div class="hud-seg-display" id="ghostSegDisplay">
          <svg id="gd4" width="15" height="27" viewBox="0 0 15 27" style="display:none"></svg>
          <svg id="gd0" width="15" height="27" viewBox="0 0 15 27"></svg>
          <svg id="gd1" width="15" height="27" viewBox="0 0 15 27"></svg>
          <div class="hud-colon-wrap">
            <div class="hud-colon-dot" id="gcd1"></div>
            <div class="hud-colon-dot" id="gcd2"></div>
          </div>
          <svg id="gd2" width="15" height="27" viewBox="0 0 15 27"></svg>
          <svg id="gd3" width="15" height="27" viewBox="0 0 15 27"></svg>
        </div>
      </div>
    </div>
    <div class="ghost-label" id="ghostLabel">STANDBY</div>
    <div class="ghost-hint" id="ghostHint">[ NHẤN ĐỂ ẨN ]</div>
  </div>

  <!-- Dark Mode Toggle removed -->
  <!-- Back To Top -->
  <button id="backToTopBtn" onclick="scrollToTop()" title="Lên đầu trang">
    <i class="fas fa-arrow-up"></i>
  </button>

  <!-- FLOATING BUTTONS -->
  <div id="leftFloatingBtn" class="floating-btn-container left">
    <div class="floating-btn left" onclick="toggleSidebar('left')">
      <i class="fas fa-times-circle"></i>
      <span class="badge" id="wrongAnswersBadge">0</span>
      <span class="btn-tooltip">Câu đã sai</span>
    </div>
  </div>
  <div id="rightFloatingBtn" class="floating-btn-container right">
    <div class="floating-btn right" onclick="toggleSidebar('right')">
      <i class="fas fa-cog"></i>
      <span class="btn-tooltip">Điều khiển</span>
    </div>
  </div>

  <!-- LEFT SIDEBAR - Wrong Answers -->
  <div id="leftSidebarPanel" class="sidebar-panel left">
    <button class="sidebar-toggle" onclick="toggleSidebar('left')">
      <i class="fas fa-chevron-left"></i>
    </button>
    <div class="sidebar-header">
      <h3>
        <i class="fas fa-times-circle" style="color: #ff3366"></i><span>CÂU ĐÃ SAI</span>
      </h3>
      <button class="sidebar-close" onclick="forceCloseSidebar('left')">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="sidebar-content">
      <div style="margin-bottom: 20px; display: flex; gap: 10px">
        <button class="cyber-button" onclick="showWrongAnswers()" style="flex: 2">
          <i class="fas fa-eye"></i> Xem
        </button>
        <button class="cyber-button" onclick="practiceWrongAnswers()" style="flex: 2">
          <i class="fas fa-graduation-cap"></i> Luyện
        </button>
        <button class="cyber-button" onclick="clearWrongAnswers()" style="
              flex: 1;
              background: linear-gradient(135deg, #ff3333, #ff6600);
            ">
          <i class="fas fa-trash"></i>
        </button>
      </div>
      <div id="wrongAnswersList" class="wrong-answers-list"></div>
    </div>
  </div>

  <!-- RIGHT SIDEBAR - Controls -->
  <div id="rightSidebarPanel" class="sidebar-panel right">
    <button class="sidebar-toggle" onclick="toggleSidebar('right')">
      <i class="fas fa-chevron-right"></i>
    </button>
    <div class="sidebar-header">
      <h3>
        <i class="fas fa-tasks" style="color: var(--secondary-glow)"></i><span>ĐIỀU KHIỂN</span>
      </h3>
      <button class="sidebar-close" onclick="forceCloseSidebar('right')">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="sidebar-content">
      <button class="cyber-button" onclick="submitQuiz()">
        <i class="fas fa-paper-plane"></i> Nộp bài
      </button>
      <button class="cyber-button" onclick="resetQuiz()">
        <i class="fas fa-redo-alt"></i> Làm lại
      </button>
      <button id="showAnswersBtn" class="cyber-button" onclick="showCorrectAnswers()" style="
            display: none;
            background: linear-gradient(135deg, #00cc66, #00ff88);
          ">
        <i class="fas fa-check-circle"></i> Hiện đáp án
      </button>

      <h4 style="
            color: var(--secondary-glow);
            margin: 20px 0 10px;
            font-family: Orbitron;
          ">
        <i class="fas fa-history"></i> LỊCH SỬ
      </h4>
      <ul id="quizHistory"></ul>

      <h4 style="
            color: var(--secondary-glow);
            margin: 20px 0 10px;
            font-family: Orbitron;
          ">
        <i class="fas fa-edit"></i> CẬP NHẬT ĐÁP ÁN
      </h4>
      <input type="text" id="editKey" placeholder="Ví dụ: q1 hoặc 4.1" style="
            width: 100%;
            margin-bottom: 10px;
            background: rgba(0, 10, 25, 0.9);
            color: white;
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            padding: 10px;
          " />
      <input type="text" id="editValue" placeholder="Số đáp án (1-4)" style="
            width: 100%;
            margin-bottom: 10px;
            background: rgba(0, 10, 25, 0.9);
            color: white;
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            padding: 10px;
          " />
      <button class="cyber-button" onclick="updateAnswer()" style="margin-bottom: 5px">
        <i class="fas fa-save"></i> Cập nhật
      </button>
      <button class="cyber-button" id="clearAnswersBtn" style="background: linear-gradient(135deg, #ff3333, #ff6600)">
        <i class="fas fa-eraser"></i> Xóa cập nhật
      </button>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div id="mainContentWrapper" class="main-content-wrapper">
    <div class="main-quiz-container">
<!-- AUDIO PLAYER TỔNG - GIỮ NGUYÊN TRẠNG THÁI BAN ĐẦU -->
<div style="margin-bottom: 20px; padding: 15px; background: rgba(0,20,40,0.5); border-radius: 10px; border: 1px solid rgba(0,150,255,0.3);"
     data-excel-audio="Mimikara-2-2.mp3"
     data-excel-exists="true">
  <!-- Dòng 1: Dropdown chọn file và các nút điều khiển chính -->
  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap;">
    <span style="color: var(--secondary-glow); font-weight: bold">AUDIO:</span>
    
    <!-- Dropdown chọn file audio -->
    <select id="mainAudioSelect" 
      style="
        background: rgba(0, 10, 25, 0.9);
        color: var(--text-primary);
        border: 1px solid rgba(0, 150, 255, 0.6);
        border-radius: 5px;
        padding: 8px 15px;
        min-width: 300px;
        cursor: pointer;
        outline: none;
        font-family: monospace;
      "
      onchange="changeAudioFile(this.value)">
      <option value="Mimikara-1-1.mp3" >Mimikara-1-1.mp3</option>
<option value="Mimikara-1-2.mp3" >Mimikara-1-2.mp3</option>
<option value="Mimikara-1-3.mp3" >Mimikara-1-3.mp3</option>
<option value="Mimikara-1-4.mp3" >Mimikara-1-4.mp3</option>
<option value="Mimikara-1-5.mp3" >Mimikara-1-5.mp3</option>
<option value="Mimikara-2-1.mp3" >Mimikara-2-1.mp3</option>
<option value="Mimikara-2-2.mp3" selected>Mimikara-2-2.mp3</option>
<option value="Mimikara-2-3.mp3" >Mimikara-2-3.mp3</option>
<option value="Mimikara-2-4.mp3" >Mimikara-2-4.mp3</option>
<option value="Mimikara-2-5.mp3" >Mimikara-2-5.mp3</option>
<option value="Mimikara-3-1.mp3" >Mimikara-3-1.mp3</option>
<option value="N1_Try Test 1.3.mp3" >N1_Try Test 1.3.mp3</option>
<option value="N1_Try Test 10.3.mp3" >N1_Try Test 10.3.mp3</option>
<option value="N1_Try Test 2.3.mp3" >N1_Try Test 2.3.mp3</option>
<option value="N1_Try Test 3.3.mp3" >N1_Try Test 3.3.mp3</option>
<option value="N1_Try Test 3.3_2.mp3" >N1_Try Test 3.3_2.mp3</option>
<option value="N1_Try Test 3.3_3.mp3" >N1_Try Test 3.3_3.mp3</option>
<option value="N1_Try Test 3.3_4.mp3" >N1_Try Test 3.3_4.mp3</option>
<option value="N1_Try Test 4.3_1.mp3" >N1_Try Test 4.3_1.mp3</option>
<option value="N1_Try Test 4.3_2.mp3" >N1_Try Test 4.3_2.mp3</option>
<option value="N1_Try Test 4.3_3.mp3" >N1_Try Test 4.3_3.mp3</option>
<option value="N1_Try Test 5.4.mp3" >N1_Try Test 5.4.mp3</option>
<option value="N1_Try Test 5.4_2.mp3" >N1_Try Test 5.4_2.mp3</option>
<option value="N1_Try Test 5.4_3.mp3" >N1_Try Test 5.4_3.mp3</option>
<option value="N1_Try Test 5.4_4.mp3" >N1_Try Test 5.4_4.mp3</option>
<option value="N1_Try Test 5.4_5.mp3" >N1_Try Test 5.4_5.mp3</option>
<option value="N1_Try Test 6.3.mp3" >N1_Try Test 6.3.mp3</option>
<option value="N1_Try Test 7.3.mp3" >N1_Try Test 7.3.mp3</option>
<option value="N1_Try Test 7.3_2.mp3" >N1_Try Test 7.3_2.mp3</option>
<option value="N1_Try Test 7.3_3.mp3" >N1_Try Test 7.3_3.mp3</option>
<option value="N1_Try Test 7.3_4.mp3" >N1_Try Test 7.3_4.mp3</option>
<option value="N1_Try Test 8.3.mp3" >N1_Try Test 8.3.mp3</option>
<option value="N1_Try Test 8.3_2.mp3" >N1_Try Test 8.3_2.mp3</option>
<option value="N1_Try Test 8.3_3.mp3" >N1_Try Test 8.3_3.mp3</option>
<option value="N1_Try Test 9.3.mp3" >N1_Try Test 9.3.mp3</option>

    </select>

    <!-- Nút Play/Pause -->
    <button
      id="mainPlayPauseBtn"
      onclick="toggleMainAudio()"
      style="
        background: linear-gradient(135deg, #00cc66, #00ff88);
        border: none;
        border-radius: 5px;
        color: #0a0e17;
        padding: 8px 15px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 5px;
      "
    >
      <i class="fas fa-play"></i> Phát
    </button>

    <!-- Speed Control -->
    <div style="
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(0, 0, 0, 0.3);
        padding: 5px 10px;
        border-radius: 5px;
      ">
      <i class="fas fa-tachometer-alt" style="color: var(--secondary-glow)"></i>
      <select id="mainSpeedSelect" 
        style="
          background: rgba(0, 10, 25, 0.9);
          color: var(--text-primary);
          border: 1px solid rgba(0, 150, 255, 0.4);
          border-radius: 5px;
          padding: 5px;
          cursor: pointer;
          outline: none;
        "
        onchange="changePlaybackSpeed(this.value)">
        <option value="0.5">0.5x</option>
        <option value="0.75">0.75x</option>
        <option value="1" selected>1x</option>
        <option value="1.25">1.25x</option>
        <option value="1.5">1.5x</option>
        <option value="2">2x</option>
      </select>
    </div>

    <!-- Volume control with mute button -->
    <div style="
        display: flex;
        align-items: center;
        gap: 5px;
        background: rgba(0, 0, 0, 0.3);
        padding: 5px 10px;
        border-radius: 5px;
      ">
      <i class="fas fa-volume-up" 
         id="mainVolumeIcon" 
         style="color: var(--secondary-glow); cursor: pointer; font-size: 18px;" 
         onclick="toggleMute(event)"
         onmouseover="this.style.opacity='0.8'"
         onmouseout="this.style.opacity='1'"
         title="Nhấn để tắt/bật âm thanh">
      </i>
      <input
        type="range"
        id="mainVolumeSlider"
        min="0"
        max="1"
        step="0.1"
        value="1"
        style="width: 80px; cursor: pointer;"
      />
    </div>

    <!-- Hiển thị thời gian đếm ngược -->
    <span
      id="mainAudioTime"
      style="
        color: var(--secondary-glow);
        font-family: 'Orbitron', sans-serif;
        min-width: 60px;
      "
      >00:00</span
    >
  </div>

  <!-- Dòng 2: Thanh tua (seek bar) -->
  <div style="display: flex; align-items: center; gap: 10px; padding: 0 5px;">
    <span style="color: var(--secondary-glow); font-size: 12px; min-width: 40px;" id="mainCurrentTime">00:00</span>
    <input
      type="range"
      id="mainSeekBar"
      min="0"
      max="100"
      value="0"
      step="0.1"
      style="
        flex: 1;
        height: 6px;
        background: linear-gradient(90deg, var(--primary-glow), var(--secondary-glow));
        border-radius: 3px;
        cursor: pointer;
        -webkit-appearance: none;
      "
      oninput="seekAudio(this.value)"
    />
    <span style="color: var(--secondary-glow); font-size: 12px; min-width: 40px;" id="mainDuration">00:00</span>
  </div>
</div>

<!-- Audio element - SỬ DỤNG JAVASCRIPT ĐỂ TẢI FILE -->
<audio id="mainAudio" preload="auto" style="display: none;"></audio>
      <!-- H2 - SỬA: thêm placeholder cho tên bài test -->
      <h2 style="
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(0, 255, 204, 0.3);
            padding-bottom: 15px;
          ">
        <i class="fas fa-file-alt" style="color: var(--secondary-glow)"></i>
        TỪ VỰNG MIMIKARA UNIT 2 (111-130)
      </h2>
      <form id="quizForm"></form>
    </div>
  </div>

  <!-- Popups -->
  <div id="timeUpAlert" class="time-up-alert" style="display: none">
    <i class="fas fa-hourglass-end" style="font-size: 40px; margin-bottom: 20px"></i>
    <h2>⏰ HẾT THỜI GIAN!</h2>
    <p style="margin-top: 10px">Bạn đã hết thời gian làm bài rồi!</p>
  </div>
  <!-- Overlay làm tối màn hình -->
  <div id="resultOverlay" class="result-overlay"></div>

  <div id="resultPopup" class="result-popup" style="display: none">
    <div class="result-popup-inner">
      <div class="result-popup-header">
        <h3 class="result-popup-title">
          <i class="fas fa-trophy" style="color: #ffd700; font-size: 24px"></i>
          KẾT QUẢ CỦA BẠN
        </h3>
        <button class="detail-popup-close test-modal-close" onclick="closeResultPopup()">
          Đóng
        </button>
      </div>

      <div class="result-popup-content">
        <i class="fas fa-trophy" style="font-size: 60px; color: #ffd700; margin-bottom: 15px"></i>
        <div class="score" id="popupScore"></div>
        <div id="popupComment" style="font-size: 20px; margin-top: 15px"></div>
      </div>
    </div>
  </div>

  <!-- ================================================================
         HUD TIMER + GHOST CLOCK SCRIPT
    ================================================================ -->
  <script>
    (function () {
      // ── Build main ticks ──
      const hudTicksEl = document.getElementById('hudTicks');
      for (let i = 0; i < 60; i++) {
        const el = document.createElement('div');
        const maj = i % 5 === 0;
        Object.assign(el.style, { position: 'absolute', left: '50%', top: '0', width: maj ? '1.5px' : '1px', height: (maj ? 8 : 5) + 'px', marginLeft: maj ? '-.75px' : '-.5px', background: 'var(--cyan)', opacity: maj ? '0.8' : '0.3', transformOrigin: '50% 65px', transform: `rotate(${i * 6}deg)`, boxShadow: maj ? '0 0 3px var(--cyan)' : 'none', borderRadius: '1px' });
        hudTicksEl.appendChild(el);
      }

      // ── 7-Segment engine ──
      const DIGITS = { 0: [1, 1, 1, 1, 1, 1, 0], 1: [0, 1, 1, 0, 0, 0, 0], 2: [1, 1, 0, 1, 1, 0, 1], 3: [1, 1, 1, 1, 0, 0, 1], 4: [0, 1, 1, 0, 0, 1, 1], 5: [1, 0, 1, 1, 0, 1, 1], 6: [1, 0, 1, 1, 1, 1, 1], 7: [1, 1, 1, 0, 0, 0, 0], 8: [1, 1, 1, 1, 1, 1, 1], 9: [1, 1, 1, 1, 0, 1, 1] };
      function makeSegPoints(W, H) {
        const t = 2.4, g = 0.5, r = t * 0.5, x0 = t + g, x1 = W - t - g, mid = H / 2;
        const by0 = t + g, by1 = mid - t / 2 - g, cy0 = mid + t / 2 + g, cy1 = H - t - g, gy = mid - t / 2, gr = r * 0.7;
        return [`${x0 + r},0 ${x1 - r},0 ${x1},${t} ${x0},${t}`, `${W - t},${by0 + r} ${W},${by0} ${W},${by1} ${W - t},${by1 - r}`, `${W - t},${cy0 + r} ${W},${cy0} ${W},${cy1} ${W - t},${cy1 - r}`, `${x0},${H - t} ${x1},${H - t} ${x1 - r},${H} ${x0 + r},${H}`, `${0},${cy0} ${t},${cy0 + r} ${t},${cy1 - r} ${0},${cy1}`, `${0},${by0} ${t},${by0 + r} ${t},${by1 - r} ${0},${by1}`, `${x0 + gr},${gy} ${x1 - gr},${gy} ${x1 - gr},${gy + t} ${x0 + gr},${gy + t}`];
      }
      const SEG_POLY = makeSegPoints(17, 30);
      function renderDigit(svgEl, num, onColor, offColor) {
        const segs = DIGITS[num] !== undefined ? DIGITS[num] : DIGITS[8]; svgEl.innerHTML = '';
        SEG_POLY.forEach((pts, i) => { const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); poly.setAttribute('points', pts); const on = segs[i] === 1; poly.setAttribute('fill', on ? onColor : offColor); if (on) poly.setAttribute('style', `filter:drop-shadow(0 0 1.5px ${onColor})`); svgEl.appendChild(poly); });
      }
      const dEls = [document.getElementById('hd4'), document.getElementById('hd0'), document.getElementById('hd1'), document.getElementById('hd2'), document.getElementById('hd3')];
      function renderTime(secs, colorOn, colorOff) {
        const m = Math.floor(secs / 60), s = secs % 60, d4 = Math.floor(m / 100), d0 = Math.floor((m % 100) / 10), d1 = m % 10, d2 = Math.floor(s / 10), d3 = s % 10;
        dEls[0].style.display = m >= 100 ? 'block' : 'none';
        [d4, d0, d1, d2, d3].forEach((n, i) => renderDigit(dEls[i], n, colorOn, colorOff));
      }

      // ── Timer state ──
      const CIRC = 2 * Math.PI * 66;
      const hudProgressBar = document.getElementById('hudProgressBar');
      hudProgressBar.setAttribute('stroke-dasharray', CIRC);
      const hudStatusText = document.getElementById('hudStatusText');
      const hudStatusDot = document.getElementById('hudStatusDot');
      const hudSegDisplay = document.getElementById('hudSegDisplay');
      const hcd1 = document.getElementById('hcd1');
      const hcd2 = document.getElementById('hcd2');
      const hudInputMin = document.getElementById('hudInputMin');
      const hudInputSec = document.getElementById('hudInputSec');

      let totalSec = 20 * 60, remaining = totalSec, timerID = null, running = false;
      const MILESTONES = new Set([300, 60, 30]);
      let firedMilestones = new Set();

      function setColonPause(p) { [hcd1, hcd2].forEach(d => p ? d.classList.add('paused') : d.classList.remove('paused')); }
      function updateDisplay(alarm) {
        const on = alarm ? '#ff3333' : 'var(--seg-on)', off = alarm ? 'rgba(255,51,51,0.06)' : 'var(--seg-off)';
        renderTime(remaining, on, off);
        const frac = totalSec > 0 ? remaining / totalSec : 0;
        hudProgressBar.style.strokeDashoffset = CIRC * (1 - frac);
        const warn = alarm || (remaining <= 10 && remaining > 0);
        hudProgressBar.style.stroke = warn ? '#ff3333' : 'var(--cyan)';
        hudProgressBar.style.filter = warn ? 'drop-shadow(0 0 5px #ff3333)' : 'drop-shadow(0 0 4px var(--cyan))';
      }
      function setStatus(s) {
        const map = { standby: { t: 'STANDBY', c: 'var(--green)', g: 'var(--green-glow)', a: true }, running: { t: 'RUNNING', c: 'var(--green)', g: 'var(--green-glow)', a: false }, paused: { t: 'PAUSED', c: '#ffaa00', g: 'rgba(255,170,0,.8)', a: true }, done: { t: 'COMPLETE', c: '#ff3333', g: 'rgba(255,51,51,.8)', a: false } };
        const d = map[s] || map.standby;
        hudStatusText.textContent = d.t; hudStatusDot.style.background = d.c; hudStatusDot.style.boxShadow = `0 0 6px ${d.g}`;
        hudStatusDot.style.animation = d.a ? 'hud-dot-pulse 1.5s ease-in-out infinite' : 'none';
      }
      function getInputTime() {
        const rawM = hudInputMin.value, rawS = hudInputSec.value;
        const m = (rawM === '' || isNaN(parseInt(rawM))) ? 20 : Math.max(0, Math.min(999, parseInt(rawM)));
        const s = (rawS === '' || isNaN(parseInt(rawS))) ? 0 : Math.max(0, Math.min(59, parseInt(rawS)));
        totalSec = m * 60 + s; if (totalSec <= 0) totalSec = 20 * 60; remaining = totalSec; firedMilestones.clear();
      }

      // ── Ghost clock setup ──
      const ghostTicksEl = document.getElementById('ghostTicks');
      for (let i = 0; i < 60; i++) { const el = document.createElement('div'); const maj = i % 5 === 0; Object.assign(el.style, { position: 'absolute', left: '50%', top: '0', width: maj ? '1.5px' : '1px', height: (maj ? 7 : 4) + 'px', marginLeft: maj ? '-.75px' : '-.5px', background: 'var(--cyan)', opacity: maj ? '0.75' : '0.28', transformOrigin: '50% 60px', transform: `rotate(${i * 6}deg)`, boxShadow: maj ? '0 0 3px var(--cyan)' : 'none', borderRadius: '1px' }); ghostTicksEl.appendChild(el); }
      const gSEG_POLY = makeSegPoints(15, 27);
      const gdEls = [document.getElementById('gd4'), document.getElementById('gd0'), document.getElementById('gd1'), document.getElementById('gd2'), document.getElementById('gd3')];
      const gcd1 = document.getElementById('gcd1'), gcd2 = document.getElementById('gcd2');
      const ghostProgressBar = document.getElementById('ghostProgressBar');
      const ghostClock = document.getElementById('ghostClock');
      const ghostLabel = document.getElementById('ghostLabel');
      const ghostHint = document.getElementById('ghostHint');
      const ghostShell = ghostClock.querySelector('.ghost-shell');
      const ghostSegDisplay = document.getElementById('ghostSegDisplay');
      const G_CIRC = 2 * Math.PI * 60;
      ghostProgressBar.setAttribute('stroke-dasharray', G_CIRC);

      let realClockVisible = true, ghostDismissed = false, ghostHoverTimeout = null, alertPopTimeout = null;

      function renderGhostDigit(svgEl, num, onColor, offColor) {
        const segs = DIGITS[num] !== undefined ? DIGITS[num] : DIGITS[8]; svgEl.innerHTML = '';
        gSEG_POLY.forEach((pts, i) => { const poly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon'); poly.setAttribute('points', pts); const on = segs[i] === 1; poly.setAttribute('fill', on ? onColor : offColor); if (on) poly.setAttribute('style', `filter:drop-shadow(0 0 1.5px ${onColor})`); svgEl.appendChild(poly); });
      }
      function syncGhost(alarm) {
        const on = alarm ? '#ff3333' : 'var(--seg-on)', off = alarm ? 'rgba(255,51,51,0.06)' : 'var(--seg-off)';
        const m = Math.floor(remaining / 60), s = remaining % 60, d4 = Math.floor(m / 100), d0 = Math.floor((m % 100) / 10), d1 = m % 10, d2 = Math.floor(s / 10), d3 = s % 10;
        gdEls[0].style.display = m >= 100 ? 'block' : 'none';
        [d4, d0, d1, d2, d3].forEach((n, i) => renderGhostDigit(gdEls[i], n, on, off));
        const frac = totalSec > 0 ? remaining / totalSec : 0;
        ghostProgressBar.style.strokeDashoffset = G_CIRC * (1 - frac);
        const warn = alarm || (remaining <= 10 && remaining > 0);
        ghostProgressBar.style.stroke = warn ? '#ff3333' : 'var(--cyan)';
        ghostProgressBar.style.filter = warn ? 'drop-shadow(0 0 5px #ff3333)' : 'drop-shadow(0 0 4px var(--cyan))';
        [gcd1, gcd2].forEach(d => running ? d.classList.remove('paused') : d.classList.add('paused'));
        alarm ? ghostSegDisplay.classList.add('alarm') : ghostSegDisplay.classList.remove('alarm');
        ghostLabel.textContent = hudStatusText.textContent;
      }
      function applyGhostVisibility() {
        ghostClock.classList.remove('should-show', 'peek', 'alert-pop');
        if (realClockVisible) return;
        if (!ghostDismissed) { ghostClock.classList.add('should-show'); ghostHint.textContent = '[ NHẤN ĐỂ ẨN ]'; }
      }
      function triggerAlertPop() {
        if (alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        ghostClock.classList.remove('should-show', 'peek'); ghostClock.classList.add('alert-pop');
        alertPopTimeout = setTimeout(() => { ghostClock.classList.remove('alert-pop'); applyGhostVisibility(); alertPopTimeout = null; }, 5000);
      }
      ghostShell.addEventListener('click', () => {
        if (alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        ghostClock.classList.remove('alert-pop', 'should-show', 'peek');
        if (!ghostDismissed) { ghostDismissed = true; ghostHint.textContent = '[ NHẤN ĐỂ HIỆN LẠI ]'; }
        else { ghostDismissed = false; ghostHint.textContent = '[ NHẤN ĐỂ ẨN ]'; if (!realClockVisible) ghostClock.classList.add('should-show'); }
      });
      const peekZone = document.createElement('div');
      Object.assign(peekZone.style, { position: 'fixed', top: '5px', right: '28px', width: '148px', height: '176px', zIndex: '10000', pointerEvents: 'auto' });
      document.body.appendChild(peekZone);
      peekZone.addEventListener('mouseenter', () => {
        if (realClockVisible || !ghostDismissed || alertPopTimeout) return;
        clearTimeout(ghostHoverTimeout); ghostClock.classList.remove('should-show', 'alert-pop'); ghostClock.classList.add('peek'); ghostHint.textContent = '[ NHẤN ĐỂ HIỆN LẠI ]';
      });
      peekZone.addEventListener('mouseleave', () => {
        if (!ghostClock.classList.contains('peek')) return;
        clearTimeout(ghostHoverTimeout); ghostHoverTimeout = setTimeout(() => ghostClock.classList.remove('peek'), 300);
      });
      ghostShell.addEventListener('mouseenter', () => clearTimeout(ghostHoverTimeout));
      ghostShell.addEventListener('mouseleave', () => {
        if (!ghostClock.classList.contains('peek')) return;
        ghostHoverTimeout = setTimeout(() => ghostClock.classList.remove('peek'), 300);
      });
      const observer = new IntersectionObserver((entries) => {
        realClockVisible = entries[0].isIntersecting;
        if (realClockVisible && alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        applyGhostVisibility();
      }, { threshold: 0.3 });
      observer.observe(document.getElementById('hudClockWrap'));

      // ── Tick functions ──
      function checkMilestone() {
        if (MILESTONES.has(remaining) && !firedMilestones.has(remaining)) {
          firedMilestones.add(remaining); if (!realClockVisible) triggerAlertPop();
        }
      }
      function tickWithGhost() {
        if (remaining <= 0) {
          clearInterval(timerID); timerID = null; running = false; remaining = 0;
          renderTime(0, '#ff3333', 'rgba(255,51,51,0.06)');
          hudProgressBar.style.strokeDashoffset = CIRC; hudProgressBar.style.stroke = '#ff3333'; hudProgressBar.style.filter = 'drop-shadow(0 0 5px #ff3333)';
          hudSegDisplay.classList.add('alarm'); setColonPause(true);
          document.getElementById('hudStartBtn').innerHTML = '▶ START'; setStatus('done'); syncGhost(true);
          if (!realClockVisible) triggerAlertPop(); return;
        }
        remaining--;
        const alarm = remaining <= 10 && remaining > 0, on = alarm ? '#ff3333' : 'var(--seg-on)', off = alarm ? 'rgba(255,51,51,0.06)' : 'var(--seg-off)';
        renderTime(remaining, on, off);
        const frac = totalSec > 0 ? remaining / totalSec : 0;
        hudProgressBar.style.strokeDashoffset = CIRC * (1 - frac); hudProgressBar.style.stroke = alarm ? '#ff3333' : 'var(--cyan)'; hudProgressBar.style.filter = alarm ? 'drop-shadow(0 0 5px #ff3333)' : 'drop-shadow(0 0 4px var(--cyan))';
        syncGhost(alarm); checkMilestone();
      }

      // ── Button wiring ──
      document.getElementById('hudStartBtn').addEventListener('click', () => {
        if (!running) {
          if (!timerID && remaining === 0) getInputTime();
          hudSegDisplay.classList.remove('alarm'); ghostSegDisplay.classList.remove('alarm'); setColonPause(false);[gcd1, gcd2].forEach(d => d.classList.remove('paused'));
          timerID = setInterval(tickWithGhost, 1000); running = true; document.getElementById('hudStartBtn').innerHTML = '⏸ PAUSE'; setStatus('running'); syncGhost(false);
        } else {
          clearInterval(timerID); timerID = null; running = false; setColonPause(true);[gcd1, gcd2].forEach(d => d.classList.add('paused'));
          document.getElementById('hudStartBtn').innerHTML = '▶ RESUME'; setStatus('paused'); syncGhost(false);
        }
      });
      document.getElementById('hudResetBtn').addEventListener('click', () => {
        clearInterval(timerID); timerID = null; running = false;
        hudSegDisplay.classList.remove('alarm'); ghostSegDisplay.classList.remove('alarm'); setColonPause(false);[gcd1, gcd2].forEach(d => d.classList.remove('paused'));
        if (alertPopTimeout) { clearTimeout(alertPopTimeout); alertPopTimeout = null; }
        getInputTime(); renderTime(remaining, 'var(--seg-on)', 'var(--seg-off)');
        hudProgressBar.style.strokeDashoffset = 0; hudProgressBar.style.stroke = 'var(--cyan)'; hudProgressBar.style.filter = 'drop-shadow(0 0 4px var(--cyan))';
        document.getElementById('hudStartBtn').innerHTML = '▶ START'; setStatus('standby'); syncGhost(false); applyGhostVisibility();
      });
      hudInputMin.addEventListener('change', () => { if (!running) { getInputTime(); updateDisplay(false); syncGhost(false); } });
      hudInputSec.addEventListener('change', () => { if (!running) { getInputTime(); updateDisplay(false); syncGhost(false); } });

      // ── Init ──
      getInputTime(); updateDisplay(false); setStatus('standby'); syncGhost(false); applyGhostVisibility();
    })();
  </script>

  <script>
    // ==================== INITIALIZATION ====================
    window.answers = JSON.parse(
      localStorage.getItem("customAnswers") || "{}",
    );
    let readingComprehensionCount = 0;
    const readingTimers = {};
    const savedRanges = {};


    // ==================== PROGRESS CONFIG (đồng bộ theo User ID) ====================
    const API_URL = "https://n1-license-server.onrender.com/api";
    const LS_DEVICE_ID = "n1_device_id";
    const LS_LICENSE = "n1_license";

    function getTestId() {
      const p = new URL(location.href).pathname;
      return p.split("/").pop() || "unknown.html";
    }

    function makeAttemptId() {
      return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    async function tryMarkPerfect() {
      const deviceId = localStorage.getItem(LS_DEVICE_ID) || "";
      const license = localStorage.getItem(LS_LICENSE) || "";
      if (!deviceId || !license) return;

      const moduleId = getTestId();
      //const attemptId = makeAttemptId();

      try {
        const res = await fetch(`${API_URL}/progress/mark-perfect`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ deviceId, license, moduleId }),
        });
        if (!res.ok) return;

        const data = await res.json();
        if (data && data.ok) {
          console.log("[PROGRESS] saved", { moduleId, ...data });
        }
      } catch (e) {
        console.log("progress api offline", e);
      }
    }


    // ==================== QUIZ DATA ====================
    const quizData = [
  {
    number: 1,
    question: '捻る',
    options: ['ひねる', 'みわける', 'みかける', 'くむ'],
    answer: '1',
    detail: '🔴 捻る（ひねる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 捻（ねん）＝ vặn, bóp<br>- Nghĩa đen: Dùng tay xoay, vặn một vật.<br>- Nghĩa Hán Việt: Niễn<br>- Ý nghĩa: Hành động vặn, xoắn, bẻ cong bằng tay. Cũng được dùng với nghĩa bóng chỉ việc suy nghĩ, tạo ra điều gì đó một cách khác thường hoặc phức tạp.<br>  → Chỉ hành động vật lý (vặn nắp, vặn khóa) hoặc tinh thần (nghĩ ra ý tưởng lắt léo, đánh đố).<br><br>💬 Ví dụ:<br>1. 蛇口を捻って水を止める。<br>　→ Vặn vòi nước để ngắt nước.<br><br>2. 彼はいつも捻った問題を出してくる。<br>　→ Anh ấy lúc nào cũng đưa ra những câu hỏi đánh đố.<br><br>3. 首を捻りながら難しい問題を考えた。<br>　→ Vừa vặn cổ (tỏ vẻ nghi ngờ, khó hiểu) vừa suy nghĩ về vấn đề khó.<br><br>🧠 Cách nhớ:<br>- Hình ảnh bàn tay (手) đang vặn (捻) một cái nắp chai.<br>- Liên tưởng đến âm Hán Việt "Niễn" - nghe như "nghiền, nắn" cũng có liên quan đến động tác xoắn, vặn.<br><br>✨（連）Các từ kết nối: 蛇口(じゃぐち)を捻る Vặn vòi nước<br>                        捻った問題 Câu hỏi đánh đố',
    isReading: false
  },
  {
    number: 2,
    question: '千切れる',
    options: ['みわける', 'ちぎれる', 'はう', 'あおぐ'],
    answer: '2',
    detail: '🔴 千切れる（ちぎれる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 千（ち）＝ nghìn<br>  • 切れる（きれる）＝ bị cắt, bị đứt<br>- Nghĩa đen: Bị cắt/bứt thành nhiều mảnh nhỏ.<br>- Nghĩa Hán Việt: Thiên thiệt.<br>- Ý nghĩa: Bị xé, bị bứt, bị đứt thành nhiều mảnh nhỏ.<br>  → Nhấn mạnh việc một vật bị tách rời thành nhiều phần nhỏ, thường là những vật mảnh, dễ rách như giấy, lá cây, dây, vải mỏng.<br><br>💬 Ví dụ:<br>1. 風で洗濯物が千切れて飛んでいった。<br>　→ Quần áo phơi bị gió xé rách và bay đi.<br><br>2. 子供が嬉しそうにパンを千切って食べている。<br>　→ Đứa trẻ vui vẻ xé nhỏ bánh mì ra ăn.<br><br>3. 強い力で引っ張ったら、ロープが千切れた。<br>　→ Khi kéo với lực mạnh, sợi dây thừng đã bị đứt thành nhiều đoạn.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa chữ Hán: 千 (nghìn - nhiều) + 切れる (bị cắt) = bị cắt thành nhiều (nghìn) mảnh.<br>- Liên tưởng: Hành động xé một tờ giấy thành nhiều mảnh nhỏ như confetti.<br><br>✨（連）Các từ kết nối: 紙・紐が・ロープが千切れた<br>                        紙が千切れた。Tờ giấy bị xé rách.<br>                        紐が千切れた。Sợi dây bị đứt tung ra.<br>                        ロープが千切れた。Sợi dây thừng bị đứt thành nhiều đoạn.<br><br>↔️（対）Các từ trái nghĩa: 切れる Bị cắt, bị đứt, hết (Nhấn mạnh vật bị chia tách hoặc hết, thường gọn, sắc bén)<br>                          破れる Bị rách, bị phá vỡ, bị tổn thương (Rách/đứt, nhưng không nhấn mạnh thành nhiều mảnh, chỉ cần rách hoặc hỏng)<br>                          千切れる Bị xé thành nhiều mảnh, bị bứt ra (Nhấn mạnh vật bị tách thành nhiều mảnh nhỏ, thường là vật mảnh như giấy, lá, dây, cành cây)',
    isReading: false
  },
  {
    number: 3,
    question: '千切る',
    options: ['ちぎる', 'みわける', 'みかける', 'あおぐ'],
    answer: '1',
    detail: '🔴 千切る（ちぎる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 千（せん）＝ một nghìn<br>  • 切る（きる）＝ cắt<br>- Nghĩa đen: Cắt thành từng mảnh nhỏ, xé vụn.<br>- Nghĩa Hán Việt: Thiên thiết<br>- Ý nghĩa: Hành động xé, bứt, cắt một vật gì đó thành nhiều mảnh nhỏ, thường bằng tay.<br>  → Thể hiện sự dứt khoát, mạnh mẽ khi tách rời hoặc phá vỡ một thứ gì đó.<br><br>💬 Ví dụ:<br>1. パンを千切って食べる。<br>　→ Xé bánh mì ra ăn.<br><br>2. 彼は怒って手紙を千切った。<br>　→ Anh ấy tức giận xé nát bức thư.<br><br>3. 千切った花びらを散らす。<br>　→ Rải những cánh hoa đã bứt ra.<br><br>🧠 Cách nhớ:<br>- Hình ảnh xé một tờ giấy thành một nghìn (千) mảnh bằng cách cắt (切る).<br>- Liên tưởng đến âm Hán Việt 「Thiên thiết」 - cắt ra thành nghìn mảnh.<br><br>✨（連）Các từ kết nối: 噛みちぎる (かみちぎる) Cắn đứt, xé bằng răng<br>                        食いちぎる (くいちぎる) Cắn xé và ăn luôn<br>                        褒めちぎる (ほめちぎる) Khen ngợi một cách dồn dập, hết lời, triệt để<br>                        ぶっちぎる Xé toang',
    isReading: false
  },
  {
    number: 4,
    question: '束ねる',
    options: ['たばねる', 'ひねる', 'うちあける', 'みわたす'],
    answer: '1',
    detail: '🔴 束ねる（たばねる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 束（たば）＝ bó, bó lại<br>  • ねる（ねる）＝ (hậu tố động từ) làm, thực hiện<br>- Nghĩa đen: Gom nhiều thứ lại và buộc thành một bó.<br>- Nghĩa Hán Việt: Thúc (bó lại, thúc đẩy)<br>- Ý nghĩa: Tập hợp, gom lại những thứ dài, mỏng, rời rạc (như tóc, củi, giấy tờ) và buộc chúng lại với nhau thành một bó gọn gàng.<br>  → Thường dùng cho tóc, hoa, củi, giấy tờ, v.v.<br><br>💬 Ví dụ:<br>1. 彼女は長い髪を後ろで束ねている。<br>　→ Cô ấy buộc tóc dài ra phía sau.<br><br>2. 古い新聞をひもで束ねてリサイクルに出した。<br>　→ Tôi bó những tờ báo cũ bằng dây và đem đi tái chế.<br><br>3. 花束は美しい花を束ねて作られる。<br>　→ Bó hoa được làm bằng cách bó những bông hoa đẹp lại.<br>4.リーダーは人を束ねて一つの目的に向かわせるのが仕事だ。<br>  →Công việc của người lãnh đạo là tập hợp mọi người và hướng họ tới một mục tiêu chung.<br><br>🧠 Cách nhớ:<br>- Hình ảnh: Tạo một 「たば」(bó) từ nhiều thứ rời rạc.<br>- Liên tưởng: 「たば」+ 「ねる」= hành động tạo ra một bó.<br><br>✨（連）Các từ kết nối: 長い髪を一つに束ねた<br>                        古新聞を束ねる<br>チームを束ねる→Lãnh đạo nhóm<br><br>↔️（類）Các từ liên quan: 括る (くくる) Buộc, trói, cột lại<br>                          一括払い Thanh toán 1 lần',
    isReading: false
  },
  {
    number: 5,
    question: '扇ぐ',
    options: ['あおぐ', 'うちあける', 'いいつける', 'みかける'],
    answer: '1',
    detail: '🔴 扇ぐ（あおぐ）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 扇（あおぎ）＝ quạt<br>- Nghĩa đen: Dùng vật như quạt để tạo ra gió.<br>- Nghĩa Hán Việt: Phiến<br>- Ý nghĩa: Dùng tay hoặc vật dụng để phe phẩy tạo ra gió, thường để làm mát hoặc thổi bùng lên.<br>  → Hành động làm cho không khí chuyển động.<br><br>💬 Ví dụ:<br>1. 暑いので、うちわで顔を扇いだ。<br>　→ Vì trời nóng, tôi đã dùng quạt để quạt vào mặt.<br><br>2. 火を扇いで強くした。<br>　→ Quạt cho ngọn lửa bùng mạnh lên.<br><br>3. 彼は新聞紙を扇いで煙を払った。<br>　→ Anh ấy dùng tờ báo quạt để phẩy khói đi.<br><br>🧠 Cách nhớ:<br>- Chữ Kanji 扇 trông giống một cánh cửa (戸) bị che bởi cánh (羽), liên tưởng đến vật có cánh để quạt.<br>- Âm đọc あおぐ gần với あお (xanh, gió), liên tưởng đến hành động tạo ra gió.<br><br>✨（連）Các từ kết nối: 団扇・扇子(うちわ・せんす)を扇ぐ',
    isReading: false
  },
  {
    number: 6,
    question: '汲む',
    options: ['ささやく', 'くむ', 'ひねる', 'ちぎれる'],
    answer: '2',
    detail: '🔴 汲む（くむ）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 汲（く）む ＝ múc, hút, hiểu, lắng nghe<br>- Nghĩa đen: Dùng vật chứa để lấy chất lỏng (như nước) từ nguồn.<br>- Nghĩa Hán Việt: Cấp (lấy nước)<br>- Ý nghĩa: Hành động lấy nước hoặc chất lỏng. Nghĩa bóng chỉ việc thấu hiểu, nắm bắt ý đồ, tình cảm hoặc tình hình của người khác.<br>  → Từ việc múc nước, mở rộng nghĩa thành việc tiếp nhận, lĩnh hội những thứ trừu tượng như tâm tư, ý định.<br><br>💬 Ví dụ:<br>1. 井戸から水を汲む。<br>　→ Múc nước từ giếng.<br><br>2. 上司の意を汲んで行動する。<br>　→ Hành động dựa trên việc thấu hiểu ý đồ của cấp trên.<br><br>3. 彼は空気を読むのが上手で、場の雰囲気をよく汲む。<br>　→ Anh ấy giỏi đọc không khí và rất thấu hiểu bầu không khí của hiện trường.<br><br>🧠 Cách nhớ:<br>- Liên tưởng đến hình ảnh dùng gầu (chữ 汲 có bộ thủy) để múc (む) nước.<br>- Nghĩa bóng: Để hiểu ý người khác, cần phải múc (tiếp nhận) thông tin từ họ.<br><br>✨（連）Các từ kết nối: 井戸水(いどみず)を汲む<br>                        上司の意を汲む Hiểu ý cấp trên',
    isReading: false
  },
  {
    number: 7,
    question: '咥える',
    options: ['みかける', 'くわえる', 'うつむく', 'ささやく'],
    answer: '2',
    detail: '🔴 咥える（くわえる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 咥（くわ）＝ ngậm, cắn<br>- Nghĩa đen: Dùng miệng giữ chặt một vật.<br>- Nghĩa Hán Việt: Hiếp (ngậm, cắn)<br>- Ý nghĩa: Hành động dùng răng hoặc môi giữ chặt một vật trong miệng.<br>  → Thường dùng để miêu tả hành động ngậm, cắn một vật như điếu thuốc, ống điếu, khăn...<br><br>💬 Ví dụ:<br>1. 彼はいつもパイプを咥えている。<br>　→ Anh ấy lúc nào cũng ngậm ống điếu.<br><br>2. 犬が新聞を咥えて持ってきた。<br>　→ Con chó ngậm tờ báo mang đến.<br><br>3. タバコを咥えながら仕事をする。<br>　→ Vừa ngậm điếu thuốc vừa làm việc.<br><br>🧠 Cách nhớ:<br>- Hình ảnh 「口」 (khẩu - miệng) trong chữ 「咥」 liên quan đến hành động dùng miệng.<br>- Âm đọc 「くわえる」 gần giống với 「加える」 (thêm vào), nghĩ đến việc "thêm" một vật vào miệng.<br><br>✨（連）Các từ kết nối: タバコ・パイプを咥える',
    isReading: false
  },
  {
    number: 8,
    question: '舐める',
    options: ['なめる', 'うちあける', 'のりすごす', 'くむ'],
    answer: '1',
    detail: '🔴 舐める（なめる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 舐（な）＝ liếm<br>- Nghĩa đen: Dùng lưỡi để làm ướt hoặc cảm nhận bề mặt của vật gì đó.<br>- Nghĩa Hán Việt: Thiểm (liếm)<br>- Ý nghĩa: Hành động liếm. Thường được dùng với nghĩa bóng là coi thường, đánh giá thấp ai đó hoặc điều gì đó.<br>  → Có hai nghĩa chính: (1) Liếm. (2) Coi thường, xem nhẹ.<br><br>💬 Ví dụ:<br>1. 猫が自分の足を舐めている。<br>　→ Con mèo đang liếm chân của nó.<br><br>2. 彼は相手の実力を舐めている。<br>　→ Anh ta đang coi thường thực lực của đối thủ.<br><br>3. この仕事を舐めてかかると失敗するよ。<br>　→ Nếu anh xem nhẹ công việc này thì sẽ thất bại đấy.<br><br>🧠 Cách nhớ:<br>- Liên tưởng đến âm Hán Việt 「thiểm」, nghĩa là liếm.<br>- Hình ảnh một con thú 「な（Na）」đang 「め（Me）」liếm (舐める) thức ăn.<br><br>✨（連）Các từ kết nối: 舐めるように可愛がる Chỉ việc quá yêu thương một người/loài động vật nào đó<br><br>↔️（類）Các từ liên quan: なめてかかる Coi thường, xem nhẹ<br>                          侮る Khinh thường, khinh bỉ<br>                          軽く見る Xem nhẹ<br>                          甘く見る Xem nhẹ',
    isReading: false
  },
  {
    number: 9,
    question: '俯く',
    options: ['ちぎる', 'うつむく', 'みわける', 'うちあける'],
    answer: '2',
    detail: '🔴 俯く（うつむく）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 俯（ふ）＝ cúi xuống<br>  • く（く）＝ (phụ tố biểu thị hành động)<br>- Nghĩa đen: Hướng mặt xuống dưới.<br>- Nghĩa Hán Việt: Phủ (cúi xuống).<br>- Ý nghĩa: Cúi đầu, cúi mặt xuống.<br>  → Thường biểu thị trạng thái buồn bã, xấu hổ, suy tư hoặc nhìn xuống vật gì đó.<br><br>💬 Ví dụ:<br>1. 恥ずかしくて俯く。<br>　→ Vì xấu hổ mà cúi mặt.<br><br>2. 彼は俯いて歩いていた。<br>　→ Anh ấy vừa đi vừa cúi mặt.<br><br>3. 俯いて地面を見つめる。<br>　→ Cúi xuống nhìn chằm chằm vào mặt đất.<br><br>🧠 Cách nhớ:<br>- Liên tưởng: 「俯く」nghe như “út mù khơi” → Khi buồn (út) thì cúi mặt (mù khơi) xuống.<br>- Phân tích chữ Hán: Chữ 俯 có bộ Nhân Đứng (亻) chỉ người và chữ 府 (phủ) gợi ý về sự hướng xuống, phủ phục.<br><br>➕（合）Các từ kết hợp: 俯き加減 Hơi cúi mặt',
    isReading: false
  },
  {
    number: 10,
    question: '這う',
    options: ['はう', 'ひねる', 'みかける', 'ささやく'],
    answer: '1',
    detail: '🔴 這う（はう）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 這（は）＝ bò, trườn<br>- Nghĩa đen: Di chuyển bằng cách để bụng hoặc thân tiếp xúc với mặt đất hoặc bề mặt.<br>- Nghĩa Hán Việt: Giá<br>- Ý nghĩa: Hành động bò, trườn của động vật hoặc người.<br>  → Thường dùng cho côn trùng, rắn, hoặc khi con người di chuyển trong tư thế thấp.<br><br>💬 Ví dụ:<br>1. 赤ちゃんが床を這う。<br>　→ Em bé bò trên sàn nhà.<br><br>2. 毛虫が木の枝を這っている。<br>　→ Con sâu bò đang trườn trên cành cây.<br><br>3. 兵士たちは敵に気付かれないように地面を這って進んだ。<br>　→ Các binh sĩ tiến lên bằng cách bò dưới đất để không bị kẻ địch phát hiện.<br><br>🧠 Cách nhớ:<br>- Liên tưởng âm 「はう」 với hình ảnh một con rắn phát ra tiếng 「はー」 khi bò.<br>- Chữ Hán 這 có bộ Xước (辶) chỉ sự di chuyển, phần còn lại gợi hình ảnh thân thể uốn lượn khi bò.<br><br>✨（連）Các từ kết nối: 虫・へびが地面・壁を這う<br>                        Côn trùng/rắn bò trên mặt đất/tường.',
    isReading: false
  },
  {
    number: 11,
    question: '囁く',
    options: ['いいつける', 'なめる', 'ちぎる', 'ささやく'],
    answer: '4',
    detail: '🔴 囁く（ささやく）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 囁（ささや）＝ thì thầm<br>- Nghĩa đen: Nói với giọng rất nhỏ, nhẹ nhàng.<br>- Nghĩa Hán Việt: Nhiếp (thì thầm)<br>- Ý nghĩa: Hành động nói chuyện với âm lượng rất thấp, thường để chỉ nói riêng với ai đó hoặc nói những điều thân mật, bí mật.<br>  → Thường mang sắc thái lãng mạn, bí ẩn hoặc tâm sự.<br><br>💬 Ví dụ:<br>1. 彼は彼女の耳元で優しく囁いた。<br>　→ Anh ấy thì thầm dịu dàng bên tai cô ấy.<br><br>2. 木々の間を風が囁くように通り抜けた。<br>　→ Cơn gió luồn qua giữa những tán cây như đang thì thầm.<br><br>3. 愛の言葉を囁き合う。<br>　→ Thì thầm với nhau những lời yêu thương.<br><br>🧠 Cách nhớ:<br>- Tưởng tượng âm thanh "sasa" giống tiếng lá cây xào xạc, kết hợp với "yaku" (nói) → nói nhỏ như tiếng lá xào xạc.<br>- Liên tưởng đến hình ảnh hai người gần nhau, miệng (khẩu 口) ở gần tai (nhĩ 耳) để thì thầm.<br><br>✨（連）Các từ kết nối: 耳元で囁く Thì thầm vào tai<br>                        愛を囁く Thì thầm lời yêu thương<br><br>↔️（類）Các từ liên quan: 呟く (つぶやく) Thì thầm độc thoại<br>                          囁く(ささやく) Thì thầm với đối phương<br>                          噂 (うわさ) Lời đồn',
    isReading: false
  },
  {
    number: 12,
    question: '喚く',
    options: ['はう', 'わめく', 'みわける', 'ひねる'],
    answer: '2',
    detail: '🔴 喚く（わめく）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 喚（かん）＝ gọi, kêu lên<br>  • く（く）＝ (phần okurigana)<br>- Nghĩa đen: Gào lên, kêu to.<br>- Nghĩa Hán Việt: Hoán (kêu gọi, la lên)<br>- Ý nghĩa: La hét, gào thét ầm ĩ, thường thể hiện sự tức giận, đau khổ hoặc phản đối kịch liệt.<br>  → Hành động hét to với cường độ mạnh và thái độ dữ dội.<br><br>💬 Ví dụ:<br>1. 子供が駄々をこねて喚いている。<br>　→ Đứa trẻ đang ăn vạ và gào thét.<br><br>2. 酔っぱらいが店先で何か喚いていた。<br>　→ Một gã say đang gào thét điều gì đó trước cửa tiệm.<br><br>3. そんなに喚かなくても、話は聞いていますよ。<br>　→ Anh không cần phải hét như vậy, tôi đang nghe đây.<br><br>🧠 Cách nhớ:<br>- Kanji 喚 có bộ Khẩu (口) chỉ miệng, liên tưởng đến hành động dùng miệng để 「叫ぶ（さけぶ）」(la hét) hoặc 「怒鳴る（どなる）」(quát tháo).<br>- Âm Hán Việt là 「hoán」như trong 「喚起（かんき）」(kêu gọi, khơi dậy), giúp nhớ nghĩa "kêu gọi, la lên".<br><br>➕（合）Các từ kết hợp: 泣き喚く Kêu khóc<br>                        喚き散らす La hét om sòm, gào thét khắp nơi<br>                        喚き声 Tiếng la hét',
    isReading: false
  },
  {
    number: 13,
    question: '言いつける',
    options: ['はう', 'あおぐ', 'うちあける', 'いいつける'],
    answer: '4',
    detail: '🔴 言いつける（いいつける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 言（い）＝ nói<br>  • 付（つ）＝ gắn, đính kèm<br>- Nghĩa đen: Nói để gắn (trách nhiệm, mệnh lệnh) cho ai đó.<br>- Nghĩa Hán Việt: Ngôn phó<br>- Ý nghĩa: Ra lệnh, chỉ thị cho ai đó làm việc gì; hoặc báo cáo, mách lẻo với người có quyền về hành vi xấu của người khác.<br>  → Thường dùng khi người trên (cha mẹ, thầy cô, cấp trên) ra lệnh cho người dưới, hoặc khi trẻ con mách người lớn về lỗi của bạn.<br><br>💬 Ví dụ:<br>1. 母は私に弟の面倒を見るよう言いつけた。<br>　→ Mẹ đã bảo tôi phải trông nom em trai.<br><br>2. 先生に言いつけられたことをちゃんと守りなさい。<br>　→ Hãy tuân thủ đúng những điều thầy cô đã dặn.<br><br>3. 彼は私が遅刻したことを上司に言いつけた。<br>　→ Anh ta đã mách sếp việc tôi đi trễ.<br><br>🧠 Cách nhớ:<br>- Ghép 言う（いう - nói）và 付ける（つける - gắn vào）: 「Nói để gắn nhiệm vụ cho ai」→ ra lệnh, mách lẻo.<br>- Hình ảnh: Một người chỉ tay và nói 「いいつけ！」, gắn nhiệm vụ cho người khác.<br><br>↔️（類）Các từ liên quan: 命じる (めいじる) Ra lệnh<br>                          言いつけを守る Tuân theo mệnh lệnh<br>                          告げ口をする (つげぐち) Mách lẻo, mách với người trên, báo cáo chuyện của người khác',
    isReading: false
  },
  {
    number: 14,
    question: '打ち明ける',
    options: ['うつむく', 'うちあける', 'みかける', 'ささやく'],
    answer: '2',
    detail: '🔴 打ち明ける（うちあける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 打（う）＝ đánh, nói ra<br>  • 明（あ）＝ sáng, rõ ràng<br>- Nghĩa đen: Đánh mở ra<br>- Nghĩa Hán Việt: Đả minh<br>- Ý nghĩa: Thổ lộ, bày tỏ một điều bí mật hoặc suy nghĩ thầm kín mà trước đây đã giấu kín.<br>  → Thường dùng khi muốn nói ra sự thật, tâm tư, tình cảm thật lòng.<br><br>💬 Ví dụ:<br>1. 彼は悩みを親友に打ち明けた。<br>　→ Anh ấy đã thổ lộ nỗi lo lắng với người bạn thân.<br><br>2. 本当の気持ちを打ち明けるのは勇気がいる。<br>　→ Cần có dũng khí để thổ lộ tình cảm thật sự.<br><br>3. 秘密を打ち明けたら、気持ちが楽になった。<br>　→ Sau khi thổ lộ bí mật, tâm trạng trở nên nhẹ nhõm hơn.<br><br>🧠 Cách nhớ:<br>- Hình dung việc 「打つ」(đánh, nói) vào một cánh cửa đóng kín để 「明ける」(mở ra) nó, tức là mở lòng nói ra điều bí mật.<br>- Ghép âm: 「うちあける」→ "úi cha kê rờ" (nói ra điều gì đó khiến người nghe "úi chà").<br><br>✨（連）Các từ kết nối: 本心を打ち明ける Thú thật lòng mình<br><br>↔️（類）Các từ liên quan: 告白 Bộc bạch, tỏ tình',
    isReading: false
  },
  {
    number: 15,
    question: '見かける',
    options: ['うつむく', 'みかける', 'ちぎれる', 'あおぐ'],
    answer: '2',
    detail: '🔴 見かける（みかける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 掛ける（かける）＝ treo, móc, thực hiện một phần<br>- Nghĩa đen: Bắt gặp, nhìn thấy (một phần)<br>- Nghĩa Hán Việt: Kiến quải<br>- Ý nghĩa: Tình cờ nhìn thấy, bắt gặp ai đó hoặc cái gì đó.<br>  → Nhấn mạnh sự tình cờ, thoáng qua, không chủ đích tìm kiếm.<br><br>💬 Ví dụ:<br>1. 駅で昔の友達を見かけた。<br>　→ Tôi đã bắt gặp người bạn cũ ở nhà ga.<br><br>2. 最近、この辺で変わった鳥を見かける。<br>　→ Gần đây, tôi hay thấy một con chim lạ quanh đây.<br><br>3. あの俳優を町で見かけたという噂だ。<br>　→ Có tin đồn là đã bắt gặp diễn viên đó trong thị trấn.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa: 見 (nhìn) + かける (một phần) → nhìn thấy một phần, tình cờ lọt vào tầm mắt.<br>- Liên tưởng: Đang đi thì mắt (見) bị cái gì đó móc (かける) lại, quay lại nhìn thì là bắt gặp.<br><br>↔️（類）Các từ liên quan: 目にする Nhấn mạnh trải nghiệm bằng mắt, thường là việc đáng chú ý hoặc ấn tượng, để mắt đến.<br>                          見かける Nhấn mạnh tình cờ / thoáng qua, không phải chủ động tìm kiếm.',
    isReading: false
  },
  {
    number: 16,
    question: '見分ける',
    options: ['うちあける', 'みわける', 'ちぎる', 'なめる'],
    answer: '2',
    detail: '🔴 見分ける（みわける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 分（わ）ける ＝ phân chia, phân biệt<br>- Nghĩa đen: Nhìn ra và phân biệt.<br>- Nghĩa Hán Việt: Kiến phân.<br>- Ý nghĩa: Phân biệt, nhận ra sự khác biệt giữa các sự vật, hiện tượng.<br>  → Nhấn mạnh khả năng quan sát và nhận biết bằng mắt hoặc cảm nhận để tìm ra điểm khác biệt.<br><br>💬 Ví dụ:<br>1. 本物と偽物を見分けるのは難しい。<br>　→ Rất khó để phân biệt hàng thật và hàng giả.<br><br>2. 彼は双子の兄弟をすぐに見分けられる。<br>　→ Anh ấy có thể ngay lập tức phân biệt được hai anh em sinh đôi.<br><br>3. 経験を積むと、細かい違いを見分ける力がつく。<br>　→ Khi tích lũy kinh nghiệm, bạn sẽ có khả năng phân biệt được những điểm khác biệt nhỏ.<br><br>🧠 Cách nhớ:<br>- Gồm chữ 見 (nhìn) và 分ける (phân chia) → Nhìn để phân chia, tức là nhìn ra sự khác biệt để phân biệt.<br>- Liên tưởng: 見る（みる）＋ 分かる（わかる）＝ 見分ける（みわける）→ Nhìn và hiểu ra sự khác biệt.<br><br>↔️（類）Các từ liên quan: 識別 (しきべつ) Trang trọng, chuyên môn, nhấn mạnh khả năng nhận biết chi tiết<br>                          区別 Trung lập, dùng để nói về sự khác nhau rõ ràng giữa nhóm / loại<br>                          見かける Hội thoại, thực tế, nhấn mạnh khả năng nhận ra sự khác nhau bằng mắt / cảm nhận',
    isReading: false
  },
  {
    number: 17,
    question: '見渡す',
    options: ['みかける', 'みわたす', 'うつむく', 'みわける'],
    answer: '2',
    detail: '🔴 見渡す（みわたす）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 渡す（わたす）＝ vượt qua, truyền qua<br>- Nghĩa đen: Nhìn xuyên qua, nhìn vượt qua (một phạm vi)<br>- Nghĩa Hán Việt: Kiến đỗ<br>- Ý nghĩa: Nhìn bao quát, quan sát toàn bộ một phạm vi rộng lớn.<br>  → Thường dùng để diễn tả hành động nhìn ngắm toàn cảnh, tầm nhìn rộng.<br><br>💬 Ví dụ:<br>1. 山の頂上から町全体を見渡した。<br>　→ Từ đỉnh núi, tôi đã nhìn bao quát toàn bộ thị trấn.<br><br>2. 会場を見渡すと、たくさんの人が集まっていた。<br>　→ Khi nhìn bao quát khắp hội trường, rất nhiều người đã tụ tập.<br><br>3. 見渡す限りの桜並木がとても美しかった。<br>　→ Hàng cây anh đào trải dài ngút tầm mắt thật đẹp.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa: 見 (nhìn) + 渡す (vượt qua) = nhìn vượt qua, tức là nhìn xa, nhìn rộng.<br>- Liên tưởng: Đứng trên cao và nhìn (見) xa tới tận chân trời, như thể ánh mắt có thể vượt qua (渡す) mọi khoảng cách.<br><br>➕（合）Các từ kết hợp: 見渡す限り Rộng,xa ngút tầm mắt',
    isReading: false
  },
  {
    number: 18,
    question: '見落とす',
    options: ['みわたす', 'みかける', 'みおとす', 'くわえる'],
    answer: '3',
    detail: '🔴 見落とす（みおとす）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 落とす（おとす）＝ làm rơi, bỏ sót<br>- Nghĩa đen: Nhìn mà làm rơi mất.<br>- Nghĩa Hán Việt: Kiến lạc.<br>- Ý nghĩa: Không nhìn thấy, không phát hiện ra điều gì đó do sơ suất, bỏ qua một cách vô tình.<br>  → Chỉ việc không chú ý đến, không nhận ra một chi tiết, sự vật, sự việc nào đó mà lẽ ra phải thấy.<br><br>💬 Ví dụ:<br>1. 書類の重要な部分を見落としていた。<br>　→ Tôi đã bỏ sót phần quan trọng trong tài liệu.<br><br>2. 誤字を見落とさないように注意して読む。<br>　→ Tôi đọc một cách cẩn thận để không bỏ sót lỗi chính tả.<br><br>3. 彼は信号を見落として、そのまま進んでしまった。<br>　→ Anh ấy đã không nhìn thấy đèn tín hiệu và cứ thế đi tiếp.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa của hai chữ: 見 (nhìn) + 落とす (làm rơi) → Nhìn mà làm rơi mất (thông tin, chi tiết) → Bỏ sót.<br>- Liên tưởng: Khi đọc vội, bạn 「見」る (nhìn) nhưng thông tin lại bị 「落とす」 (rơi/trượt) khỏi tầm mắt.<br><br>↔️（類）Các từ liên quan: 見落とし Sự bỏ sót',
    isReading: false
  },
  {
    number: 19,
    question: '乗り過ごす',
    options: ['うちあける', 'ちぎれる', 'のりすごす', 'ささやく'],
    answer: '3',
    detail: '🔴 乗り過ごす（のりすごす）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 乗（の）り ＝ lên, đi lên (phương tiện)<br>  • 過（す）ごす ＝ vượt qua, trải qua<br>- Nghĩa đen: Đi (trên phương tiện) vượt qua (điểm dừng)<br>- Nghĩa Hán Việt: Thừa quá<br>- Ý nghĩa: Vô tình đi quá trạm dừng dự định trên tàu, xe buýt, v.v.<br>  → Chỉ sự việc xảy ra do không chú ý, không cố ý.<br><br>💬 Ví dụ:<br>1. 寝ていて、駅を乗り過ごしてしまった。<br>　→ Tôi đã ngủ quên và đi quá mất ga.<br><br>2. スマホを見ていて、バス停を乗り過ごす。<br>　→ Nhìn điện thoại mà đi quá trạm xe buýt.<br><br>3. 降りる駅を乗り過ごさないように注意する。<br>　→ Chú ý để không đi quá ga cần xuống.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa: 「乗る」(lên xe) + 「過ごす」(vượt qua) = lên xe và vượt qua điểm cần xuống.<br>- Phân biệt với 「乗り越す」(cố ý đi quá trạm để trốn vé): 「過ごす」mang nghĩa trải qua, thường là vô tình.<br><br>📎（対）Các từ trái nghĩa: 乗り越す Cố ý đi quá trạm',
    isReading: false
  },
  {
    number: 20,
    question: 'Vặn, xoay (Linh hoạt hơn 捻じる),đánh đố',
    options: ['捻る', '束ねる', '扇ぐ', '見落とす'],
    answer: '1',
    detail: '🔴 捻る（ひねる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 捻（ねん）＝ vặn, bóp<br>- Nghĩa đen: Dùng tay xoay, vặn một vật.<br>- Nghĩa Hán Việt: Niễn<br>- Ý nghĩa: Hành động vặn, xoắn, bẻ cong bằng tay. Cũng được dùng với nghĩa bóng chỉ việc suy nghĩ, tạo ra điều gì đó một cách khác thường hoặc phức tạp.<br>  → Chỉ hành động vật lý (vặn nắp, vặn khóa) hoặc tinh thần (nghĩ ra ý tưởng lắt léo, đánh đố).<br><br>💬 Ví dụ:<br>1. 蛇口を捻って水を止める。<br>　→ Vặn vòi nước để ngắt nước.<br><br>2. 彼はいつも捻った問題を出してくる。<br>　→ Anh ấy lúc nào cũng đưa ra những câu hỏi đánh đố.<br><br>3. 首を捻りながら難しい問題を考えた。<br>　→ Vừa vặn cổ (tỏ vẻ nghi ngờ, khó hiểu) vừa suy nghĩ về vấn đề khó.<br><br>🧠 Cách nhớ:<br>- Hình ảnh bàn tay (手) đang vặn (捻) một cái nắp chai.<br>- Liên tưởng đến âm Hán Việt "Niễn" - nghe như "nghiền, nắn" cũng có liên quan đến động tác xoắn, vặn.<br><br>✨（連）Các từ kết nối: 蛇口(じゃぐち)を捻る Vặn vòi nước<br>                        捻った問題 Câu hỏi đánh đố',
    isReading: false
  },
  {
    number: 21,
    question: 'Bị đứt, rách',
    options: ['俯く', '千切れる', '束ねる', '乗り過ごす'],
    answer: '2',
    detail: '🔴 千切れる（ちぎれる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 千（ち）＝ nghìn<br>  • 切れる（きれる）＝ bị cắt, bị đứt<br>- Nghĩa đen: Bị cắt/bứt thành nhiều mảnh nhỏ.<br>- Nghĩa Hán Việt: Thiên thiệt.<br>- Ý nghĩa: Bị xé, bị bứt, bị đứt thành nhiều mảnh nhỏ.<br>  → Nhấn mạnh việc một vật bị tách rời thành nhiều phần nhỏ, thường là những vật mảnh, dễ rách như giấy, lá cây, dây, vải mỏng.<br><br>💬 Ví dụ:<br>1. 風で洗濯物が千切れて飛んでいった。<br>　→ Quần áo phơi bị gió xé rách và bay đi.<br><br>2. 子供が嬉しそうにパンを千切って食べている。<br>　→ Đứa trẻ vui vẻ xé nhỏ bánh mì ra ăn.<br><br>3. 強い力で引っ張ったら、ロープが千切れた。<br>　→ Khi kéo với lực mạnh, sợi dây thừng đã bị đứt thành nhiều đoạn.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa chữ Hán: 千 (nghìn - nhiều) + 切れる (bị cắt) = bị cắt thành nhiều (nghìn) mảnh.<br>- Liên tưởng: Hành động xé một tờ giấy thành nhiều mảnh nhỏ như confetti.<br><br>✨（連）Các từ kết nối: 紙・紐が・ロープが千切れた<br>                        紙が千切れた。Tờ giấy bị xé rách.<br>                        紐が千切れた。Sợi dây bị đứt tung ra.<br>                        ロープが千切れた。Sợi dây thừng bị đứt thành nhiều đoạn.<br><br>↔️（対）Các từ trái nghĩa: 切れる Bị cắt, bị đứt, hết (Nhấn mạnh vật bị chia tách hoặc hết, thường gọn, sắc bén)<br>                          破れる Bị rách, bị phá vỡ, bị tổn thương (Rách/đứt, nhưng không nhấn mạnh thành nhiều mảnh, chỉ cần rách hoặc hỏng)<br>                          千切れる Bị xé thành nhiều mảnh, bị bứt ra (Nhấn mạnh vật bị tách thành nhiều mảnh nhỏ, thường là vật mảnh như giấy, lá, dây, cành cây)',
    isReading: false
  },
  {
    number: 22,
    question: 'Xé, bứt, ngắt bằng tay',
    options: ['俯く', '千切れる', '千切る', '這う'],
    answer: '3',
    detail: '🔴 千切る（ちぎる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 千（せん）＝ một nghìn<br>  • 切る（きる）＝ cắt<br>- Nghĩa đen: Cắt thành từng mảnh nhỏ, xé vụn.<br>- Nghĩa Hán Việt: Thiên thiết<br>- Ý nghĩa: Hành động xé, bứt, cắt một vật gì đó thành nhiều mảnh nhỏ, thường bằng tay.<br>  → Thể hiện sự dứt khoát, mạnh mẽ khi tách rời hoặc phá vỡ một thứ gì đó.<br><br>💬 Ví dụ:<br>1. パンを千切って食べる。<br>　→ Xé bánh mì ra ăn.<br><br>2. 彼は怒って手紙を千切った。<br>　→ Anh ấy tức giận xé nát bức thư.<br><br>3. 千切った花びらを散らす。<br>　→ Rải những cánh hoa đã bứt ra.<br><br>🧠 Cách nhớ:<br>- Hình ảnh xé một tờ giấy thành một nghìn (千) mảnh bằng cách cắt (切る).<br>- Liên tưởng đến âm Hán Việt 「Thiên thiết」 - cắt ra thành nghìn mảnh.<br><br>✨（連）Các từ kết nối: 噛みちぎる (かみちぎる) Cắn đứt, xé bằng răng<br>                        食いちぎる (くいちぎる) Cắn xé và ăn luôn<br>                        褒めちぎる (ほめちぎる) Khen ngợi một cách dồn dập, hết lời, triệt để<br>                        ぶっちぎる Xé toang',
    isReading: false
  },
  {
    number: 23,
    question: 'Cột lại, sắp xếp lại (thành bó)',
    options: ['束ねる', '見渡す', '這う', '千切れる'],
    answer: '1',
    detail: '🔴 束ねる（たばねる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 束（たば）＝ bó, bó lại<br>  • ねる（ねる）＝ (hậu tố động từ) làm, thực hiện<br>- Nghĩa đen: Gom nhiều thứ lại và buộc thành một bó.<br>- Nghĩa Hán Việt: Thúc (bó lại, thúc đẩy)<br>- Ý nghĩa: Tập hợp, gom lại những thứ dài, mỏng, rời rạc (như tóc, củi, giấy tờ) và buộc chúng lại với nhau thành một bó gọn gàng.<br>  → Thường dùng cho tóc, hoa, củi, giấy tờ, v.v.<br><br>💬 Ví dụ:<br>1. 彼女は長い髪を後ろで束ねている。<br>　→ Cô ấy buộc tóc dài ra phía sau.<br><br>2. 古い新聞をひもで束ねてリサイクルに出した。<br>　→ Tôi bó những tờ báo cũ bằng dây và đem đi tái chế.<br><br>3. 花束は美しい花を束ねて作られる。<br>　→ Bó hoa được làm bằng cách bó những bông hoa đẹp lại.<br><br>🧠 Cách nhớ:<br>- Hình ảnh: Tạo một 「たば」(bó) từ nhiều thứ rời rạc.<br>- Liên tưởng: 「たば」+ 「ねる」= hành động tạo ra một bó.<br><br>✨（連）Các từ kết nối: 長い髪を一つに束ねた<br>                        古新聞を束ねる<br><br>↔️（類）Các từ liên quan: 括る (くくる) Buộc, trói, cột lại<br>                          一括払い Thanh toán 1 lần',
    isReading: false
  },
  {
    number: 24,
    question: 'Quạt',
    options: ['扇ぐ', '這う', '喚く', '乗り過ごす'],
    answer: '1',
    detail: '🔴 扇ぐ（あおぐ）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 扇（あおぎ）＝ quạt<br>- Nghĩa đen: Dùng vật như quạt để tạo ra gió.<br>- Nghĩa Hán Việt: Phiến<br>- Ý nghĩa: Dùng tay hoặc vật dụng để phe phẩy tạo ra gió, thường để làm mát hoặc thổi bùng lên.<br>  → Hành động làm cho không khí chuyển động.<br><br>💬 Ví dụ:<br>1. 暑いので、うちわで顔を扇いだ。<br>　→ Vì trời nóng, tôi đã dùng quạt để quạt vào mặt.<br><br>2. 火を扇いで強くした。<br>　→ Quạt cho ngọn lửa bùng mạnh lên.<br><br>3. 彼は新聞紙を扇いで煙を払った。<br>　→ Anh ấy dùng tờ báo quạt để phẩy khói đi.<br><br>🧠 Cách nhớ:<br>- Chữ Kanji 扇 trông giống một cánh cửa (戸) bị che bởi cánh (羽), liên tưởng đến vật có cánh để quạt.<br>- Âm đọc あおぐ gần với あお (xanh, gió), liên tưởng đến hành động tạo ra gió.<br><br>✨（連）Các từ kết nối: 団扇・扇子(うちわ・せんす)を扇ぐ',
    isReading: false
  },
  {
    number: 25,
    question: 'Múc (chất lỏng), thấu hiểu, cảm thông, hiểu ý',
    options: ['見分ける', '汲む', '俯く', 'くぐる'],
    answer: '2',
    detail: '🔴 汲む（くむ）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 汲（く）む ＝ múc, hút, hiểu, lắng nghe<br>- Nghĩa đen: Dùng vật chứa để lấy chất lỏng (như nước) từ nguồn.<br>- Nghĩa Hán Việt: Cấp (lấy nước)<br>- Ý nghĩa: Hành động lấy nước hoặc chất lỏng. Nghĩa bóng chỉ việc thấu hiểu, nắm bắt ý đồ, tình cảm hoặc tình hình của người khác.<br>  → Từ việc múc nước, mở rộng nghĩa thành việc tiếp nhận, lĩnh hội những thứ trừu tượng như tâm tư, ý định.<br><br>💬 Ví dụ:<br>1. 井戸から水を汲む。<br>　→ Múc nước từ giếng.<br><br>2. 上司の意を汲んで行動する。<br>　→ Hành động dựa trên việc thấu hiểu ý đồ của cấp trên.<br><br>3. 彼は空気を読むのが上手で、場の雰囲気をよく汲む。<br>　→ Anh ấy giỏi đọc không khí và rất thấu hiểu bầu không khí của hiện trường.<br><br>🧠 Cách nhớ:<br>- Liên tưởng đến hình ảnh dùng gầu (chữ 汲 có bộ thủy) để múc (む) nước.<br>- Nghĩa bóng: Để hiểu ý người khác, cần phải múc (tiếp nhận) thông tin từ họ.<br><br>✨（連）Các từ kết nối: 井戸水(いどみず)を汲む<br>                        上司の意を汲む Hiểu ý cấp trên',
    isReading: false
  },
  {
    number: 26,
    question: 'Ngậm, kẹp, giữ (bằng miệng)',
    options: ['俯く', '捻る', '咥える', '言いつける'],
    answer: '3',
    detail: '🔴 咥える（くわえる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 咥（くわ）＝ ngậm, cắn<br>- Nghĩa đen: Dùng miệng giữ chặt một vật.<br>- Nghĩa Hán Việt: Hiếp (ngậm, cắn)<br>- Ý nghĩa: Hành động dùng răng hoặc môi giữ chặt một vật trong miệng.<br>  → Thường dùng để miêu tả hành động ngậm, cắn một vật như điếu thuốc, ống điếu, khăn...<br><br>💬 Ví dụ:<br>1. 彼はいつもパイプを咥えている。<br>　→ Anh ấy lúc nào cũng ngậm ống điếu.<br><br>2. 犬が新聞を咥えて持ってきた。<br>　→ Con chó ngậm tờ báo mang đến.<br><br>3. タバコを咥えながら仕事をする。<br>　→ Vừa ngậm điếu thuốc vừa làm việc.<br><br>🧠 Cách nhớ:<br>- Hình ảnh 「口」 (khẩu - miệng) trong chữ 「咥」 liên quan đến hành động dùng miệng.<br>- Âm đọc 「くわえる」 gần giống với 「加える」 (thêm vào), nghĩ đến việc "thêm" một vật vào miệng.<br><br>✨（連）Các từ kết nối: タバコ・パイプを咥える',
    isReading: false
  },
  {
    number: 27,
    question: 'Liếm',
    options: ['見渡す', '捻る', '舐める', '千切る'],
    answer: '3',
    detail: '🔴 舐める（なめる）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 舐（な）＝ liếm<br>- Nghĩa đen: Dùng lưỡi để làm ướt hoặc cảm nhận bề mặt của vật gì đó.<br>- Nghĩa Hán Việt: Thiểm (liếm)<br>- Ý nghĩa: Hành động liếm. Thường được dùng với nghĩa bóng là coi thường, đánh giá thấp ai đó hoặc điều gì đó.<br>  → Có hai nghĩa chính: (1) Liếm. (2) Coi thường, xem nhẹ.<br><br>💬 Ví dụ:<br>1. 猫が自分の足を舐めている。<br>　→ Con mèo đang liếm chân của nó.<br><br>2. 彼は相手の実力を舐めている。<br>　→ Anh ta đang coi thường thực lực của đối thủ.<br><br>3. この仕事を舐めてかかると失敗するよ。<br>　→ Nếu anh xem nhẹ công việc này thì sẽ thất bại đấy.<br><br>🧠 Cách nhớ:<br>- Liên tưởng đến âm Hán Việt 「thiểm」, nghĩa là liếm.<br>- Hình ảnh một con thú 「な（Na）」đang 「め（Me）」liếm (舐める) thức ăn.<br><br>✨（連）Các từ kết nối: 舐めるように可愛がる Chỉ việc quá yêu thương một người/loài động vật nào đó<br><br>↔️（類）Các từ liên quan: なめてかかる Coi thường, xem nhẹ<br>                          侮る Khinh thường, khinh bỉ<br>                          軽く見る Xem nhẹ<br>                          甘く見る Xem nhẹ',
    isReading: false
  },
  {
    number: 28,
    question: 'Nhìn xuống, cuối mặt xuống (Thường vì buồn, xấu hổ, suy nghĩ)',
    options: ['乗り過ごす', '俯く', '見落とす', '舐める'],
    answer: '2',
    detail: '🔴 俯く（うつむく）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 俯（ふ）＝ cúi xuống<br>  • く（く）＝ (phụ tố biểu thị hành động)<br>- Nghĩa đen: Hướng mặt xuống dưới.<br>- Nghĩa Hán Việt: Phủ (cúi xuống).<br>- Ý nghĩa: Cúi đầu, cúi mặt xuống.<br>  → Thường biểu thị trạng thái buồn bã, xấu hổ, suy tư hoặc nhìn xuống vật gì đó.<br><br>💬 Ví dụ:<br>1. 恥ずかしくて俯く。<br>　→ Vì xấu hổ mà cúi mặt.<br><br>2. 彼は俯いて歩いていた。<br>　→ Anh ấy vừa đi vừa cúi mặt.<br><br>3. 俯いて地面を見つめる。<br>　→ Cúi xuống nhìn chằm chằm vào mặt đất.<br><br>🧠 Cách nhớ:<br>- Liên tưởng: 「俯く」nghe như “út mù khơi” → Khi buồn (út) thì cúi mặt (mù khơi) xuống.<br>- Phân tích chữ Hán: Chữ 俯 có bộ Nhân Đứng (亻) chỉ người và chữ 府 (phủ) gợi ý về sự hướng xuống, phủ phục.<br><br>➕（合）Các từ kết hợp: 俯き加減 Hơi cúi mặt',
    isReading: false
  },
  {
    number: 29,
    question: 'Bò',
    options: ['汲む', '喚く', '這う', 'くぐる'],
    answer: '3',
    detail: '🔴 這う（はう）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 這（は）＝ bò, trườn<br>- Nghĩa đen: Di chuyển bằng cách để bụng hoặc thân tiếp xúc với mặt đất hoặc bề mặt.<br>- Nghĩa Hán Việt: Giá<br>- Ý nghĩa: Hành động bò, trườn của động vật hoặc người.<br>  → Thường dùng cho côn trùng, rắn, hoặc khi con người di chuyển trong tư thế thấp.<br><br>💬 Ví dụ:<br>1. 赤ちゃんが床を這う。<br>　→ Em bé bò trên sàn nhà.<br><br>2. 毛虫が木の枝を這っている。<br>　→ Con sâu bò đang trườn trên cành cây.<br><br>3. 兵士たちは敵に気付かれないように地面を這って進んだ。<br>　→ Các binh sĩ tiến lên bằng cách bò dưới đất để không bị kẻ địch phát hiện.<br><br>🧠 Cách nhớ:<br>- Liên tưởng âm 「はう」 với hình ảnh một con rắn phát ra tiếng 「はー」 khi bò.<br>- Chữ Hán 這 có bộ Xước (辶) chỉ sự di chuyển, phần còn lại gợi hình ảnh thân thể uốn lượn khi bò.<br><br>✨（連）Các từ kết nối: 虫・へびが地面・壁を這う<br>                        Côn trùng/rắn bò trên mặt đất/tường.',
    isReading: false
  },
  {
    number: 30,
    question: 'Chui qua, đi xuyên qua',
    options: ['捻る', 'くぐる', '見分ける', '千切る'],
    answer: '2',
    detail: '🔴 潜る／くぐる<br><br>🈶 Nghĩa & Giải thích:<br><br>Kanji:<br>• 潜（せん）＝ lặn, ẩn mình<br>• 括（không dùng trong từ này nhưng くぐる còn có kanji khác như「潜る」「くぐる」viết hiragana phổ biến hơn）<br><br>Nghĩa đen: Chui qua, lách qua, đi xuyên qua một không gian hẹp hoặc phía dưới vật gì đó.<br><br>Nghĩa Hán Việt: Tiềm (潜)<br><br>Ý nghĩa:<br>→ Chỉ hành động đi qua bên dưới, chui qua (cổng, rèm, bàn, đường hầm…).<br>→ Cũng dùng nghĩa bóng: vượt qua (khó khăn, giai đoạn, quy định), thoát khỏi sự kiểm soát.<br><br>💬 Ví dụ:<br><br>トンネルをくぐる。<br>　→ Đi xuyên qua đường hầm.<br><br>暖簾をくぐって店に入る。<br>　→ Vén rèm (noren) bước vào quán.<br><br>厳しい時代をくぐり抜けた。<br>　→ Đã vượt qua một thời kỳ khó khăn.<br><br>テーブルの下をくぐる。<br>　→ Chui qua dưới bàn.<br><br>🧠 Cách nhớ:<br><br>Hình dung một người cúi thấp người để chui qua cổng torii hoặc chui dưới bàn.<br><br>“くぐる” nghe giống “cúi gừ gừ” → phải cúi xuống mới chui qua được 😄<br><br>✨（連）Các từ kết nối:<br><br>鳥居(とりい)をくぐる → Đi qua cổng đền<br><br>暖簾(のれん)をくぐる → Vén rèm bước vào quán<br><br>困難(こんなん)をくぐり抜ける → Vượt qua khó khăn',
    isReading: false
  },
  {
    number: 31,
    question: 'Thì thầm, đồn thổi',
    options: ['咥える', '打ち明ける', '囁く', '這う'],
    answer: '3',
    detail: '🔴 囁く（ささやく）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 囁（ささや）＝ thì thầm<br>- Nghĩa đen: Nói với giọng rất nhỏ, nhẹ nhàng.<br>- Nghĩa Hán Việt: Nhiếp (thì thầm)<br>- Ý nghĩa: Hành động nói chuyện với âm lượng rất thấp, thường để chỉ nói riêng với ai đó hoặc nói những điều thân mật, bí mật.<br>  → Thường mang sắc thái lãng mạn, bí ẩn hoặc tâm sự.<br><br>💬 Ví dụ:<br>1. 彼は彼女の耳元で優しく囁いた。<br>　→ Anh ấy thì thầm dịu dàng bên tai cô ấy.<br><br>2. 木々の間を風が囁くように通り抜けた。<br>　→ Cơn gió luồn qua giữa những tán cây như đang thì thầm.<br><br>3. 愛の言葉を囁き合う。<br>　→ Thì thầm với nhau những lời yêu thương.<br><br>🧠 Cách nhớ:<br>- Tưởng tượng âm thanh "sasa" giống tiếng lá cây xào xạc, kết hợp với "yaku" (nói) → nói nhỏ như tiếng lá xào xạc.<br>- Liên tưởng đến hình ảnh hai người gần nhau, miệng (khẩu 口) ở gần tai (nhĩ 耳) để thì thầm.<br><br>✨（連）Các từ kết nối: 耳元で囁く Thì thầm vào tai<br>                        愛を囁く Thì thầm lời yêu thương<br><br>↔️（類）Các từ liên quan: 呟く (つぶやく) Thì thầm độc thoại<br>                          囁く(ささやく) Thì thầm với đối phương<br>                          噂 (うわさ) Lời đồn',
    isReading: false
  },
  {
    number: 32,
    question: 'La hét, quát',
    options: ['汲む', '捻る', '俯く', '喚く'],
    answer: '4',
    detail: '🔴 喚く（わめく）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 喚（かん）＝ gọi, kêu lên<br>  • く（く）＝ (phần okurigana)<br>- Nghĩa đen: Gào lên, kêu to.<br>- Nghĩa Hán Việt: Hoán (kêu gọi, la lên)<br>- Ý nghĩa: La hét, gào thét ầm ĩ, thường thể hiện sự tức giận, đau khổ hoặc phản đối kịch liệt.<br>  → Hành động hét to với cường độ mạnh và thái độ dữ dội.<br><br>💬 Ví dụ:<br>1. 子供が駄々をこねて喚いている。<br>　→ Đứa trẻ đang ăn vạ và gào thét.<br><br>2. 酔っぱらいが店先で何か喚いていた。<br>　→ Một gã say đang gào thét điều gì đó trước cửa tiệm.<br><br>3. そんなに喚かなくても、話は聞いていますよ。<br>　→ Anh không cần phải hét như vậy, tôi đang nghe đây.<br><br>🧠 Cách nhớ:<br>- Kanji 喚 có bộ Khẩu (口) chỉ miệng, liên tưởng đến hành động dùng miệng để 「叫ぶ（さけぶ）」(la hét) hoặc 「怒鳴る（どなる）」(quát tháo).<br>- Âm Hán Việt là 「hoán」như trong 「喚起（かんき）」(kêu gọi, khơi dậy), giúp nhớ nghĩa "kêu gọi, la lên".<br><br>➕（合）Các từ kết hợp: 泣き喚く Kêu khóc<br>                        喚き散らす La hét om sòm, gào thét khắp nơi<br>                        喚き声 Tiếng la hét',
    isReading: false
  },
  {
    number: 33,
    question: 'Ra lệnh, mách',
    options: ['千切る', '見かける', '言いつける', 'くぐる'],
    answer: '3',
    detail: '🔴 言いつける（いいつける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 言（い）＝ nói<br>  • 付（つ）＝ gắn, đính kèm<br>- Nghĩa đen: Nói để gắn (trách nhiệm, mệnh lệnh) cho ai đó.<br>- Nghĩa Hán Việt: Ngôn phó<br>- Ý nghĩa: Ra lệnh, chỉ thị cho ai đó làm việc gì; hoặc báo cáo, mách lẻo với người có quyền về hành vi xấu của người khác.<br>  → Thường dùng khi người trên (cha mẹ, thầy cô, cấp trên) ra lệnh cho người dưới, hoặc khi trẻ con mách người lớn về lỗi của bạn.<br><br>💬 Ví dụ:<br>1. 母は私に弟の面倒を見るよう言いつけた。<br>　→ Mẹ đã bảo tôi phải trông nom em trai.<br><br>2. 先生に言いつけられたことをちゃんと守りなさい。<br>　→ Hãy tuân thủ đúng những điều thầy cô đã dặn.<br><br>3. 彼は私が遅刻したことを上司に言いつけた。<br>　→ Anh ta đã mách sếp việc tôi đi trễ.<br><br>🧠 Cách nhớ:<br>- Ghép 言う（いう - nói）và 付ける（つける - gắn vào）: 「Nói để gắn nhiệm vụ cho ai」→ ra lệnh, mách lẻo.<br>- Hình ảnh: Một người chỉ tay và nói 「いいつけ！」, gắn nhiệm vụ cho người khác.<br><br>↔️（類）Các từ liên quan: 命じる (めいじる) Ra lệnh<br>                          言いつけを守る Tuân theo mệnh lệnh<br>                          告げ口をする (つげぐち) Mách lẻo, mách với người trên, báo cáo chuyện của người khác',
    isReading: false
  },
  {
    number: 34,
    question: 'Thú nhận, tiết lộ, bày tỏ',
    options: ['打ち明ける', '千切れる', '見落とす', '乗り過ごす'],
    answer: '1',
    detail: '🔴 打ち明ける（うちあける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 打（う）＝ đánh, nói ra<br>  • 明（あ）＝ sáng, rõ ràng<br>- Nghĩa đen: Đánh mở ra<br>- Nghĩa Hán Việt: Đả minh<br>- Ý nghĩa: Thổ lộ, bày tỏ một điều bí mật hoặc suy nghĩ thầm kín mà trước đây đã giấu kín.<br>  → Thường dùng khi muốn nói ra sự thật, tâm tư, tình cảm thật lòng.<br><br>💬 Ví dụ:<br>1. 彼は悩みを親友に打ち明けた。<br>　→ Anh ấy đã thổ lộ nỗi lo lắng với người bạn thân.<br><br>2. 本当の気持ちを打ち明けるのは勇気がいる。<br>　→ Cần có dũng khí để thổ lộ tình cảm thật sự.<br><br>3. 秘密を打ち明けたら、気持ちが楽になった。<br>　→ Sau khi thổ lộ bí mật, tâm trạng trở nên nhẹ nhõm hơn.<br><br>🧠 Cách nhớ:<br>- Hình dung việc 「打つ」(đánh, nói) vào một cánh cửa đóng kín để 「明ける」(mở ra) nó, tức là mở lòng nói ra điều bí mật.<br>- Ghép âm: 「うちあける」→ "úi cha kê rờ" (nói ra điều gì đó khiến người nghe "úi chà").<br><br>✨（連）Các từ kết nối: 本心を打ち明ける Thú thật lòng mình<br><br>↔️（類）Các từ liên quan: 告白 Bộc bạch, tỏ tình',
    isReading: false
  },
  {
    number: 35,
    question: 'Bắt gặp, nhìn thấy',
    options: ['見かける', '喚く', '見落とす', '千切れる'],
    answer: '1',
    detail: '🔴 見かける（みかける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 掛ける（かける）＝ treo, móc, thực hiện một phần<br>- Nghĩa đen: Bắt gặp, nhìn thấy (một phần)<br>- Nghĩa Hán Việt: Kiến quải<br>- Ý nghĩa: Tình cờ nhìn thấy, bắt gặp ai đó hoặc cái gì đó.<br>  → Nhấn mạnh sự tình cờ, thoáng qua, không chủ đích tìm kiếm.<br><br>💬 Ví dụ:<br>1. 駅で昔の友達を見かけた。<br>　→ Tôi đã bắt gặp người bạn cũ ở nhà ga.<br><br>2. 最近、この辺で変わった鳥を見かける。<br>　→ Gần đây, tôi hay thấy một con chim lạ quanh đây.<br><br>3. あの俳優を町で見かけたという噂だ。<br>　→ Có tin đồn là đã bắt gặp diễn viên đó trong thị trấn.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa: 見 (nhìn) + かける (một phần) → nhìn thấy một phần, tình cờ lọt vào tầm mắt.<br>- Liên tưởng: Đang đi thì mắt (見) bị cái gì đó móc (かける) lại, quay lại nhìn thì là bắt gặp.<br><br>↔️（類）Các từ liên quan: 目にする Nhấn mạnh trải nghiệm bằng mắt, thường là việc đáng chú ý hoặc ấn tượng, để mắt đến.<br>                          見かける Nhấn mạnh tình cờ / thoáng qua, không phải chủ động tìm kiếm.',
    isReading: false
  },
  {
    number: 36,
    question: 'Phân biệt (nhìn để phân biệt)',
    options: ['舐める', '千切る', '汲む', '見分ける'],
    answer: '4',
    detail: '🔴 見分ける（みわける）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 分（わ）ける ＝ phân chia, phân biệt<br>- Nghĩa đen: Nhìn ra và phân biệt.<br>- Nghĩa Hán Việt: Kiến phân.<br>- Ý nghĩa: Phân biệt, nhận ra sự khác biệt giữa các sự vật, hiện tượng.<br>  → Nhấn mạnh khả năng quan sát và nhận biết bằng mắt hoặc cảm nhận để tìm ra điểm khác biệt.<br><br>💬 Ví dụ:<br>1. 本物と偽物を見分けるのは難しい。<br>　→ Rất khó để phân biệt hàng thật và hàng giả.<br><br>2. 彼は双子の兄弟をすぐに見分けられる。<br>　→ Anh ấy có thể ngay lập tức phân biệt được hai anh em sinh đôi.<br><br>3. 経験を積むと、細かい違いを見分ける力がつく。<br>　→ Khi tích lũy kinh nghiệm, bạn sẽ có khả năng phân biệt được những điểm khác biệt nhỏ.<br><br>🧠 Cách nhớ:<br>- Gồm chữ 見 (nhìn) và 分ける (phân chia) → Nhìn để phân chia, tức là nhìn ra sự khác biệt để phân biệt.<br>- Liên tưởng: 見る（みる）＋ 分かる（わかる）＝ 見分ける（みわける）→ Nhìn và hiểu ra sự khác biệt.<br><br>↔️（類）Các từ liên quan: 識別 (しきべつ) Trang trọng, chuyên môn, nhấn mạnh khả năng nhận biết chi tiết<br>                          区別 Trung lập, dùng để nói về sự khác nhau rõ ràng giữa nhóm / loại<br>                          見かける Hội thoại, thực tế, nhấn mạnh khả năng nhận ra sự khác nhau bằng mắt / cảm nhận',
    isReading: false
  },
  {
    number: 37,
    question: 'Nhìn ra xa, nhìn tổng quan',
    options: ['見落とす', '見分ける', '見渡す', '俯く'],
    answer: '3',
    detail: '🔴 見渡す（みわたす）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 渡す（わたす）＝ vượt qua, truyền qua<br>- Nghĩa đen: Nhìn xuyên qua, nhìn vượt qua (một phạm vi)<br>- Nghĩa Hán Việt: Kiến đỗ<br>- Ý nghĩa: Nhìn bao quát, quan sát toàn bộ một phạm vi rộng lớn.<br>  → Thường dùng để diễn tả hành động nhìn ngắm toàn cảnh, tầm nhìn rộng.<br><br>💬 Ví dụ:<br>1. 山の頂上から町全体を見渡した。<br>　→ Từ đỉnh núi, tôi đã nhìn bao quát toàn bộ thị trấn.<br><br>2. 会場を見渡すと、たくさんの人が集まっていた。<br>　→ Khi nhìn bao quát khắp hội trường, rất nhiều người đã tụ tập.<br><br>3. 見渡す限りの桜並木がとても美しかった。<br>　→ Hàng cây anh đào trải dài ngút tầm mắt thật đẹp.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa: 見 (nhìn) + 渡す (vượt qua) = nhìn vượt qua, tức là nhìn xa, nhìn rộng.<br>- Liên tưởng: Đứng trên cao và nhìn (見) xa tới tận chân trời, như thể ánh mắt có thể vượt qua (渡す) mọi khoảng cách.<br><br>➕（合）Các từ kết hợp: 見渡す限り Rộng,xa ngút tầm mắt',
    isReading: false
  },
  {
    number: 38,
    question: 'Bỏ lở, để sót',
    options: ['見落とす', '汲む', '俯く', '見かける'],
    answer: '1',
    detail: '🔴 見落とす（みおとす）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 見（み）＝ nhìn, xem<br>  • 落とす（おとす）＝ làm rơi, bỏ sót<br>- Nghĩa đen: Nhìn mà làm rơi mất.<br>- Nghĩa Hán Việt: Kiến lạc.<br>- Ý nghĩa: Không nhìn thấy, không phát hiện ra điều gì đó do sơ suất, bỏ qua một cách vô tình.<br>  → Chỉ việc không chú ý đến, không nhận ra một chi tiết, sự vật, sự việc nào đó mà lẽ ra phải thấy.<br><br>💬 Ví dụ:<br>1. 書類の重要な部分を見落としていた。<br>　→ Tôi đã bỏ sót phần quan trọng trong tài liệu.<br><br>2. 誤字を見落とさないように注意して読む。<br>　→ Tôi đọc một cách cẩn thận để không bỏ sót lỗi chính tả.<br><br>3. 彼は信号を見落として、そのまま進んでしまった。<br>　→ Anh ấy đã không nhìn thấy đèn tín hiệu và cứ thế đi tiếp.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa của hai chữ: 見 (nhìn) + 落とす (làm rơi) → Nhìn mà làm rơi mất (thông tin, chi tiết) → Bỏ sót.<br>- Liên tưởng: Khi đọc vội, bạn 「見」る (nhìn) nhưng thông tin lại bị 「落とす」 (rơi/trượt) khỏi tầm mắt.<br><br>↔️（類）Các từ liên quan: 見落とし Sự bỏ sót',
    isReading: false
  },
  {
    number: 39,
    question: 'Đi quá ga, trạm cần xuống',
    options: ['乗り過ごす', '見落とす', '俯く', '千切れる'],
    answer: '1',
    detail: '🔴 乗り過ごす（のりすごす）<br><br>🈶 Nghĩa & Giải thích:<br>- Kanji:<br>  • 乗（の）り ＝ lên, đi lên (phương tiện)<br>  • 過（す）ごす ＝ vượt qua, trải qua<br>- Nghĩa đen: Đi (trên phương tiện) vượt qua (điểm dừng)<br>- Nghĩa Hán Việt: Thừa quá<br>- Ý nghĩa: Vô tình đi quá trạm dừng dự định trên tàu, xe buýt, v.v.<br>  → Chỉ sự việc xảy ra do không chú ý, không cố ý.<br><br>💬 Ví dụ:<br>1. 寝ていて、駅を乗り過ごしてしまった。<br>　→ Tôi đã ngủ quên và đi quá mất ga.<br><br>2. スマホを見ていて、バス停を乗り過ごす。<br>　→ Nhìn điện thoại mà đi quá trạm xe buýt.<br><br>3. 降りる駅を乗り過ごさないように注意する。<br>　→ Chú ý để không đi quá ga cần xuống.<br><br>🧠 Cách nhớ:<br>- Ghép nghĩa: 「乗る」(lên xe) + 「過ごす」(vượt qua) = lên xe và vượt qua điểm cần xuống.<br>- Phân biệt với 「乗り越す」(cố ý đi quá trạm để trốn vé): 「過ごす」mang nghĩa trải qua, thường là vô tình.<br><br>📎（対）Các từ trái nghĩa: 乗り越す Cố ý đi quá trạm',
    isReading: false
  }
]; 

    // ==================== READING TIMER FUNCTIONS ====================
    function setReadingTimer(idx) {
      const inputEl = document.getElementById(`readTimeInput-${idx}`);
      if (!inputEl) return;
      const minutes = parseInt(inputEl.value);
      if (isNaN(minutes) || minutes <= 0) {
        alert("Nhập số phút ≥ 1.");
        return;
      }
      readingTimers[idx] = {
        remaining: minutes * 60,
        original: minutes * 60,
        intervalId: null,
      };
      updateReadingTimerDisplay(idx);
    }

    function startReadingTimer(idx) {
      if (!readingTimers[idx])
        readingTimers[idx] = {
          remaining: 60,
          original: 60,
          intervalId: null,
        };
      if (readingTimers[idx].intervalId) return;
      readingTimers[idx].intervalId = setInterval(() => {
        const timerObj = readingTimers[idx];
        timerObj.remaining--;
        updateReadingTimerDisplay(idx);
        if (timerObj.remaining <= 0) {
          clearInterval(timerObj.intervalId);
          timerObj.intervalId = null;
          showTimeUpAlert(idx);
        }
      }, 1000);
    }

    function resetReadingTimer(idx) {
      const timerObj = readingTimers[idx];
      if (timerObj) {
        if (timerObj.intervalId) {
          clearInterval(timerObj.intervalId);
          timerObj.intervalId = null;
        }
        timerObj.remaining = timerObj.original || 0;
        updateReadingTimerDisplay(idx);
      }
    }

    function updateReadingTimerDisplay(idx) {
      const disp = document.getElementById(`readingTimerDisplay-${idx}`);
      if (!disp) return;
      const timerObj = readingTimers[idx] || { remaining: 0 };
      let sec = timerObj.remaining < 0 ? 0 : timerObj.remaining;
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      disp.textContent = `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    }

    function showTimeUpAlert(idx) {
      const readingBlock = document.querySelector(
        `.reading-comprehension[data-index='${idx}']`,
      );
      if (!readingBlock) return;
      const readingLabel = readingBlock.querySelector(".reading-label");
      const readingName = readingLabel
        ? readingLabel.textContent.trim()
        : `Đọc hiểu ${idx + 1}`;
      const alertDiv = document.createElement("div");
      alertDiv.innerHTML = `⏰ Hết thời gian của <strong>${readingName}</strong> rồi!`;
      alertDiv.style.cssText = `position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #d32f2f; color: white; padding: 20px 40px; border-radius: 5px; font-size: 24px; z-index: 100000; box-shadow: 0 4px 8px rgba(0,0,0,0.2);`;
      document.body.appendChild(alertDiv);
      setTimeout(() => alertDiv.remove(), 3000);
    }

    // ==================== HIGHLIGHT FUNCTIONS ====================
    function highlightSelection(idx, color) {
      const selection = window.getSelection();
      const range =
        savedRanges[idx] ||
        (selection.rangeCount > 0
          ? selection.getRangeAt(0).cloneRange()
          : null);
      if (!range || range.collapsed) {
        alert(
          "Vui lòng bôi đen văn bản trong phần đọc hiểu trước khi đổi màu.",
        );
        return;
      }
      const readingBlock = document.querySelector(
        `.reading-comprehension[data-index="${idx}"]`,
      );
      if (
        !readingBlock ||
        !readingBlock.contains(range.commonAncestorContainer)
      ) {
        alert("Vui lòng chọn văn bản trong phần đọc hiểu tương ứng.");
        return;
      }
      const fragment = range.extractContents();
      const span = document.createElement("span");
      span.style.color = color;
      span.style.fontWeight = "bold";
      span.appendChild(fragment);
      range.insertNode(span);
      savedRanges[idx] = null;
      selection.removeAllRanges();
    }

    function removeHighlights(idx) {
      const readingBlock = document.querySelector(
        `.reading-comprehension[data-index="${idx}"]`,
      );
      if (!readingBlock) return;
      const highlightedSpans = readingBlock.querySelectorAll(
        'span[style*="color:"]',
      );
      highlightedSpans.forEach((span) => {
        const content = document.createDocumentFragment();
        while (span.firstChild) content.appendChild(span.firstChild);
        span.parentNode.insertBefore(content, span);
        span.parentNode.removeChild(span);
      });
    }

    function findAncestor(el, fn) {
      while (el) {
        if (fn(el)) return el;
        el = el.parentNode;
      }
      return null;
    }

    // Save selection for highlight
    document.addEventListener("mouseup", function (e) {
      const sel = window.getSelection();
      if (sel.isCollapsed) return;
      const range = sel.getRangeAt(0);
      const readingBlock = findAncestor(
        range.commonAncestorContainer,
        (el) =>
          el.classList && el.classList.contains("reading-comprehension"),
      );
      if (readingBlock) {
        const idx = parseInt(readingBlock.getAttribute("data-index"));
        savedRanges[idx] = range.cloneRange();
      }
    });

    // ==================== RENDER QUIZ ====================
    function renderQuiz() {
      const form = document.getElementById("quizForm");
      if (!form) return;
      form.innerHTML = "";
      readingComprehensionCount = 0;

      quizData.forEach((q, index) => {
        const div = document.createElement("div");
        div.classList.add("question-block");

        if (q.isReading) {
          readingComprehensionCount++;
          let subQuestionsHtml = "";
          if (q.subQuestions && q.subQuestions.length > 0) {
            subQuestionsHtml = q.subQuestions
              .map(
                (subQ, subIndex) => `
              <div class="sub-question-container">
                <div class="sub-question-box">
                  <p><strong>${subQ.number}.</strong> ${subQ.subQuestion} <span class="sub-question-key">[key: q${index}_${subIndex}]</span></p>
                  <div class="sub-question-options">
                    ${subQ.options
                    .map(
                      (opt, optIndex) => `
                      <label class="answer-option">
                        <input type="radio" name="q${index}_${subIndex}" value="${optIndex + 1}">
                        ${opt}
                      </label>
                    `,
                    )
                    .join("")}
                  </div>
                </div>
              </div>
            `,
              )
              .join("");
          }

          div.innerHTML = `
            <div class="reading-comprehension" data-index="${index}">
              <div class="reading-title">
                <span class="reading-label">ĐỌC HIỂU ${readingComprehensionCount}</span>
              </div>
              <div class="highlight-controls">
                <div class="highlight-btn red" onclick="highlightSelection(${index}, '#ff3333'); event.preventDefault();" title="Đỏ"></div>
                <div class="highlight-btn blue" onclick="highlightSelection(${index}, '#00a8ff'); event.preventDefault();" title="Xanh"></div>
                <div class="highlight-btn purple" onclick="highlightSelection(${index}, '#aa00ff'); event.preventDefault();" title="Tím"></div>
                <div class="highlight-btn black" onclick="highlightSelection(${index}, '#000000'); event.preventDefault();" title="Đen"></div>
                <div class="highlight-btn remove-btn" onclick="removeHighlights(${index}); event.preventDefault();" title="Xóa highlight"><i class="fas fa-times"></i></div>
              </div>
              <div class="reading-timer-container" data-timer-index="${index}">
                <input type="number" class="reading-timer-input" id="readTimeInput-${index}" placeholder="1" min="1" max="120" value="5">
                <button type="button" class="reading-timer-btn" onclick="setReadingTimer(${index}); event.preventDefault();"><i class="fas fa-clock"></i> Đặt</button>
                <button type="button" class="reading-timer-btn" onclick="startReadingTimer(${index}); event.preventDefault();"><i class="fas fa-play"></i></button>
                <button type="button" class="reading-timer-btn" onclick="resetReadingTimer(${index}); event.preventDefault();"><i class="fas fa-undo"></i></button>
                <span class="reading-timer-display" id="readingTimerDisplay-${index}">00:00</span>
              </div>
              <div class="reading-content">
                <p><strong>${q.question}</strong></p>
                ${q.content ? `<p>${q.content}</p>` : ``}
              </div>
              ${subQuestionsHtml}
            </div>
          `;
          if (q.subQuestions) {
            q.subQuestions.forEach((subQ, subIndex) => {
              if (!window.quizAnswers) window.quizAnswers = {};
              window.quizAnswers[`q${index}_${subIndex}`] = subQ.answer;
            });
          }
        } else {
          div.innerHTML = `
            <div class="question-number"><span style="background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow)); color: #0a0e17; padding: 5px 12px; border-radius: 20px; font-size: 16px;">Câu ${q.number}</span></div>
            <p class="question-text">${q.question}</p>
          `;
          q.options.forEach((opt, i) => {
            const label = document.createElement("label");
            label.classList.add("answer-option");
            label.innerHTML = `<input type="radio" name="q${index}" value="${i + 1}"> ${opt}`;
            div.appendChild(label);
          });
          const detailBtn = document.createElement("button");
          detailBtn.classList.add("detail-btn");
          detailBtn.innerHTML =
            '<i class="fas fa-info-circle"></i> Xem chi tiết';
          detailBtn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            showQuestionDetail(index);
          });
          div.appendChild(detailBtn);
          if (!window.quizAnswers) window.quizAnswers = {};
          window.quizAnswers[`q${index}`] = q.answer;
        }
        form.appendChild(div);
      });
    }

    // ==================== SIDEBAR TOGGLE ====================
    function toggleSidebar(side) {
      const panel = document.getElementById(`${side}SidebarPanel`);
      const floatingBtn = document.getElementById(`${side}FloatingBtn`);
      const wrapper = document.getElementById("mainContentWrapper");
      const isActive = panel.classList.contains("active");
      if (!isActive) {
        panel.classList.add("active");
        floatingBtn.classList.add("hidden");
        if (side === "left") wrapper.classList.add("left-expanded");
        else wrapper.classList.add("right-expanded");
      } else {
        panel.classList.remove("active");
        floatingBtn.classList.remove("hidden");
        if (side === "left") wrapper.classList.remove("left-expanded");
        else wrapper.classList.remove("right-expanded");
      }
      localStorage.setItem(`${side}SidebarActive`, !isActive);
    }

    function forceCloseSidebar(side) {
      const panel = document.getElementById(`${side}SidebarPanel`);
      const floatingBtn = document.getElementById(`${side}FloatingBtn`);
      const wrapper = document.getElementById("mainContentWrapper");
      panel.classList.remove("active");
      floatingBtn.classList.remove("hidden");
      if (side === "left") wrapper.classList.remove("left-expanded");
      else wrapper.classList.remove("right-expanded");
      localStorage.setItem(`${side}SidebarActive`, "false");
    }
    // ==================== FIREWORKS EFFECT ====================
    function launchFireworks() {
      // Tạo container nếu chưa có
      let container = document.querySelector(".fireworks-container");
      if (!container) {
        container = document.createElement("div");
        container.className = "fireworks-container";
        document.body.appendChild(container);
      }

      // Số lượng pháo hoa
      const particleCount = 150;

      for (let i = 0; i < particleCount; i++) {
        setTimeout(() => {
          createFireworkParticle(container);
        }, i * 20); // Mỗi hạt cách nhau 20ms
      }

      // Thêm confetti rơi
      for (let i = 0; i < 50; i++) {
        setTimeout(() => {
          createConfetti();
        }, i * 30);
      }

      // Tự động xóa container sau 5 giây
      setTimeout(() => {
        if (container) container.remove();
      }, 5000);
    }

    function createFireworkParticle(container) {
      const particle = document.createElement("div");
      particle.className = "firework-particle";

      // Màu sắc ngẫu nhiên rực rỡ
      const colors = [
        "#ff3333",
        "#ff9933",
        "#ffff33",
        "#33ff33",
        "#33ffff",
        "#3366ff",
        "#9933ff",
        "#ff33ff",
        "#ff0066",
        "#ff6600",
        "#ffcc00",
        "#00ffcc",
      ];
      const color = colors[Math.floor(Math.random() * colors.length)];
      particle.style.backgroundColor = color;
      particle.style.boxShadow = `0 0 15px ${color}`;

      // Vị trí trung tâm màn hình
      const x = window.innerWidth / 2 + (Math.random() - 0.5) * 300;
      const y = window.innerHeight / 2 + (Math.random() - 0.5) * 200;

      particle.style.left = x + "px";
      particle.style.top = y + "px";

      // Hướng bay ngẫu nhiên
      const tx = (Math.random() - 0.5) * 500;
      const ty = (Math.random() - 0.5) * 500;

      particle.style.setProperty("--tx", tx + "px");
      particle.style.setProperty("--ty", ty + "px");

      container.appendChild(particle);

      // Tự xóa sau khi animation kết thúc
      setTimeout(() => particle.remove(), 1500);
    }

    function createConfetti() {
      const confetti = document.createElement("div");
      confetti.className = "confetti";

      // Màu sắc ngẫu nhiên
      const colors = [
        "#f00",
        "#0f0",
        "#00f",
        "#ff0",
        "#f0f",
        "#0ff",
        "#ff8800",
      ];
      confetti.style.backgroundColor =
        colors[Math.floor(Math.random() * colors.length)];

      // Hình dạng ngẫu nhiên (vuông, tròn, chữ nhật)
      const shapes = ["50%", "0", "20%"];
      confetti.style.borderRadius =
        shapes[Math.floor(Math.random() * shapes.length)];

      // Vị trí ngẫu nhiên
      confetti.style.left = Math.random() * 100 + "%";

      // Kích thước ngẫu nhiên
      const size = 5 + Math.random() * 10;
      confetti.style.width = size + "px";
      confetti.style.height = size + "px";

      // Thời gian rơi ngẫu nhiên
      const duration = 3 + Math.random() * 4;
      confetti.style.animation = `confetti-fall ${duration}s linear forwards`;

      document.body.appendChild(confetti);

      // Tự xóa sau khi rơi xong
      setTimeout(() => confetti.remove(), duration * 1000);
    }

    // Thêm hiệu ứng âm thanh (tùy chọn)
    function playVictorySound() {
      try {
        const audioContext = new (
          window.AudioContext || window.webkitAudioContext
        )();

        // Tạo âm thanh đơn giản
        const osc = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        osc.type = "sine";
        osc.frequency.value = 523.25; // C5

        gainNode.gain.value = 0.1;
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          audioContext.currentTime + 2,
        );

        osc.connect(gainNode);
        gainNode.connect(audioContext.destination);

        osc.start();
        osc.stop(audioContext.currentTime + 2);
      } catch (e) {
        console.log("Không thể phát âm thanh", e);
      }
    }

    // ==================== QUIZ FUNCTIONS ====================
    function submitQuiz() {
      const form = document.getElementById("quizForm");
      let correctAnswers = 0;
      let totalQuestions = 0;

      quizData.forEach((q) => {
        if (q.isReading && q.subQuestions)
          totalQuestions += q.subQuestions.length;
        else totalQuestions++;
      });

      quizData.forEach((q, index) => {
        if (q.isReading && q.subQuestions) {
          q.subQuestions.forEach((subQ, subIndex) => {
            const name = `q${index}_${subIndex}`;
            const selected = form.querySelector(
              `input[name='${name}']:checked`,
            );
            const correct =
              (window.answers && window.answers[name]) ||
              (window.quizAnswers && window.quizAnswers[name]);
            if (selected && selected.value === correct) {
              correctAnswers++;
              selected.parentElement.innerHTML +=
                ' <span class="correct-answer">✅ Đúng</span>';
            } else if (selected) {
              selected.parentElement.innerHTML +=
                ' <span class="wrong-answer">❌ Sai</span>';
              saveWrongAnswer(
                name,
                subQ.subQuestion,
                selected.value,
                correct,
              );
            }
          });
        } else {
          const name = `q${index}`;
          const selected = form.querySelector(
            `input[name='${name}']:checked`,
          );
          const correct =
            (window.answers && window.answers[name]) ||
            (window.quizAnswers && window.quizAnswers[name]);
          if (selected && selected.value === correct) {
            correctAnswers++;
            selected.parentElement.innerHTML +=
              ' <span class="correct-answer">✅ Đúng</span>';
          } else if (selected) {
            selected.parentElement.innerHTML +=
              ' <span class="wrong-answer">❌ Sai</span>';
            saveWrongAnswer(name, q.question, selected.value, correct);
          }
        }
      });

      const percentage = Math.round((correctAnswers / totalQuestions) * 100);
      document.getElementById("popupScore").textContent =
        `${correctAnswers}/${totalQuestions} (${percentage}%)`;
      document.getElementById("popupComment").innerHTML =
        getResultComment(percentage);
      document.getElementById("resultOverlay").style.display = "block";
      document.getElementById("resultPopup").style.display = "block";
      saveQuizHistory(correctAnswers, percentage);
      document.getElementById("showAnswersBtn").style.display = "flex";
      form
        .querySelectorAll("input")
        .forEach((input) => (input.disabled = true));
      pauseTimer();
      // ===== THÊM ĐOẠN NÀY ĐỂ KÍCH HOẠT PHÁO HOA KHI ĐẠT 100% =====
      if (percentage === 100) {
        launchFireworks();
        tryMarkPerfect();
        // Phát âm thanh nếu muốn (cần sự tương tác của user trước đó)
        // playVictorySound();

        // Thêm hiệu ứng đặc biệt cho popup
        const popup = document.getElementById("resultPopup");
        popup.style.animation = "popup-appear 0.3s, glow-pulse 1s infinite";

        // Thêm class đặc biệt
        popup.classList.add("perfect-score");

        // Tạo thông báo
        // Tạo thông báo
        // Tạo thông báo perfect và đưa lên trên cùng
        const perfectMsg = document.createElement("div");
        perfectMsg.style.cssText = `
  position: fixed;
  top: 15%;  /* Đưa lên cao hơn */
  left: 50%;
  transform: translateX(-50%);
  background: linear-gradient(135deg, gold, #ffaa00);
  color: #000;
  padding: 15px 35px;
  border-radius: 60px;
  font-size: 36px;
  font-weight: 900;
  z-index: 200001;  /* Cao hơn popup */
  animation: perfect-float 0.8s ease infinite alternate;
  text-shadow: 2px 2px 4px rgba(255,255,255,0.5);
  box-shadow: 0 0 50px gold, 0 10px 20px rgba(0,0,0,0.3);
  border: 3px solid white;
  letter-spacing: 2px;
  white-space: nowrap;
  font-family: 'Orbitron', sans-serif;
`;

        perfectMsg.innerHTML = "🏆 PERFECT! 100% 🏆";
        document.body.appendChild(perfectMsg);

        // Thêm animation riêng cho perfect message
        const style = document.createElement("style");
        style.innerHTML = `
  @keyframes perfect-float {
    0% {
      transform: translateX(-50%) translateY(0);
      box-shadow: 0 0 50px gold, 0 10px 20px rgba(0,0,0,0.3);
    }
    100% {
      transform: translateX(-50%) translateY(-15px);
      box-shadow: 0 0 70px #ffaa00, 0 20px 30px rgba(0,0,0,0.4);
    }
  }
`;
        document.head.appendChild(style);

        setTimeout(() => {
          perfectMsg.remove();
          style.remove(); // Xóa cả style khi kết thúc
        }, 4000);
      }
    }

    function resetQuiz() {
      const form = document.getElementById("quizForm");
      if (form) form.reset();
      Object.values(readingTimers).forEach((obj) => {
        if (obj.intervalId) clearInterval(obj.intervalId);
      });
      renderQuiz();
      closeResultPopup();

      // XÓA HIỆU ỨNG 100 ĐIỂM
      const popup = document.getElementById("resultPopup");
      popup.classList.remove("perfect-score");
      popup.style.animation = ""; // Xóa animation inline nếu có
      popup.style.borderColor = ""; // Reset về màu mặc định
      popup.style.boxShadow = ""; // Reset box-shadow

      document.getElementById("showAnswersBtn").style.display = "none";
      document.getElementById("showAnswersBtn").disabled = false;
      resetTimer();
    }

    function showCorrectAnswers() {
      quizData.forEach((q, idx) => {
        if (q.isReading && q.subQuestions) {
          q.subQuestions.forEach((subQ, subIdx) => {
            const name = `q${idx}_${subIdx}`;
            const correct =
              (window.answers && window.answers[name]) ||
              (window.quizAnswers && window.quizAnswers[name]);
            document
              .querySelectorAll(`input[name='${name}']`)
              .forEach((input) => {
                const label = input.parentElement;
                if (
                  input.value === correct &&
                  !label.innerHTML.includes("✅ Đáp án đúng")
                ) {
                  label.innerHTML +=
                    ' <span class="correct-answer">✅ Đáp án đúng</span>';
                }
              });
          });
        } else {
          const name = `q${idx}`;
          const correct =
            (window.answers && window.answers[name]) ||
            (window.quizAnswers && window.quizAnswers[name]);
          document
            .querySelectorAll(`input[name='${name}']`)
            .forEach((input) => {
              const label = input.parentElement;
              if (
                input.value === correct &&
                !label.innerHTML.includes("✅ Đáp án đúng")
              ) {
                label.innerHTML +=
                  ' <span class="correct-answer">✅ Đáp án đúng</span>';
              }
            });
        }
      });
      document.getElementById("showAnswersBtn").disabled = true;
    }
    let __scrollY = 0;

    function lockBodyScroll() {
      __scrollY = window.scrollY || document.documentElement.scrollTop || 0;

      // bù độ rộng scrollbar để khỏi “giật” layout
      const scrollbarWidth =
        window.innerWidth - document.documentElement.clientWidth;

      document.body.classList.add("modal-open");
      document.body.style.position = "fixed";
      document.body.style.top = `-${__scrollY}px`;
      document.body.style.left = "0";
      document.body.style.right = "0";
      document.body.style.width = "100%";
      document.body.style.paddingRight = scrollbarWidth
        ? `${scrollbarWidth}px`
        : "";
    }

    function unlockBodyScroll() {
      document.body.classList.remove("modal-open");
      document.body.style.position = "";
      document.body.style.top = "";
      document.body.style.left = "";
      document.body.style.right = "";
      document.body.style.width = "";
      document.body.style.paddingRight = "";

      window.scrollTo(0, __scrollY);
    }

    function showQuestionDetail(index) {
      const question = quizData[index];
      const detailValue = question.detail || "Không có chi tiết bổ sung";

      // Tạo popup
      const detailPopup = document.createElement("div");
      detailPopup.className = "detail-popup";

      detailPopup.innerHTML = `
    <div class="detail-popup-inner">
      <div class="detail-popup-header">
        <h3 class="detail-popup-title">
          <i class="fas fa-info-circle"></i> GIẢI THÍCH
        </h3>
        <button class="detail-popup-close test-modal-close" type="button">
          Đóng
        </button>
      </div>

      <div class="detail-scroll">
        <p style="margin:0;">${detailValue}</p>
      </div>
    </div>
  `;

      // ===== HÀM ĐÓNG POPUP =====
      function closePopup() {
        detailPopup.remove();
        unlockBodyScroll();
        document.removeEventListener("keydown", handleEsc);
      }

      // ===== ĐÓNG BẰNG NÚT =====
      const closeBtn = detailPopup.querySelector(".detail-popup-close");
      closeBtn.addEventListener("click", closePopup);

      // ===== CLICK RA NGOÀI ĐỂ ĐÓNG (THÊM MỚI) =====
      function handleClickOutside(e) {
        // Kiểm tra nếu click vào phần tử không nằm trong popup
        if (!detailPopup.contains(e.target)) {
          closePopup();
        }
      }
      // Thêm event listener cho toàn bộ document
      document.addEventListener("mousedown", handleClickOutside);

      // ===== ĐÓNG BẰNG ESC =====
      function handleEsc(e) {
        if (e.key === "Escape") {
          closePopup();
        }
      }

      document.addEventListener("keydown", handleEsc);

      // ===== KHÓA SCROLL NGOÀI =====
      lockBodyScroll();

      // Thêm popup vào body
      document.body.appendChild(detailPopup);
    }

    function getResultComment(percentage) {
      if (percentage >= 90) return "🏆 素晴らしいいいい - Xuất sắc!";
      if (percentage >= 70) return "🌟 いいね！ - Khá tốt!";
      if (percentage >= 50) return "📚 いいよー - Cần cố gắng thêm!";
      return "💪 大丈夫、頑張れ！ - Đừng nản, cố lên!";
    }

    function saveQuizHistory(score, percentage) {
      const list = document.getElementById("quizHistory");
      if (!list) return;
      const time = new Date().toLocaleTimeString("vi-VN");
      const li = document.createElement("li");
      li.innerHTML = `<span><i class="fas fa-clock"></i> ${time}</span><span style="color: var(--secondary-glow);">${score}/${Object.keys(window.quizAnswers || {}).length} (${percentage}%)</span><button onclick="this.parentElement.remove()" style="background: none; border: none; color: #ff6b6b; cursor: pointer;">×</button>`;
      list.prepend(li);
    }

    function closeResultPopup() {
      document.getElementById("resultPopup").style.display = "none";
      document.getElementById("resultOverlay").style.display = "none";
      // Xóa class perfect-score nếu có
      document
        .getElementById("resultPopup")
        .classList.remove("perfect-score");
    }

    // ==================== WRONG ANSWERS ====================
    function saveWrongAnswer(
      questionKey,
      questionText,
      userAnswer,
      correctAnswer,
    ) {
      let wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      wrongAnswers.push({
        id: Date.now(),
        questionKey,
        questionText,
        userAnswer,
        correctAnswer,
        timestamp: new Date().toLocaleString("vi-VN"),
      });
      localStorage.setItem("wrongAnswers", JSON.stringify(wrongAnswers));
      updateWrongAnswersBadge();
      displayWrongAnswers();
    }

    function displayWrongAnswers() {
      const wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      const container = document.getElementById("wrongAnswersList");
      if (!container) return;
      if (wrongAnswers.length === 0) {
        container.innerHTML =
          '<p style="text-align: center; color: #999; padding: 20px;">🎉 Chưa có câu sai nào!</p>';
        return;
      }
      let html = "";
      wrongAnswers
        .sort((a, b) => b.timestamp.localeCompare(a.timestamp))
        .forEach((item, index) => {
          html += `
          <div class="wrong-answer-item">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <strong style="color: #ff3366;">#${index + 1}</strong>
              <button onclick="removeWrongAnswer(${item.id})" style="background: none; border: none; color: #ff3366; cursor: pointer; font-size: 16px;">✕</button>
            </div>
            <p style="margin-bottom: 8px; font-size: 14px;">${item.questionText}</p>
            <div style="display: flex; gap: 15px; font-size: 13px;">
              <span style="color: #ff6b6b;">❌ ${item.userAnswer}</span>
              <span style="color: #00ff88;">✅ ${item.correctAnswer}</span>
              <span style="color: #999;">${item.timestamp}</span>
            </div>
          </div>
        `;
        });
      container.innerHTML = html;
    }

    function updateWrongAnswersBadge() {
      const wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      const badge = document.getElementById("wrongAnswersBadge");
      if (badge) {
        badge.textContent = wrongAnswers.length;
        badge.style.display = wrongAnswers.length > 0 ? "flex" : "none";
      }
    }

    function showWrongAnswers() {
      displayWrongAnswers();
      const leftPanel = document.getElementById("leftSidebarPanel");
      const leftFloatingBtn = document.getElementById("leftFloatingBtn");
      const wrapper = document.getElementById("mainContentWrapper");
      if (!leftPanel.classList.contains("active")) {
        leftPanel.classList.add("active");
        leftFloatingBtn.classList.add("hidden");
        wrapper.classList.add("left-expanded");
        localStorage.setItem("leftSidebarActive", "true");
      }
    }

    function removeWrongAnswer(id) {
      let wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      wrongAnswers = wrongAnswers.filter((item) => item.id !== id);
      localStorage.setItem("wrongAnswers", JSON.stringify(wrongAnswers));
      displayWrongAnswers();
      updateWrongAnswersBadge();
    }

    function clearWrongAnswers() {
      if (confirm("Bạn có chắc muốn xóa tất cả lịch sử câu sai?")) {
        localStorage.removeItem("wrongAnswers");
        displayWrongAnswers();
        updateWrongAnswersBadge();
      }
    }

    function practiceWrongAnswers() {
      const wrongAnswers = JSON.parse(
        localStorage.getItem("wrongAnswers") || "[]",
      );
      if (wrongAnswers.length === 0) {
        alert("🎉 Chưa có câu sai nào để luyện tập!");
        return;
      }
      alert("🚀 Chức năng luyện tập đang phát triển!");
    }

    // ==================== CẬP NHẬT ĐÁP ÁN - SỬA THEO YÊU CẦU ====================
    function findKeyBySubQNumber(number) {
      for (let i = 0; i < quizData.length; i++) {
        const q = quizData[i];
        if (!q.isReading) {
          if (q.number == number) return `q${i}`;
        } else if (q.subQuestions) {
          for (let j = 0; j < q.subQuestions.length; j++) {
            const subQ = q.subQuestions[j];
            if (subQ.number == number) return `q${i}_${j}`;
          }
        }
      }
      return null;
    }

    function updateAnswer() {
      let keyOrNumber = document.getElementById("editKey").value.trim();
      const value = document.getElementById("editValue").value.trim();

      if (!window.answers) window.answers = {};

      // Nếu nhập số, tự động dò key theo subQ.number
      if (/^\d+(\.\d+)?$/.test(keyOrNumber)) {
        const mappedKey = findKeyBySubQNumber(keyOrNumber);
        if (!mappedKey) {
          alert(`❌ Không tìm thấy câu hỏi số ${keyOrNumber}!`);
          return;
        }
        keyOrNumber = mappedKey;
      }

      if (keyOrNumber && value) {
        window.answers[keyOrNumber] = value;
        localStorage.setItem("customAnswers", JSON.stringify(window.answers));
        alert(
          `✅ Đáp án của ${keyOrNumber} đã được cập nhật thành ${value}.`,
        );
        document.getElementById("editKey").value = "";
        document.getElementById("editValue").value = "";
      } else {
        alert("❌ Vui lòng nhập đầy đủ thông tin!");
      }
    }

    function clearUpdatedAnswers() {
      const ok = confirm("Bạn có chắc muốn xóa cập nhật đáp án không?");
      if (!ok) return;
      localStorage.removeItem("customAnswers");
      window.answers = {};
      alert("✅ Đã xóa hết các cập nhật đáp án.");
    }

    /* Dark mode toggle functions removed */
    // ==================== BACK TO TOP ====================
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function updateBackToTopVisibility() {
      const btn = document.getElementById("backToTopBtn");
      if (!btn) return;
      if (window.scrollY > 300) btn.classList.add("show");
      else btn.classList.remove("show");
    }

    // ==================== INITIALIZATION ====================
    window.onload = function () {
      renderQuiz();
      updateTimerDisplay();
      displayWrongAnswers();
      updateWrongAnswersBadge();

      /* Dark mode feature removed; no persisted setting applied */

      const leftActive = localStorage.getItem("leftSidebarActive") === "true";
      const rightActive =
        localStorage.getItem("rightSidebarActive") === "true";
      const wrapper = document.getElementById("mainContentWrapper");

      if (leftActive) {
        document.getElementById("leftSidebarPanel").classList.add("active");
        document.getElementById("leftFloatingBtn").classList.add("hidden");
        wrapper.classList.add("left-expanded");
      }
      if (rightActive) {
        document.getElementById("rightSidebarPanel").classList.add("active");
        document.getElementById("rightFloatingBtn").classList.add("hidden");
        wrapper.classList.add("right-expanded");
      }
    };

    // Scroll handler
    window.addEventListener("scroll", function () {
      updateBackToTopVisibility();
    });

    // Event listeners
    document
      .getElementById("clearAnswersBtn")
      .addEventListener("click", clearUpdatedAnswers);
    // ==================== MAIN AUDIO PLAYER FUNCTIONS - GIỮ NGUYÊN TRẠNG THÁI BAN ĐẦU THEO EXCEL ====================
    let mainAudio = null;
    let isMainAudioPlaying = false;
    let previousVolume = 1; // Lưu volume trước khi mute
    let isSeeking = false; // Đang tua thì không cập nhật thanh trượt

    // Sử dụng multiple event listeners để đảm bảo DOM đã sẵn sàng
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOMContentLoaded - Đang khởi tạo audio player...");
        setTimeout(initAudioPlayer, 100);
      });
    } else {
      console.log("DOM đã sẵn sàng - Đang khởi tạo audio player...");
      setTimeout(initAudioPlayer, 100);
    }

    // Hàm khởi tạo chính
    function getHtmlSelectedOption(selectEl) {
      // Lấy option có ATTRIBUTE selected trong HTML (không phải property do browser restore)
      let opt = selectEl.querySelector("option[selected]");
      if (!opt) {
        // fallback an toàn: nếu không có, dùng option đang selectedIndex hoặc option đầu
        opt =
          selectEl.options[selectEl.selectedIndex] ||
          selectEl.options[0] ||
          null;
      }
      return opt;
    }

    function forceBackToHtmlDefault(selectEl) {
      const htmlSelected = getHtmlSelectedOption(selectEl);
      if (!htmlSelected) return null;

      // Ép select quay đúng về default theo HTML
      selectEl.value = htmlSelected.value;
      return htmlSelected;
    }

    function disableAudioControls(reasonText) {
      const btn = document.getElementById("mainPlayPauseBtn");
      const seekBar = document.getElementById("mainSeekBar");

      if (btn) {
        btn.disabled = true;
        btn.style.opacity = "0.5";
        btn.style.cursor = "not-allowed";
        btn.title = reasonText ? reasonText : "Không có file audio hợp lệ";
      }

      if (seekBar) {
        seekBar.disabled = true;
        seekBar.style.opacity = "0.5";
        seekBar.style.cursor = "not-allowed";
      }

      if (mainAudio) {
        mainAudio.pause();
        isMainAudioPlaying = false;
        mainAudio.removeAttribute("src");
        while (mainAudio.firstChild)
          mainAudio.removeChild(mainAudio.firstChild);
        mainAudio.load();
      }
    }

    function loadFromHtmlSelectedOption() {
      const audioSelect = document.getElementById("mainAudioSelect");
      if (!audioSelect) return;

      // 1) MỖI LẦN LOAD: ép về option có attribute selected trong HTML
      const htmlSelected = forceBackToHtmlDefault(audioSelect);
      if (!htmlSelected) return;

      // 2) JS LUÔN LẤY option đang selected TRONG SELECT để load
      const opt = audioSelect.options[audioSelect.selectedIndex];
      const val = opt ? opt.value : "";

      if (val) {
        changeAudioFile(val);
      } else {
        // Trường hợp warning option (disabled + selected) hoặc option trống
        disableAudioControls(opt ? opt.textContent.trim() : "");
      }

      // 3) CHỈ restore tốc độ phát (được phép)
      restorePlaybackSpeed();
    }

    function initAudioPlayer() {
      initMainAudio();
      // ===== THÊM ĐOẠN NÀY ĐỂ ĐẢM BẢO VOLUME 50% =====
      const volumeSlider = document.getElementById("mainVolumeSlider");
      if (mainAudio && volumeSlider) {
        mainAudio.volume = 0.5;
        volumeSlider.value = 0.5;
        previousVolume = 0.5; // Cập nhật previousVolume
        updateVolumeIcon();
      }

      // Load mặc định ngay sau khi init
      loadFromHtmlSelectedOption();
    }

    // DOM ready
    document.addEventListener("DOMContentLoaded", initAudioPlayer);

    // BẮT BUỘC: xử lý back/forward cache + refresh kiểu restore form state
    window.addEventListener("pageshow", function () {
      loadFromHtmlSelectedOption();
    });

    // Hàm load audio mặc định từ selected option
    function loadDefaultAudio() {
      console.log("loadDefaultAudio được gọi");

      const audioSelect = document.getElementById("mainAudioSelect");
      if (!audioSelect) {
        console.error("Không tìm thấy mainAudioSelect");
        return;
      }

      // Log để debug
      console.log("Số lượng options:", audioSelect.options.length);
      for (let i = 0; i < audioSelect.options.length; i++) {
        console.log(
          `Option ${i}: value="${audioSelect.options[i].value}", selected=${audioSelect.options[i].selected}, text="${audioSelect.options[i].text}"`,
        );
      }

      // Lấy option đang được selected trong HTML (do Java code set)
      const selectedIndex = audioSelect.selectedIndex;
      console.log("selectedIndex:", selectedIndex);

      if (selectedIndex === -1) {
        console.log("Không có option nào được selected");
        return;
      }

      const selectedOption = audioSelect.options[selectedIndex];
      console.log("Selected option:", selectedOption);

      if (!selectedOption) {
        console.log("Không tìm thấy selected option");
        return;
      }

      const selectedValue = selectedOption.value;
      console.log("Selected value:", selectedValue);

      // KHÔNG lưu vào localStorage, chỉ dựa vào selected từ HTML
      if (selectedValue && selectedValue !== "") {
        // Có file được chọn (file Excel tồn tại)
        console.log("Load file mặc định từ Excel:", selectedValue);
        changeAudioFile(selectedValue);
      } else {
        // Không có giá trị (option thông báo đang được selected)
        console.log("File Excel không tồn tại, hiển thị thông báo");

        // Disable nút play
        const btn = document.getElementById("mainPlayPauseBtn");
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.cursor = "not-allowed";
          btn.title =
            "Không tìm thấy file audio từ Excel: " +
            (selectedOption.text || "").replace("⚠️ ", "");
        }

        // Disable thanh seek bar
        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.disabled = true;
          seekBar.style.opacity = "0.5";
          seekBar.style.cursor = "not-allowed";
        }

        // Reset audio element
        if (mainAudio) {
          mainAudio.pause();
          mainAudio.removeAttribute("src");
          while (mainAudio.firstChild) {
            mainAudio.removeChild(mainAudio.firstChild);
          }
          mainAudio.load();
        }
      }

      // Khôi phục tốc độ phát (giữ nguyên nếu muốn)
      restorePlaybackSpeed();
    }

    function initMainAudio() {
      mainAudio = document.getElementById("mainAudio");
      if (!mainAudio) {
        console.error("Không tìm thấy element audio!");
        return;
      }
      console.log("Đã tìm thấy mainAudio");
      mainAudio.volume = 0.5;  // 0.5 = 50%

      // Volume control
      const volumeSlider = document.getElementById("mainVolumeSlider");
      if (volumeSlider) {
        volumeSlider.value = 0.5;
        volumeSlider.addEventListener("input", function (e) {
          if (mainAudio) {
            const volume = parseFloat(e.target.value);
            mainAudio.volume = volume;
            mainAudio.muted = volume === 0;
            previousVolume = volume > 0 ? volume : previousVolume;
            updateVolumeIcon();
            console.log("Volume:", volume);
          }
        });
      }

      // Time update
      mainAudio.addEventListener("timeupdate", function () {
        if (!isSeeking) {
          updateSeekBar();
        }
        updateMainAudioTime();
        updateCurrentTime();
      });

      // Audio ended
      mainAudio.addEventListener("ended", function () {
        console.log("Audio kết thúc");
        isMainAudioPlaying = false;
        const btn = document.getElementById("mainPlayPauseBtn");
        if (btn) {
          btn.innerHTML = '<i class="fas fa-play"></i> Phát';
          btn.style.background = "linear-gradient(135deg, #00cc66, #00ff88)";
        }

        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.value = 0;
        }
      });

      // Load metadata
      mainAudio.addEventListener("loadedmetadata", function () {
        console.log("Đã tải metadata, duration:", mainAudio.duration);
        updateMainAudioTime();
        updateDuration();

        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.max = 100;
        }

        // Áp dụng tốc độ đã lưu
        const savedSpeed = localStorage.getItem("audioPlaybackSpeed");
        if (savedSpeed && mainAudio) {
          mainAudio.playbackRate = parseFloat(savedSpeed);
        }

        // Tự động phát lại nếu đang ở chế độ phát
        if (isMainAudioPlaying) {
          mainAudio
            .play()
            .catch((e) => console.log("Không thể tự động phát:", e));
        }
      });

      // Error handling
      mainAudio.addEventListener("error", function (e) {
        console.error("Lỗi audio:", e);
        showAudioError();
      });
    }

    // Hàm thay đổi file audio từ dropdown
    function changeAudioFile(fileName) {
      console.log("changeAudioFile được gọi với fileName:", fileName);

      if (!fileName || fileName === "") {
        console.log("fileName rỗng, disable controls");

        // Disable các controls
        const btn = document.getElementById("mainPlayPauseBtn");
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.cursor = "not-allowed";
          btn.title = "Vui lòng chọn file audio hợp lệ";
        }

        const seekBar = document.getElementById("mainSeekBar");
        if (seekBar) {
          seekBar.disabled = true;
          seekBar.style.opacity = "0.5";
          seekBar.style.cursor = "not-allowed";
        }

        // Dừng audio hiện tại
        if (mainAudio) {
          mainAudio.pause();
          isMainAudioPlaying = false;
        }

        return;
      }

      console.log("Chuyển sang file audio:", fileName);
      loadAudioFile(fileName);

      // Enable các controls
      const btn = document.getElementById("mainPlayPauseBtn");
      if (btn) {
        btn.disabled = false;
        btn.style.opacity = "1";
        btn.style.cursor = "pointer";
        btn.title = "";
      }

      const seekBar = document.getElementById("mainSeekBar");
      if (seekBar) {
        seekBar.disabled = false;
        seekBar.style.opacity = "1";
        seekBar.style.cursor = "pointer";
      }
    }

    // Hàm tải file audio
    function loadAudioFile(fileName) {
      if (!fileName) return;

      console.log("loadAudioFile:", fileName);

      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
        if (!mainAudio) {
          console.error("Không tìm thấy mainAudio trong loadAudioFile");
          return;
        }
      }

      // Dừng audio hiện tại
      mainAudio.pause();
      isMainAudioPlaying = false;

      // Cập nhật UI
      const btn = document.getElementById("mainPlayPauseBtn");
      if (btn) {
        btn.innerHTML = '<i class="fas fa-play"></i> Phát';
        btn.style.background = "linear-gradient(135deg, #00cc66, #00ff88)";
      }

      // Tạo đường dẫn mới
      const audioPath = "audios/" + fileName;
      console.log("Đang tải audio:", audioPath);

      // Xóa các source cũ
      while (mainAudio.firstChild) {
        mainAudio.removeChild(mainAudio.firstChild);
      }

      // Thêm source mới
      const fileExt = fileName.split(".").pop().toLowerCase();
      let mimeType = "audio/mpeg";
      if (fileExt === "m4a") mimeType = "audio/mp4";
      else if (fileExt === "wav") mimeType = "audio/wav";
      else if (fileExt === "ogg") mimeType = "audio/ogg";

      const source = document.createElement("source");
      source.src = audioPath;
      source.type = mimeType;
      mainAudio.appendChild(source);

      // Load lại audio
      mainAudio.load();

      // Reset seek bar
      const seekBar = document.getElementById("mainSeekBar");
      if (seekBar) {
        seekBar.value = 0;
        seekBar.disabled = false;
      }

      // Reset thời gian hiển thị
      document.getElementById("mainCurrentTime").textContent = "00:00";
      document.getElementById("mainDuration").textContent = "00:00";
      document.getElementById("mainAudioTime").textContent = "00:00";
    }

    // Hàm khôi phục tốc độ phát
    function restorePlaybackSpeed() {
      const savedSpeed = localStorage.getItem("audioPlaybackSpeed");
      const speedSelect = document.getElementById("mainSpeedSelect");

      if (savedSpeed && speedSelect) {
        speedSelect.value = savedSpeed;
        console.log("Đã khôi phục tốc độ phát:", savedSpeed);

        if (mainAudio) {
          mainAudio.playbackRate = parseFloat(savedSpeed);
        }
      }
    }

    // Hàm thay đổi tốc độ phát
    function changePlaybackSpeed(speed) {
      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
      }

      if (mainAudio) {
        const speedValue = parseFloat(speed);
        mainAudio.playbackRate = speedValue;
        console.log("Tốc độ phát:", mainAudio.playbackRate);

        // Lưu tốc độ vào localStorage (chỉ lưu tốc độ, không lưu file)
        localStorage.setItem("audioPlaybackSpeed", speed);

        showSpeedNotification(speed);
      }
    }

    // Các hàm còn lại giữ nguyên...
    function showSpeedNotification(speed) {
      const oldNotif = document.getElementById("speedNotification");
      if (oldNotif) oldNotif.remove();

      const notif = document.createElement("div");
      notif.id = "speedNotification";
      notif.innerHTML = `⚡ Tốc độ: ${speed}x`;
      notif.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, var(--primary-glow), var(--secondary-glow));
        color: #0a0e17;
        padding: 10px 25px;
        border-radius: 30px;
        font-weight: bold;
        z-index: 100000;
        animation: speedFade 2s forwards;
        box-shadow: 0 0 20px rgba(0,255,204,0.5);
        border: 2px solid white;
    `;

      const style = document.createElement("style");
      style.innerHTML = `
        @keyframes speedFade {
            0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
        }
    `;
      document.head.appendChild(style);

      document.body.appendChild(notif);

      setTimeout(() => {
        if (notif) notif.remove();
        if (style) style.remove();
      }, 2000);
    }

    function updateVolumeIcon() {
      const icon = document.getElementById("mainVolumeIcon");
      if (!icon || !mainAudio) return;

      if (mainAudio.muted || mainAudio.volume === 0) {
        icon.className = "fas fa-volume-mute";
      } else if (mainAudio.volume < 0.5) {
        icon.className = "fas fa-volume-down";
      } else {
        icon.className = "fas fa-volume-up";
      }
    }

    function toggleMute(event) {
      if (event) {
        event.stopPropagation();
      }

      console.log("toggleMute được gọi");

      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
        if (!mainAudio) {
          alert("Không tìm thấy audio!");
          return;
        }
      }

      const icon = document.getElementById("mainVolumeIcon");
      const volumeSlider = document.getElementById("mainVolumeSlider");

      if (!icon || !volumeSlider) return;

      if (mainAudio.muted) {
        mainAudio.muted = false;
        mainAudio.volume = previousVolume;
        volumeSlider.value = previousVolume;
      } else {
        previousVolume = mainAudio.volume > 0 ? mainAudio.volume : 1;
        mainAudio.muted = true;
        volumeSlider.value = 0;
      }

      updateVolumeIcon();
      console.log("Mute state:", mainAudio.muted);
    }

    function toggleMainAudio() {
      console.log("toggleMainAudio được gọi");

      if (!mainAudio) {
        mainAudio = document.getElementById("mainAudio");
        if (!mainAudio) {
          alert("Không tìm thấy audio! Vui lòng load lại trang.");
          return;
        }
      }

      const btn = document.getElementById("mainPlayPauseBtn");
      if (!btn) return;

      if (isMainAudioPlaying) {
        mainAudio.pause();
        btn.innerHTML = '<i class="fas fa-play"></i> Phát';
        btn.style.background = "linear-gradient(135deg, #00cc66, #00ff88)";
        isMainAudioPlaying = false;
        console.log("Đã tạm dừng audio");
      } else {
        console.log("Đang thử phát audio...");

        // Kiểm tra xem có source không
        if (!mainAudio.querySelector("source") && !mainAudio.src) {
          // Nếu không có source, lấy từ dropdown hiện tại
          const audioSelect = document.getElementById("mainAudioSelect");
          if (audioSelect && audioSelect.value) {
            loadAudioFile(audioSelect.value);
          } else {
            alert("Không có file audio nào được chọn!");
            return;
          }
        }

        var playPromise = mainAudio.play();

        if (playPromise !== undefined) {
          playPromise
            .then(function () {
              console.log("Play audio thành công!");
              btn.innerHTML = '<i class="fas fa-pause"></i> Dừng';
              btn.style.background =
                "linear-gradient(135deg, #ff3333, #ff6600)";
              isMainAudioPlaying = true;
              updateDuration();

              const savedSpeed = localStorage.getItem("audioPlaybackSpeed");
              if (
                savedSpeed &&
                mainAudio.playbackRate !== parseFloat(savedSpeed)
              ) {
                mainAudio.playbackRate = parseFloat(savedSpeed);
              }
            })
            .catch(function (error) {
              console.error("Lỗi khi play audio:", error);

              if (error.name === "NotAllowedError") {
                alert(
                  "Trình duyệt chặn phát audio. Vui lòng nhấn nút Phát lại!",
                );
              } else if (error.name === "NotSupportedError") {
                alert("Định dạng audio không được hỗ trợ!");
              } else {
                alert("Không thể phát audio. Lỗi: " + error.message);
              }

              btn.innerHTML = '<i class="fas fa-play"></i> Phát lại';
              btn.style.background =
                "linear-gradient(135deg, #00cc66, #00ff88)";
            });
        }
      }
    }

    function updateMainAudioTime() {
      const timeSpan = document.getElementById("mainAudioTime");
      if (!timeSpan || !mainAudio) return;

      const remaining = Math.max(
        0,
        (mainAudio.duration || 0) - (mainAudio.currentTime || 0),
      );
      const remainingFormatted = formatTime(remaining);
      timeSpan.textContent = remainingFormatted;
    }

    function formatTime(seconds) {
      if (isNaN(seconds) || seconds === Infinity || seconds <= 0)
        return "00:00";
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
    }

    function updateDuration() {
      const durationSpan = document.getElementById("mainDuration");
      if (durationSpan && mainAudio) {
        durationSpan.textContent = formatTime(mainAudio.duration || 0);
      }
    }

    function updateCurrentTime() {
      const currentSpan = document.getElementById("mainCurrentTime");
      if (currentSpan && mainAudio) {
        currentSpan.textContent = formatTime(mainAudio.currentTime || 0);
      }
    }

    function updateSeekBar() {
      const seekBar = document.getElementById("mainSeekBar");
      if (seekBar && mainAudio && mainAudio.duration && !seekBar.disabled) {
        const percent = (mainAudio.currentTime / mainAudio.duration) * 100;
        seekBar.value = percent;
      }
    }

    function seekAudio(value) {
      if (!mainAudio || !mainAudio.duration) return;

      isSeeking = true;
      const seekTime = (value / 100) * mainAudio.duration;
      mainAudio.currentTime = seekTime;

      updateCurrentTime();

      setTimeout(() => {
        isSeeking = false;
      }, 100);
    }

    function showAudioError() {
      const btn = document.getElementById("mainPlayPauseBtn");
      if (btn) {
        btn.innerHTML =
          '<i class="fas fa-exclamation-triangle"></i> Lỗi file';
        btn.style.background = "linear-gradient(135deg, #ff3333, #ff6600)";
      }
    }

    // Hàm reset tốc độ về mặc định (1x)
    function resetPlaybackSpeed() {
      const defaultSpeed = "1";

      localStorage.removeItem("audioPlaybackSpeed");

      const speedSelect = document.getElementById("mainSpeedSelect");
      if (speedSelect) {
        speedSelect.value = defaultSpeed;
      }

      if (mainAudio) {
        mainAudio.playbackRate = 1;
      }

      showSpeedNotification(defaultSpeed);
      console.log("Đã reset tốc độ về 1x");
    }
    
  </script>
    <!-- CYBER LOADING OVERLAY - GIỐNG INDEX.HTML -->
  <div class="cyber-loading" id="cyberLoading">
    <div class="cyber-loading-box">
      <div class="cyber-loading-title">
        <span id="cyberLoadingText">ĐANG TẢI DỮ LIỆU</span>
        <span id="cyberLoadingPercent" style="margin-left: 10px">0%</span>
      </div>
      <div class="cyber-loading-bar">
        <div class="cyber-loading-bar-fill"></div>
      </div>
      <div class="cyber-loading-sub">SYSTEM PROCESSING...</div>
    </div>
  </div>

  <!-- SCRIPT LOADING - GIỐNG INDEX.HTML -->
  <script>
    let __loadingTimer = null;
    let __loadingPct = 0;

    function showCyberLoading(text = "ĐANG TẢI DỮ LIỆU") {
      const loading = document.getElementById("cyberLoading");

      // Nếu đang mở rồi thì chỉ đổi text, không reset % (tránh giật/quay lại 0)
      if (loading.classList.contains("show")) {
        const textEl = document.getElementById("cyberLoadingText");
        if (textEl) textEl.textContent = text;
        return;
      }

      const textEl = document.getElementById("cyberLoadingText");
      const pctEl = document.getElementById("cyberLoadingPercent");
      const bar = document.querySelector(".cyber-loading-bar-fill");

      textEl.textContent = text;

      __loadingPct = 0;
      if (pctEl) pctEl.textContent = "0%";
      if (bar) bar.style.width = "0%";

      loading.classList.add("show");

      if (__loadingTimer) clearInterval(__loadingTimer);
      __loadingTimer = setInterval(() => {
        const step = __loadingPct < 50 ? 3 : __loadingPct < 80 ? 2 : 1;
        __loadingPct = Math.min(90, __loadingPct + step);
        if (pctEl) pctEl.textContent = `${__loadingPct}%`;
        if (bar) bar.style.width = `${__loadingPct}%`;
      }, 120);
    }

    function hideCyberLoading() {
      const loading = document.getElementById("cyberLoading");
      const pctEl = document.getElementById("cyberLoadingPercent");
      const bar = document.querySelector(".cyber-loading-bar-fill");

      // kết thúc thật: lên 100%
      if (__loadingTimer) clearInterval(__loadingTimer);
      __loadingTimer = null;

      __loadingPct = 100;
      if (pctEl) pctEl.textContent = "100%";
      if (bar) bar.style.width = "100%";

      // giữ 1 nhịp cho người dùng thấy full rồi tắt
      setTimeout(() => {
        loading.classList.remove("show");
      }, 180);
    }

    // Tự động hiển thị loading khi trang bắt đầu load
    (function() {
      // Hiển thị loading ngay lập tức
      showCyberLoading("ĐANG TẢI BÀI TEST");
      
      // Ẩn loading khi trang đã load xong
      window.addEventListener('load', function() {
        hideCyberLoading();
      });
      
      // Fallback: Ẩn sau 3 giây nếu load quá lâu
      setTimeout(function() {
        hideCyberLoading();
      }, 3000);
    })();
  </script>

  <!-- THÊM CSS CHO CYBER LOADING (nếu chưa có) -->
  <style>
    /* ================= CYBER LOADING ================= */
    .cyber-loading {
      position: fixed;
      inset: 0;
      background: rgba(2, 8, 18, 0.85);
      backdrop-filter: blur(12px);
      z-index: 20000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .cyber-loading.show {
      display: flex;
    }

    .cyber-loading-box {
      width: 420px;
      padding: 30px;
      border: 2px solid #00a8ff;
      border-radius: 14px;
      background: rgba(0, 20, 40, 0.95);
      text-align: center;
      box-shadow:
        0 0 25px rgba(0, 168, 255, 0.7),
        0 0 60px rgba(0, 100, 255, 0.4);
      animation: cyberGlow 3s infinite alternate;
    }

    @keyframes cyberGlow {
      0% {
        box-shadow: 0 0 20px rgba(0, 168, 255, 0.6);
      }
      100% {
        box-shadow: 0 0 50px rgba(0, 255, 204, 0.8);
      }
    }

    .cyber-loading-title {
      font-family: "Orbitron", sans-serif;
      font-size: 20px;
      letter-spacing: 2px;
      color: #00ffcc;
      margin-bottom: 20px;
      text-shadow: 0 0 15px rgba(0, 255, 204, 0.8);
      animation: cyberTextPulse 2.5s infinite alternate;
    }

    @keyframes cyberTextPulse {
      0% {
        opacity: 0.6;
      }
      100% {
        opacity: 1;
      }
    }

    .cyber-loading-bar {
      height: 8px;
      background: rgba(0, 50, 100, 0.4);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .cyber-loading-bar-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #0066cc, #00ffcc);
      transition: width 120ms linear;
      /* chạy mượt theo % */
    }

    .cyber-loading-sub {
      font-size: 12px;
      color: #88d3ff;
      letter-spacing: 1px;
    }
  </style>
</body>
</html>